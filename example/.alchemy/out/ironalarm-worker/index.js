var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all7) => {
  for (var name in all7)
    __defProp(target, name, { get: all7[name], enumerable: true });
};

// worker/index.ts
import { DurableObject } from "cloudflare:workers";

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Function.js
var isFunction = /* @__PURE__ */ __name((input) => typeof input === "function", "isFunction");
var dual = /* @__PURE__ */ __name(function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args3 = arguments;
        return function(self) {
          return body(self, ...args3);
        };
      };
  }
}, "dual");
var identity = /* @__PURE__ */ __name((a) => a, "identity");
var constant = /* @__PURE__ */ __name((value) => () => value, "constant");
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constUndefined = /* @__PURE__ */ constant(void 0);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
__name(pipe, "pipe");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Equivalence.js
var make = /* @__PURE__ */ __name((isEquivalent) => (self, that) => self === that || isEquivalent(self, that), "make");
var mapInput = /* @__PURE__ */ dual(2, (self, f) => make((x, y) => self(f(x), f(y))));
var array = /* @__PURE__ */ __name((item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
}), "array");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/doNotation.js
var let_ = /* @__PURE__ */ __name((map23) => dual(3, (self, name, f) => map23(self, (a) => ({
  ...a,
  [name]: f(a)
}))), "let_");
var bindTo = /* @__PURE__ */ __name((map23) => dual(2, (self, name) => map23(self, (a) => ({
  [name]: a
}))), "bindTo");
var bind = /* @__PURE__ */ __name((map23, flatMap19) => dual(3, (self, name, f) => flatMap19(self, (a) => map23(f(a), (b) => ({
  ...a,
  [name]: b
})))), "bind");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = /* @__PURE__ */ __name((id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
}, "globalValue");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Predicate.js
var isString = /* @__PURE__ */ __name((input) => typeof input === "string", "isString");
var isNumber = /* @__PURE__ */ __name((input) => typeof input === "number", "isNumber");
var isBigInt = /* @__PURE__ */ __name((input) => typeof input === "bigint", "isBigInt");
var isFunction2 = isFunction;
var isRecordOrArray = /* @__PURE__ */ __name((input) => typeof input === "object" && input !== null, "isRecordOrArray");
var isObject = /* @__PURE__ */ __name((input) => isRecordOrArray(input) || isFunction2(input), "isObject");
var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && property in self);
var isTagged = /* @__PURE__ */ dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
var isNullable = /* @__PURE__ */ __name((input) => input === null || input === void 0, "isNullable");
var isIterable = /* @__PURE__ */ __name((input) => typeof input === "string" || hasProperty(input, Symbol.iterator), "isIterable");
var isPromiseLike = /* @__PURE__ */ __name((input) => hasProperty(input, "then") && isFunction2(input.then), "isPromiseLike");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = /* @__PURE__ */ __name((message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`, "getBugErrorMessage");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var GenKindImpl = class {
  static {
    __name(this, "GenKindImpl");
  }
  value;
  constructor(value) {
    this.value = value;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  static {
    __name(this, "SingleShotGen");
  }
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  static {
    __name(this, "PCGRandom");
  }
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max9) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max9;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
__name(mul64, "mul64");
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
__name(add64, "add64");
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  static {
    __name(this, "YieldWrap");
  }
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
__name(yieldWrapGet, "yieldWrapGet");
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: /* @__PURE__ */ __name((body) => {
    return body();
  }, "effect_internal_function")
};
var forced = {
  effect_internal_function: /* @__PURE__ */ __name((body) => {
    try {
      return body();
    } finally {
    }
  }, "effect_internal_function")
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = /* @__PURE__ */ __name((u) => isObject(u) && u.constructor === genConstructor, "isGeneratorFunction");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = /* @__PURE__ */ __name((self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        if (Number.isNaN(self.getTime())) {
          return string("Invalid Date");
        }
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
}, "hash");
var random = /* @__PURE__ */ __name((self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
}, "random");
var combine = /* @__PURE__ */ __name((b) => (self) => self * 53 ^ b, "combine");
var optimize = /* @__PURE__ */ __name((n) => n & 3221225471 | n >>> 1 & 1073741824, "optimize");
var isHash = /* @__PURE__ */ __name((u) => hasProperty(u, symbol), "isHash");
var number = /* @__PURE__ */ __name((n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
}, "number");
var string = /* @__PURE__ */ __name((str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
}, "string");
var structureKeys = /* @__PURE__ */ __name((o, keys9) => {
  let h = 12289;
  for (let i = 0; i < keys9.length; i++) {
    h ^= pipe(string(keys9[i]), combine(hash(o[keys9[i]])));
  }
  return optimize(h);
}, "structureKeys");
var structure = /* @__PURE__ */ __name((o) => structureKeys(o, Object.keys(o)), "structure");
var array2 = /* @__PURE__ */ __name((arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
}, "array");
var cached = /* @__PURE__ */ __name(function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash4) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash4;
        },
        enumerable: false
      });
      return hash4;
    };
  }
  const self = arguments[0];
  const hash3 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash3;
    },
    enumerable: false
  });
  return hash3;
}, "cached");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
__name(equals, "equals");
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        const t1 = self.getTime();
        const t2 = that.getTime();
        return t1 === t2 || Number.isNaN(t1) && Number.isNaN(t2);
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
__name(compareBoth, "compareBoth");
var isEqual = /* @__PURE__ */ __name((u) => hasProperty(u, symbol2), "isEqual");
var equivalence = /* @__PURE__ */ __name(() => equals, "equivalence");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = /* @__PURE__ */ __name((x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
}, "toJSON");
var format = /* @__PURE__ */ __name((x) => JSON.stringify(x, null, 2), "format");
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  static {
    __name(this, "Class");
  }
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = /* @__PURE__ */ __name((u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
}, "toStringUnknown");
var stringifyCircular = /* @__PURE__ */ __name((obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? void 0 : cache.push(value) && (redactableState.fiberRefs !== void 0 && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = void 0;
  return retVal;
}, "stringifyCircular");
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = /* @__PURE__ */ __name((u) => typeof u === "object" && u !== null && symbolRedactable in u, "isRedactable");
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = /* @__PURE__ */ __name((context7, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context7;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
}, "withRedactableContext");
var redact = /* @__PURE__ */ __name((u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
}, "redact");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = /* @__PURE__ */ __name((self, args3) => {
  switch (args3.length) {
    case 0:
      return self;
    case 1:
      return args3[0](self);
    case 2:
      return args3[1](args3[0](self));
    case 3:
      return args3[2](args3[1](args3[0](self)));
    case 4:
      return args3[3](args3[2](args3[1](args3[0](self))));
    case 5:
      return args3[4](args3[3](args3[2](args3[1](args3[0](self)))));
    case 6:
      return args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self))))));
    case 7:
      return args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self)))))));
    case 8:
      return args3[7](args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self))))))));
    case 9:
      return args3[8](args3[7](args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args3.length; i < len; i++) {
        ret = args3[i](ret);
      }
      return ret;
    }
  }
}, "pipeArguments");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.19.13";
var getCurrentVersion = /* @__PURE__ */ __name(() => moduleVersion, "getCurrentVersion");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _L: /* @__PURE__ */ __name((_) => _, "_L"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var channelVariance = {
  /* c8 ignore next */
  _Env: /* @__PURE__ */ __name((_) => _, "_Env"),
  /* c8 ignore next */
  _InErr: /* @__PURE__ */ __name((_) => _, "_InErr"),
  /* c8 ignore next */
  _InElem: /* @__PURE__ */ __name((_) => _, "_InElem"),
  /* c8 ignore next */
  _InDone: /* @__PURE__ */ __name((_) => _, "_InDone"),
  /* c8 ignore next */
  _OutErr: /* @__PURE__ */ __name((_) => _, "_OutErr"),
  /* c8 ignore next */
  _OutElem: /* @__PURE__ */ __name((_) => _, "_OutElem"),
  /* c8 ignore next */
  _OutDone: /* @__PURE__ */ __name((_) => _, "_OutDone")
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ (function() {
  function Base5() {
  }
  __name(Base5, "Base");
  Base5.prototype = CommitPrototype;
  return Base5;
})();

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = /* @__PURE__ */ __name((input) => hasProperty(input, TypeId), "isOption");
var isNone = /* @__PURE__ */ __name((fa) => fa._tag === "None", "isNone");
var isSome = /* @__PURE__ */ __name((fa) => fa._tag === "Some", "isSome");
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = /* @__PURE__ */ __name((value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
}, "some");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: /* @__PURE__ */ __name((_) => _, "_R")
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = /* @__PURE__ */ __name((input) => hasProperty(input, TypeId2), "isEither");
var isLeft = /* @__PURE__ */ __name((ma) => ma._tag === "Left", "isLeft");
var isRight = /* @__PURE__ */ __name((ma) => ma._tag === "Right", "isRight");
var left = /* @__PURE__ */ __name((left5) => {
  const a = Object.create(LeftProto);
  a.left = left5;
  return a;
}, "left");
var right = /* @__PURE__ */ __name((right5) => {
  const a = Object.create(RightProto);
  a.right = right5;
  return a;
}, "right");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var isLeft2 = isLeft;
var isRight2 = isRight;
var match = /* @__PURE__ */ dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = /* @__PURE__ */ __name((self) => self.length > 0, "isNonEmptyArray");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Order.js
var make2 = /* @__PURE__ */ __name((compare) => (self, that) => self === that ? 0 : compare(self, that), "make");
var number2 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var mapInput2 = /* @__PURE__ */ dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));
var greaterThan = /* @__PURE__ */ __name((O) => dual(2, (self, that) => O(self, that) === 1), "greaterThan");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Option.js
var none2 = /* @__PURE__ */ __name(() => none, "none");
var some2 = some;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var getOrElse = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
var fromNullable = /* @__PURE__ */ __name((nullableValue) => nullableValue == null ? none2() : some2(nullableValue), "fromNullable");
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var getOrThrowWith = /* @__PURE__ */ dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a None"));
var map = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));
var flatMap = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
var containsWith = /* @__PURE__ */ __name((isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a)), "containsWith");
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var mergeWith = /* @__PURE__ */ __name((f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
}, "mergeWith");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Tuple.js
var make3 = /* @__PURE__ */ __name((...elements) => elements, "make");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Array.js
var allocate = /* @__PURE__ */ __name((n) => new Array(n), "allocate");
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max9 = Math.max(1, Math.floor(n));
  const out = new Array(max9);
  for (let i = 0; i < max9; i++) {
    out[i] = f(i);
  }
  return out;
});
var fromIterable = /* @__PURE__ */ __name((collection) => Array.isArray(collection) ? collection : Array.from(collection), "fromIterable");
var ensure = /* @__PURE__ */ __name((self) => Array.isArray(self) ? self : [self], "ensure");
var prepend = /* @__PURE__ */ dual(2, (self, head9) => [head9, ...self]);
var append = /* @__PURE__ */ dual(2, (self, last5) => [...self, last5]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = /* @__PURE__ */ __name((self) => self.length === 0, "isEmptyArray");
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = /* @__PURE__ */ __name((i, as7) => i < 0 || i >= as7.length, "isOutOfBounds");
var clamp = /* @__PURE__ */ __name((i, as7) => Math.floor(Math.min(Math.max(0, i), as7.length)), "clamp");
var get = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = /* @__PURE__ */ __name((self) => isNonEmptyReadonlyArray(self) ? some2(lastNonEmpty(self)) : none2(), "last");
var lastNonEmpty = /* @__PURE__ */ __name((self) => self[self.length - 1], "lastNonEmpty");
var tailNonEmpty = /* @__PURE__ */ __name((self) => self.slice(1), "tailNonEmpty");
var spanIndex = /* @__PURE__ */ __name((self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
}, "spanIndex");
var span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop = /* @__PURE__ */ dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(clamp(n, input), input.length);
});
var reverse = /* @__PURE__ */ __name((self) => Array.from(self).reverse(), "reverse");
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var zip = /* @__PURE__ */ dual(2, (self, that) => zipWith(self, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self, that, f) => {
  const as7 = fromIterable(self);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as7) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as7), headNonEmpty(bs))];
    const len = Math.min(as7.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as7[i], bs[i]);
    }
    return out;
  }
  return [];
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var splitAt = /* @__PURE__ */ dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var copy = /* @__PURE__ */ __name((self) => self.slice(), "copy");
var unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
  const a = fromIterable(self);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe3 = dedupeWith(isEquivalent);
      return dedupe3(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence2));
var empty = /* @__PURE__ */ __name(() => [], "empty");
var of = /* @__PURE__ */ __name((a) => [a], "of");
var map2 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap = /* @__PURE__ */ dual(2, (self, f) => {
  const as7 = fromIterable(self);
  const out = [];
  for (let i = 0; i < as7.length; i++) {
    const o = f(as7[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var partitionMap = /* @__PURE__ */ dual(2, (self, f) => {
  const left5 = [];
  const right5 = [];
  const as7 = fromIterable(self);
  for (let i = 0; i < as7.length; i++) {
    const e = f(as7[i], i);
    if (isLeft2(e)) {
      left5.push(e.left);
    } else {
      right5.push(e.right);
    }
  }
  return [left5, right5];
});
var getSomes = /* @__PURE__ */ filterMap(identity);
var reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduceRight((b2, a, i) => f(b2, a, i), b));
var unfold = /* @__PURE__ */ __name((b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
}, "unfold");
var getEquivalence = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = /* @__PURE__ */ __name((self) => dedupeWith(self, equivalence()), "dedupe");
var join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable(self).join(sep));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Number.js
var Order = number2;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/RegExp.js
var escape = /* @__PURE__ */ __name((string3) => string3.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&"), "escape");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Boolean.js
var not = /* @__PURE__ */ __name((self) => !self, "not");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: /* @__PURE__ */ __name((_) => _, "_Service"),
    _Identifier: /* @__PURE__ */ __name((_) => _, "_Identifier")
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make4(this, self);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = /* @__PURE__ */ __name((key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
}, "makeGenericTag");
var Reference = /* @__PURE__ */ __name(() => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  __name(ReferenceClass, "ReferenceClass");
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
}, "Reference");
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId3]: {
    _Services: /* @__PURE__ */ __name((_) => _, "_Services")
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = /* @__PURE__ */ __name((unsafeMap) => {
  const context7 = Object.create(ContextProto);
  context7.unsafeMap = unsafeMap;
  return context7;
}, "makeContext");
var serviceNotFoundError = /* @__PURE__ */ __name((tag) => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split("\n");
    lines.splice(1, 3);
    error.stack = lines.join("\n");
  }
  return error;
}, "serviceNotFoundError");
var isContext = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId3), "isContext");
var isTag = /* @__PURE__ */ __name((u) => hasProperty(u, TagTypeId), "isTag");
var isReference = /* @__PURE__ */ __name((u) => hasProperty(u, ReferenceTypeId), "isReference");
var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
var empty2 = /* @__PURE__ */ __name(() => _empty, "empty");
var make4 = /* @__PURE__ */ __name((tag, service) => makeContext(/* @__PURE__ */ new Map([[tag.key, service]])), "make");
var add = /* @__PURE__ */ dual(3, (self, tag, service) => {
  const map23 = new Map(self.unsafeMap);
  map23.set(tag.key, service);
  return makeContext(map23);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = /* @__PURE__ */ __name((tag) => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
}, "getDefaultValue");
var unsafeGetReference = /* @__PURE__ */ __name((self, tag) => {
  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
}, "unsafeGetReference");
var unsafeGet2 = /* @__PURE__ */ dual(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId in tag) return getDefaultValue(tag);
    throw serviceNotFoundError(tag);
  }
  return self.unsafeMap.get(tag.key);
});
var get2 = unsafeGet2;
var getOption = /* @__PURE__ */ dual(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    return isReference(tag) ? some(getDefaultValue(tag)) : none;
  }
  return some(self.unsafeMap.get(tag.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self, that) => {
  const map23 = new Map(self.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map23.set(tag, s);
  }
  return makeContext(map23);
});
var mergeAll = /* @__PURE__ */ __name((...ctxs) => {
  const map23 = /* @__PURE__ */ new Map();
  for (let i = 0; i < ctxs.length; i++) {
    ctxs[i].unsafeMap.forEach((value, key) => {
      map23.set(key, value);
    });
  }
  return makeContext(map23);
}, "mergeAll");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var isContext2 = isContext;
var isTag2 = isTag;
var empty3 = empty2;
var make5 = make4;
var add2 = add;
var get3 = get2;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var mergeAll2 = mergeAll;
var Reference2 = Reference;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Chunk.js
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
__name(copy2, "copy");
var emptyArray = [];
var getEquivalence2 = /* @__PURE__ */ __name((isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet4(that, i)))), "getEquivalence");
var _equivalence3 = /* @__PURE__ */ getEquivalence2(equals);
var ChunkProto = {
  [TypeId4]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = /* @__PURE__ */ __name((backing) => {
  const chunk3 = Object.create(ChunkProto);
  chunk3.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk3.length = 0;
      chunk3.depth = 0;
      chunk3.left = chunk3;
      chunk3.right = chunk3;
      break;
    }
    case "IConcat": {
      chunk3.length = backing.left.length + backing.right.length;
      chunk3.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk3.left = backing.left;
      chunk3.right = backing.right;
      break;
    }
    case "IArray": {
      chunk3.length = backing.array.length;
      chunk3.depth = 0;
      chunk3.left = _empty2;
      chunk3.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk3.length = 1;
      chunk3.depth = 0;
      chunk3.left = _empty2;
      chunk3.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk3.length = backing.length;
      chunk3.depth = backing.chunk.depth + 1;
      chunk3.left = _empty2;
      chunk3.right = _empty2;
      break;
    }
  }
  return chunk3;
}, "makeChunk");
var isChunk = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId4), "isChunk");
var _empty2 = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty4 = /* @__PURE__ */ __name(() => _empty2, "empty");
var make6 = /* @__PURE__ */ __name((...as7) => unsafeFromNonEmptyArray(as7), "make");
var of2 = /* @__PURE__ */ __name((a) => makeChunk({
  _tag: "ISingleton",
  a
}), "of");
var fromIterable2 = /* @__PURE__ */ __name((self) => isChunk(self) ? self : unsafeFromArray(fromIterable(self)), "fromIterable");
var copyToArray = /* @__PURE__ */ __name((self, array6, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy2(self.backing.array, 0, array6, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array6, initial);
      copyToArray(self.right, array6, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array6[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array6[j] = unsafeGet4(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
}, "copyToArray");
var toReadonlyArray_ = /* @__PURE__ */ __name((self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
}, "toReadonlyArray_");
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = /* @__PURE__ */ __name((self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self.backing.right),
        right: reverse2(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self)));
  }
}, "reverseChunk");
var reverse2 = reverseChunk;
var get4 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet4(self, index)));
var unsafeFromArray = /* @__PURE__ */ __name((self) => self.length === 0 ? empty4() : self.length === 1 ? of2(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
}), "unsafeFromArray");
var unsafeFromNonEmptyArray = /* @__PURE__ */ __name((self) => unsafeFromArray(self), "unsafeFromNonEmptyArray");
var unsafeGet4 = /* @__PURE__ */ dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self, a) => appendAll2(self, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of2(elem), self));
var drop2 = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty2;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop2(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff15 = that.depth - self.depth;
  if (Math.abs(diff15) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff15 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll2(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var isEmpty = /* @__PURE__ */ __name((self) => self.length === 0, "isEmpty");
var isNonEmpty = /* @__PURE__ */ __name((self) => self.length > 0, "isNonEmpty");
var head2 = /* @__PURE__ */ get4(0);
var unsafeHead = /* @__PURE__ */ __name((self) => unsafeGet4(self, 0), "unsafeHead");
var headNonEmpty2 = unsafeHead;
var tailNonEmpty2 = /* @__PURE__ */ __name((self) => drop2(self, 1), "tailNonEmpty");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Duration.js
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1e3);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = /* @__PURE__ */ __name((input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match20 = DURATION_REGEX.exec(input);
    if (match20) {
      const [_, valueStr, unit] = match20;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
}, "decode");
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId5]: TypeId5,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make7 = /* @__PURE__ */ __name((input) => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
}, "make");
var isDuration = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId5), "isDuration");
var isZero = /* @__PURE__ */ __name((self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
}, "isZero");
var zero = /* @__PURE__ */ make7(0);
var infinity = /* @__PURE__ */ make7(Infinity);
var nanos = /* @__PURE__ */ __name((nanos3) => make7(nanos3), "nanos");
var micros = /* @__PURE__ */ __name((micros3) => make7(micros3 * bigint1e3), "micros");
var millis = /* @__PURE__ */ __name((millis3) => make7(millis3), "millis");
var seconds = /* @__PURE__ */ __name((seconds3) => make7(seconds3 * 1e3), "seconds");
var minutes = /* @__PURE__ */ __name((minutes3) => make7(minutes3 * 6e4), "minutes");
var hours = /* @__PURE__ */ __name((hours3) => make7(hours3 * 36e5), "hours");
var days = /* @__PURE__ */ __name((days3) => make7(days3 * 864e5), "days");
var weeks = /* @__PURE__ */ __name((weeks3) => make7(weeks3 * 6048e5), "weeks");
var toMillis = /* @__PURE__ */ __name((self) => match3(self, {
  onMillis: /* @__PURE__ */ __name((millis3) => millis3, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos3) => Number(nanos3) / 1e6, "onNanos")
}), "toMillis");
var unsafeToNanos = /* @__PURE__ */ __name((self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
}, "unsafeToNanos");
var toHrTime = /* @__PURE__ */ __name((self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
}, "toHrTime");
var match3 = /* @__PURE__ */ dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Equivalence = /* @__PURE__ */ __name((self, that) => matchWith(self, that, {
  onMillis: /* @__PURE__ */ __name((self2, that2) => self2 === that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self2, that2) => self2 === that2, "onNanos")
}), "Equivalence");
var lessThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: /* @__PURE__ */ __name((self2, that2) => self2 <= that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self2, that2) => self2 <= that2, "onNanos")
}));
var greaterThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: /* @__PURE__ */ __name((self2, that2) => self2 >= that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self2, that2) => self2 >= that2, "onNanos")
}));
var equals2 = /* @__PURE__ */ dual(2, (self, that) => Equivalence(decode(self), decode(that)));
var parts = /* @__PURE__ */ __name((self) => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos3 = unsafeToNanos(duration);
  const ms = nanos3 / bigint1e6;
  const sec = ms / bigint1e3;
  const min5 = sec / bigint60;
  const hr = min5 / bigint60;
  const days3 = hr / bigint24;
  return {
    days: Number(days3),
    hours: Number(hr % bigint24),
    minutes: Number(min5 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos3 % bigint1e6)
  };
}, "parts");
var format2 = /* @__PURE__ */ __name((self) => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration)) {
    return "0";
  }
  const fragments = parts(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
}, "format");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
__name(popcount, "popcount");
function hashFragment(shift3, h) {
  return h >>> shift3 & MASK;
}
__name(hashFragment, "hashFragment");
function toBitmap(x) {
  return 1 << x;
}
__name(toBitmap, "toBitmap");
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}
__name(fromBitmap, "fromBitmap");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/stack.js
var make8 = /* @__PURE__ */ __name((value, previous) => ({
  value,
  previous
}), "make");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate7, at, v, arr) {
  let out = arr;
  if (!mutate7) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
__name(arrayUpdate, "arrayUpdate");
function arraySpliceOut(mutate7, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate7) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate7) {
    out.length = newLen;
  }
  return out;
}
__name(arraySpliceOut, "arraySpliceOut");
function arraySpliceIn(mutate7, at, v, arr) {
  const len = arr.length;
  if (mutate7) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}
__name(arraySpliceIn, "arraySpliceIn");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  static {
    __name(this, "EmptyNode");
  }
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash3, key, size17) {
    const v = f(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size17.value;
    return new LeafNode(edit, hash3, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
__name(isEmptyNode, "isEmptyNode");
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
__name(isLeafNode, "isLeafNode");
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
__name(canEditNode, "canEditNode");
var LeafNode = class _LeafNode {
  static {
    __name(this, "LeafNode");
  }
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash3, key, value) {
    this.edit = edit;
    this.hash = hash3;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift3, f, hash3, key, size17) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        --size17.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash3, key, v2);
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size17.value;
    return mergeLeaves(edit, shift3, this.hash, this, hash3, new _LeafNode(edit, hash3, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  static {
    __name(this, "CollisionNode");
  }
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash3, children) {
    this.edit = edit;
    this.hash = hash3;
    this.children = children;
  }
  modify(edit, shift3, f, hash3, key, size17) {
    if (hash3 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size17);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size17.value;
    return mergeLeaves(edit, shift3, this.hash, this, hash3, new LeafNode(edit, hash3, key, v));
  }
  updateCollisionList(mutate7, edit, hash3, list, f, key, size17) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value) return list;
        if (isNone2(newValue2)) {
          --size17.value;
          return arraySpliceOut(mutate7, i, list);
        }
        return arrayUpdate(mutate7, i, new LeafNode(edit, hash3, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue)) return list;
    ++size17.value;
    return arrayUpdate(mutate7, len, new LeafNode(edit, hash3, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  static {
    __name(this, "IndexedNode");
  }
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift3, f, hash3, key, size17) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift3, hash3);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists5 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists5) {
      const _newChild = new EmptyNode().modify(edit, shift3 + SIZE, f, hash3, key, size17);
      if (!_newChild) return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift3 + SIZE, f, hash3, key, size17);
    if (current === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  static {
    __name(this, "ArrayNode");
  }
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size17, children) {
    this.edit = edit;
    this.size = size17;
    this.children = children;
  }
  modify(edit, shift3, f, hash3, key, size17) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift3, hash3);
    const child = children[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift3 + SIZE, f, hash3, key, size17);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count, newChildren);
  }
};
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
__name(pack, "pack");
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
__name(expand, "expand");
function mergeLeavesInner(edit, shift3, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift3, h1);
  const subH2 = hashFragment(shift3, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
__name(mergeLeavesInner, "mergeLeavesInner");
function mergeLeaves(edit, shift3, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift3;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make8(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}
__name(mergeLeaves, "mergeLeaves");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash3 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash3 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash3);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = /* @__PURE__ */ __name((editable, edit, root, size17) => {
  const map23 = Object.create(HashMapProto);
  map23._editable = editable;
  map23._edit = edit;
  map23._root = root;
  map23._size = size17;
  return map23;
}, "makeImpl");
var HashMapIterator = class _HashMapIterator {
  static {
    __name(this, "HashMapIterator");
  }
  map;
  f;
  v;
  constructor(map23, f) {
    this.map = map23;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = /* @__PURE__ */ __name((cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2(), "applyCont");
var visitLazy = /* @__PURE__ */ __name((node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
}, "visitLazy");
var visitLazyChildren = /* @__PURE__ */ __name((len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
}, "visitLazyChildren");
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty5 = /* @__PURE__ */ __name(() => _empty3, "empty");
var fromIterable3 = /* @__PURE__ */ __name((entries3) => {
  const map23 = beginMutation(empty5());
  for (const entry of entries3) {
    set(map23, entry[0], entry[1]);
  }
  return endMutation(map23);
}, "fromIterable");
var isHashMap = /* @__PURE__ */ __name((u) => hasProperty(u, HashMapTypeId), "isHashMap");
var isEmpty2 = /* @__PURE__ */ __name((self) => self && isEmptyNode(self._root), "isEmpty");
var get5 = /* @__PURE__ */ dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self, key, hash3) => {
  let node = self._root;
  let shift3 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash3 === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length; i < len; ++i) {
            const child = children[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift3, hash3);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift3 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift3, hash3)];
        if (node) {
          shift3 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has = /* @__PURE__ */ dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
var set = /* @__PURE__ */ dual(3, (self, key, value) => modifyAt(self, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys = /* @__PURE__ */ __name((self) => new HashMapIterator(self, (key) => key), "keys");
var size = /* @__PURE__ */ __name((self) => self._size, "size");
var beginMutation = /* @__PURE__ */ __name((self) => makeImpl(true, self._edit + 1, self._root, self._size), "beginMutation");
var endMutation = /* @__PURE__ */ __name((self) => {
  ;
  self._editable = false;
  return self;
}, "endMutation");
var mutate = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation(self);
  f(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self, key, hash3, f) => {
  const size17 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash3, key, size17);
  return pipe(self, setTree(newRoot, size17.value));
});
var remove2 = /* @__PURE__ */ dual(2, (self, key) => modifyAt(self, key, none2));
var map3 = /* @__PURE__ */ dual(2, (self, f) => reduce2(self, empty5(), (map23, value, key) => set(map23, key, f(value, key))));
var forEach = /* @__PURE__ */ dual(2, (self, f) => reduce2(self, void 0, (_, value, key) => f(value, key)));
var reduce2 = /* @__PURE__ */ dual(3, (self, zero3, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length; i < len; ) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = /* @__PURE__ */ __name((keyMap) => {
  const set11 = Object.create(HashSetProto);
  set11._keyMap = keyMap;
  return set11;
}, "makeImpl");
var isHashSet = /* @__PURE__ */ __name((u) => hasProperty(u, HashSetTypeId), "isHashSet");
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty5());
var empty6 = /* @__PURE__ */ __name(() => _empty4, "empty");
var fromIterable4 = /* @__PURE__ */ __name((elements) => {
  const set11 = beginMutation2(empty6());
  for (const value of elements) {
    add3(set11, value);
  }
  return endMutation2(set11);
}, "fromIterable");
var make9 = /* @__PURE__ */ __name((...elements) => {
  const set11 = beginMutation2(empty6());
  for (const value of elements) {
    add3(set11, value);
  }
  return endMutation2(set11);
}, "make");
var has2 = /* @__PURE__ */ dual(2, (self, value) => has(self._keyMap, value));
var size2 = /* @__PURE__ */ __name((self) => size(self._keyMap), "size");
var beginMutation2 = /* @__PURE__ */ __name((self) => makeImpl2(beginMutation(self._keyMap)), "beginMutation");
var endMutation2 = /* @__PURE__ */ __name((self) => {
  ;
  self._keyMap._editable = false;
  return self;
}, "endMutation");
var mutate2 = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (set(value, true)(self._keyMap), self) : makeImpl2(set(value, true)(self._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (remove2(value)(self._keyMap), self) : makeImpl2(remove2(value)(self._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self, that) => mutate2(self, (set11) => {
  for (const value of that) {
    remove3(set11, value);
  }
}));
var union2 = /* @__PURE__ */ dual(2, (self, that) => mutate2(empty6(), (set11) => {
  forEach2(self, (value) => add3(set11, value));
  for (const value of that) {
    add3(set11, value);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self, f) => forEach(self._keyMap, (_, k) => f(k)));
var reduce3 = /* @__PURE__ */ dual(3, (self, zero3, f) => reduce2(self._keyMap, zero3, (z, _, a) => f(z, a)));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/HashSet.js
var empty7 = empty6;
var fromIterable5 = fromIterable4;
var make10 = make9;
var has3 = has2;
var size3 = size2;
var add4 = add3;
var remove4 = remove3;
var difference3 = difference2;
var union3 = union2;
var reduce4 = reduce3;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/MutableRef.js
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId6]: TypeId6,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make11 = /* @__PURE__ */ __name((value) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
}, "make");
var compareAndSet = /* @__PURE__ */ dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var get6 = /* @__PURE__ */ __name((self) => self.current, "get");
var set2 = /* @__PURE__ */ dual(2, (self, value) => {
  self.current = value;
  return self;
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
var None = class {
  static {
    __name(this, "None");
  }
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Runtime = class {
  static {
    __name(this, "Runtime");
  }
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Composite = class {
  static {
    __name(this, "Composite");
  }
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left5, right5) {
    this.left = left5;
    this.right = right5;
  }
  _hash;
  [symbol]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = /* @__PURE__ */ new None();
var isFiberId = /* @__PURE__ */ __name((self) => hasProperty(self, FiberIdTypeId), "isFiberId");
var combine2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var ids = /* @__PURE__ */ __name((self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty7();
    }
    case OP_RUNTIME: {
      return make10(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union3(ids(self.right)));
    }
  }
}, "ids");
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make11(0));
var threadName = /* @__PURE__ */ __name((self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
}, "threadName");
var unsafeMake = /* @__PURE__ */ __name(() => {
  const id = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id + 1));
  return new Runtime(id, Date.now());
}, "unsafeMake");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var combine3 = combine2;
var threadName2 = threadName;
var unsafeMake2 = unsafeMake;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/HashMap.js
var empty8 = empty5;
var fromIterable6 = fromIterable3;
var isEmpty3 = isEmpty2;
var get7 = get5;
var set3 = set;
var keys2 = keys;
var mutate3 = mutate;
var modifyAt2 = modifyAt;
var map5 = map3;
var forEach3 = forEach;
var reduce5 = reduce2;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/List.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray2 = /* @__PURE__ */ __name((self) => fromIterable(self), "toArray");
var getEquivalence3 = /* @__PURE__ */ __name((isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray2), "getEquivalence");
var _equivalence4 = /* @__PURE__ */ getEquivalence3(equals);
var ConsProto = {
  [TypeId7]: TypeId7,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray2(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray2(this)));
  },
  [Symbol.iterator]() {
    let done13 = false;
    let self = this;
    return {
      next() {
        if (done13) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done13 = true;
          return this.return();
        }
        const value = self.head;
        self = self.tail;
        return {
          done: done13,
          value
        };
      },
      return(value) {
        if (!done13) {
          done13 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = /* @__PURE__ */ __name((head9, tail) => {
  const cons3 = Object.create(ConsProto);
  cons3.head = head9;
  cons3.tail = tail;
  return cons3;
}, "makeCons");
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId7]: TypeId7,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId7), "isList");
var isNil = /* @__PURE__ */ __name((self) => self._tag === "Nil", "isNil");
var isCons = /* @__PURE__ */ __name((self) => self._tag === "Cons", "isCons");
var nil = /* @__PURE__ */ __name(() => _Nil, "nil");
var cons = /* @__PURE__ */ __name((head9, tail) => makeCons(head9, tail), "cons");
var empty9 = nil;
var of3 = /* @__PURE__ */ __name((value) => makeCons(value, _Nil), "of");
var appendAll3 = /* @__PURE__ */ dual(2, (self, that) => prependAll(that, self));
var prepend3 = /* @__PURE__ */ dual(2, (self, element) => cons(element, self));
var prependAll = /* @__PURE__ */ dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce6 = /* @__PURE__ */ dual(3, (self, zero3, f) => {
  let acc = zero3;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = /* @__PURE__ */ __name((self) => {
  let result = empty9();
  let these = self;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
}, "reverse");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ (function() {
  function Structural4(args3) {
    if (args3) {
      Object.assign(this, args3);
    }
  }
  __name(Structural4, "Structural");
  Structural4.prototype = StructuralPrototype;
  return Structural4;
})();
var struct = /* @__PURE__ */ __name((as7) => Object.assign(Object.create(StructuralPrototype), as7), "struct");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance(a) {
  return a;
}
__name(variance, "variance");
var PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty10 = /* @__PURE__ */ __name(() => _empty5, "empty");
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = /* @__PURE__ */ __name((first3, second) => {
  const o = Object.create(AndThenProto);
  o.first = first3;
  o.second = second;
  return o;
}, "makeAndThen");
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AddService"
});
var makeAddService = /* @__PURE__ */ __name((key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
}, "makeAddService");
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "RemoveService"
});
var makeRemoveService = /* @__PURE__ */ __name((key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
}, "makeRemoveService");
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "UpdateService"
});
var makeUpdateService = /* @__PURE__ */ __name((key, update9) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update9;
  return o;
}, "makeUpdateService");
var diff = /* @__PURE__ */ __name((oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch17 = empty10();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch17 = combine4(makeUpdateService(tag, () => newService))(patch17);
      }
    } else {
      missingServices.delete(tag);
      patch17 = combine4(makeAddService(tag, newService))(patch17);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch17 = combine4(makeRemoveService(tag))(patch17);
  }
  return patch17;
}, "diff");
var combine4 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
var patch = /* @__PURE__ */ dual(2, (self, context7) => {
  if (self._tag === "Empty") {
    return context7;
  }
  let wasServiceUpdated = false;
  let patches = of2(self);
  const updatedContext = new Map(context7.unsafeMap);
  while (isNonEmpty(patches)) {
    const head9 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head9._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head9.key, head9.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail, head9.second), head9.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head9.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head9.key, head9.update(updatedContext.get(head9.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map23 = /* @__PURE__ */ new Map();
  for (const [tag] of context7.unsafeMap) {
    if (updatedContext.has(tag)) {
      map23.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s] of updatedContext) {
    map23.set(tag, s);
  }
  return makeContext(map23);
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance2(a) {
  return a;
}
__name(variance2, "variance");
var PatchProto2 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance2,
    _Key: variance2,
    _Patch: variance2
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty11 = /* @__PURE__ */ __name(() => _empty6, "empty");
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = /* @__PURE__ */ __name((first3, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first3;
  o.second = second;
  return o;
}, "makeAndThen");
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Add"
});
var makeAdd = /* @__PURE__ */ __name((value) => {
  const o = Object.create(AddProto);
  o.value = value;
  return o;
}, "makeAdd");
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Remove"
});
var makeRemove = /* @__PURE__ */ __name((value) => {
  const o = Object.create(RemoveProto);
  o.value = value;
  return o;
}, "makeRemove");
var diff2 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const [removed, patch17] = reduce4([oldValue, empty11()], ([set11, patch18], value) => {
    if (has3(value)(set11)) {
      return [remove4(value)(set11), patch18];
    }
    return [set11, combine5(makeAdd(value))(patch18)];
  })(newValue);
  return reduce4(patch17, (patch18, value) => combine5(makeRemove(value))(patch18))(removed);
}, "diff");
var combine5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = /* @__PURE__ */ dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set11 = oldValue;
  let patches = of2(self);
  while (isNonEmpty(patches)) {
    const head9 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head9._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(head9.first)(prepend2(head9.second)(tail));
        break;
      }
      case "Add": {
        set11 = add4(head9.value)(set11);
        patches = tail;
        break;
      }
      case "Remove": {
        set11 = remove4(head9.value)(set11);
        patches = tail;
      }
    }
  }
  return set11;
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance3(a) {
  return a;
}
__name(variance3, "variance");
var PatchProto3 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance3,
    _Patch: variance3
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty12 = /* @__PURE__ */ __name(() => _empty7, "empty");
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = /* @__PURE__ */ __name((first3, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first3;
  o.second = second;
  return o;
}, "makeAndThen");
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Append"
});
var makeAppend = /* @__PURE__ */ __name((values5) => {
  const o = Object.create(AppendProto);
  o.values = values5;
  return o;
}, "makeAppend");
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Slice"
});
var makeSlice = /* @__PURE__ */ __name((from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
}, "makeSlice");
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate = /* @__PURE__ */ __name((index, patch17) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch17;
  return o;
}, "makeUpdate");
var diff3 = /* @__PURE__ */ __name((options) => {
  let i = 0;
  let patch17 = empty12();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch17 = combine6(patch17, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch17 = combine6(patch17, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch17 = combine6(patch17, makeAppend(drop(i)(options.newValue)));
  }
  return patch17;
}, "diff");
var combine6 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = /* @__PURE__ */ dual(3, (self, oldValue, differ5) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray3 = oldValue.slice();
  let patches = of(self);
  while (isNonEmptyArray2(patches)) {
    const head9 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head9._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head9.first, head9.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value of head9.values) {
          readonlyArray3.push(value);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray3 = readonlyArray3.slice(head9.from, head9.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray3[head9.index] = differ5.patch(head9.patch, readonlyArray3[head9.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray3;
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make14 = /* @__PURE__ */ __name((params) => {
  const differ5 = Object.create(DifferProto);
  differ5.empty = params.empty;
  differ5.diff = params.diff;
  differ5.combine = params.combine;
  differ5.patch = params.patch;
  return differ5;
}, "make");
var environment = /* @__PURE__ */ __name(() => make14({
  empty: empty10(),
  combine: /* @__PURE__ */ __name((first3, second) => combine4(second)(first3), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff(oldValue, newValue), "diff"),
  patch: /* @__PURE__ */ __name((patch17, oldValue) => patch(oldValue)(patch17), "patch")
}), "environment");
var hashSet = /* @__PURE__ */ __name(() => make14({
  empty: empty11(),
  combine: /* @__PURE__ */ __name((first3, second) => combine5(second)(first3), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff2(oldValue, newValue), "diff"),
  patch: /* @__PURE__ */ __name((patch17, oldValue) => patch2(oldValue)(patch17), "patch")
}), "hashSet");
var readonlyArray = /* @__PURE__ */ __name((differ5) => make14({
  empty: empty12(),
  combine: /* @__PURE__ */ __name((first3, second) => combine6(first3, second), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ5
  }), "diff"),
  patch: /* @__PURE__ */ __name((patch17, oldValue) => patch3(patch17, oldValue, differ5), "patch")
}), "readonlyArray");
var update = /* @__PURE__ */ __name(() => updateWith((_, a) => a), "update");
var updateWith = /* @__PURE__ */ __name((f) => make14({
  empty: identity,
  combine: /* @__PURE__ */ __name((first3, second) => {
    if (first3 === identity) {
      return second;
    }
    if (second === identity) {
      return first3;
    }
    return (a) => second(first3(a));
  }, "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  }, "diff"),
  patch: /* @__PURE__ */ __name((patch17, oldValue) => f(oldValue, patch17(oldValue)), "patch")
}), "updateWith");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = /* @__PURE__ */ __name((patch17) => patch17 & BIT_MASK, "active");
var enabled = /* @__PURE__ */ __name((patch17) => patch17 >> BIT_SHIFT & BIT_MASK, "enabled");
var make15 = /* @__PURE__ */ __name((active3, enabled3) => (active3 & BIT_MASK) + ((enabled3 & active3 & BIT_MASK) << BIT_SHIFT), "make");
var empty13 = /* @__PURE__ */ make15(0, 0);
var enable = /* @__PURE__ */ __name((flag) => make15(flag, flag), "enable");
var disable = /* @__PURE__ */ __name((flag) => make15(flag, 0), "disable");
var exclude = /* @__PURE__ */ dual(2, (self, flag) => make15(active(self) & ~flag, enabled(self)));
var andThen = /* @__PURE__ */ dual(2, (self, that) => self | that);
var invert = /* @__PURE__ */ __name((n) => ~n >>> 0 & BIT_MASK, "invert");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = /* @__PURE__ */ __name((self) => isEnabled(self, CooperativeYielding), "cooperativeYielding");
var disable2 = /* @__PURE__ */ dual(2, (self, flag) => self & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
var interruptible = /* @__PURE__ */ __name((self) => interruption(self) && !windDown(self), "interruptible");
var interruption = /* @__PURE__ */ __name((self) => isEnabled(self, Interruption), "interruption");
var isEnabled = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
var make16 = /* @__PURE__ */ __name((...flags) => flags.reduce((a, b) => a | b, 0), "make");
var none5 = /* @__PURE__ */ make16(None2);
var runtimeMetrics = /* @__PURE__ */ __name((self) => isEnabled(self, RuntimeMetrics), "runtimeMetrics");
var windDown = /* @__PURE__ */ __name((self) => isEnabled(self, WindDown), "windDown");
var diff4 = /* @__PURE__ */ dual(2, (self, that) => make15(self ^ that, that));
var patch4 = /* @__PURE__ */ dual(2, (self, patch17) => self & (invert(active(patch17)) | enabled(patch17)) | active(patch17) & enabled(patch17));
var differ = /* @__PURE__ */ make14({
  empty: empty13,
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff4(oldValue, newValue), "diff"),
  combine: /* @__PURE__ */ __name((first3, second) => andThen(second)(first3), "combine"),
  patch: /* @__PURE__ */ __name((_patch, oldValue) => patch4(oldValue, _patch), "patch")
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty14 = empty13;
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/blockedRequests.js
var empty15 = {
  _tag: "Empty"
};
var par = /* @__PURE__ */ __name((self, that) => ({
  _tag: "Par",
  left: self,
  right: that
}), "par");
var seq = /* @__PURE__ */ __name((self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
}), "seq");
var single = /* @__PURE__ */ __name((dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
}), "single");
var flatten2 = /* @__PURE__ */ __name((self) => {
  let current = of3(self);
  let updated = empty9();
  while (1) {
    const [parallel7, sequential7] = reduce6(current, [parallelCollectionEmpty(), empty9()], ([parallel8, sequential8], blockedRequest) => {
      const [par3, seq3] = step(blockedRequest);
      return [parallelCollectionCombine(parallel8, par3), appendAll3(sequential8, seq3)];
    });
    updated = merge4(updated, parallel7);
    if (isNil(sequential7)) {
      return reverse3(updated);
    }
    current = sequential7;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "flatten");
var step = /* @__PURE__ */ __name((requests) => {
  let current = requests;
  let parallel7 = parallelCollectionEmpty();
  let stack = empty9();
  let sequential7 = empty9();
  while (1) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel7, sequential7];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left5 = current.left;
        const right5 = current.right;
        switch (left5._tag) {
          case "Empty": {
            current = right5;
            break;
          }
          case "Par": {
            const l = left5.left;
            const r = left5.right;
            current = par(seq(l, right5), seq(r, right5));
            break;
          }
          case "Seq": {
            const l = left5.left;
            const r = left5.right;
            current = seq(l, seq(r, right5));
            break;
          }
          case "Single": {
            current = left5;
            sequential7 = cons(right5, sequential7);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel7 = parallelCollectionAdd(parallel7, current);
        if (isNil(stack)) {
          return [parallel7, sequential7];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "step");
var merge4 = /* @__PURE__ */ __name((sequential7, parallel7) => {
  if (isNil(sequential7)) {
    return of3(parallelCollectionToSequentialCollection(parallel7));
  }
  if (parallelCollectionIsEmpty(parallel7)) {
    return sequential7;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential7.head);
  const parKeys = parallelCollectionKeys(parallel7);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential7.head, parallelCollectionToSequentialCollection(parallel7)), sequential7.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel7), sequential7);
}, "merge");
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
var EntryImpl = class {
  static {
    __name(this, "EntryImpl");
  }
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request3, result, listeners, ownerId, state) {
    this.request = request3;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var makeEntry = /* @__PURE__ */ __name((options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state), "makeEntry");
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var ParallelImpl = class {
  static {
    __name(this, "ParallelImpl");
  }
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map23) {
    this.map = map23;
  }
};
var parallelCollectionEmpty = /* @__PURE__ */ __name(() => new ParallelImpl(empty8()), "parallelCollectionEmpty");
var parallelCollectionAdd = /* @__PURE__ */ __name((self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest)))), "parallelCollectionAdd");
var parallelCollectionCombine = /* @__PURE__ */ __name((self, that) => new ParallelImpl(reduce5(self.map, that.map, (map23, value, key) => set3(map23, key, match2(get7(map23, key), {
  onNone: /* @__PURE__ */ __name(() => value, "onNone"),
  onSome: /* @__PURE__ */ __name((other) => appendAll2(value, other), "onSome")
})))), "parallelCollectionCombine");
var parallelCollectionIsEmpty = /* @__PURE__ */ __name((self) => isEmpty3(self.map), "parallelCollectionIsEmpty");
var parallelCollectionKeys = /* @__PURE__ */ __name((self) => Array.from(keys2(self.map)), "parallelCollectionKeys");
var parallelCollectionToSequentialCollection = /* @__PURE__ */ __name((self) => sequentialCollectionMake(map5(self.map, (x) => of2(x))), "parallelCollectionToSequentialCollection");
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var SequentialImpl = class {
  static {
    __name(this, "SequentialImpl");
  }
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map23) {
    this.map = map23;
  }
};
var sequentialCollectionMake = /* @__PURE__ */ __name((map23) => new SequentialImpl(map23), "sequentialCollectionMake");
var sequentialCollectionCombine = /* @__PURE__ */ __name((self, that) => new SequentialImpl(reduce5(that.map, self.map, (map23, value, key) => set3(map23, key, match2(get7(map23, key), {
  onNone: /* @__PURE__ */ __name(() => empty4(), "onNone"),
  onSome: /* @__PURE__ */ __name((a) => appendAll2(a, value), "onSome")
})))), "sequentialCollectionCombine");
var sequentialCollectionKeys = /* @__PURE__ */ __name((self) => Array.from(keys2(self.map)), "sequentialCollectionKeys");
var sequentialCollectionToChunk = /* @__PURE__ */ __name((self) => Array.from(self.map), "sequentialCollectionToChunk");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance4 = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E")
};
var proto = {
  [CauseTypeId]: variance4,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty16 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = /* @__PURE__ */ __name((error) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
}, "fail");
var die = /* @__PURE__ */ __name((defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
}, "die");
var interrupt = /* @__PURE__ */ __name((fiberId5) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId5;
  return o;
}, "interrupt");
var parallel = /* @__PURE__ */ __name((left5, right5) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left5;
  o.right = right5;
  return o;
}, "parallel");
var sequential = /* @__PURE__ */ __name((left5, right5) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left5;
  o.right = right5;
  return o;
}, "sequential");
var isCause = /* @__PURE__ */ __name((u) => hasProperty(u, CauseTypeId), "isCause");
var isEmptyType = /* @__PURE__ */ __name((self) => self._tag === OP_EMPTY, "isEmptyType");
var isDieType = /* @__PURE__ */ __name((self) => self._tag === OP_DIE, "isDieType");
var isEmpty5 = /* @__PURE__ */ __name((self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce7(self, true, (acc, cause5) => {
    switch (cause5._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
}, "isEmpty");
var isInterrupted = /* @__PURE__ */ __name((self) => isSome2(interruptOption(self)), "isInterrupted");
var isInterruptedOnly = /* @__PURE__ */ __name((self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self), "isInterruptedOnly");
var failures = /* @__PURE__ */ __name((self) => reverse2(reduce7(self, empty4(), (list, cause5) => cause5._tag === OP_FAIL ? some2(pipe(list, prepend2(cause5.error))) : none2())), "failures");
var defects = /* @__PURE__ */ __name((self) => reverse2(reduce7(self, empty4(), (list, cause5) => cause5._tag === OP_DIE ? some2(pipe(list, prepend2(cause5.defect))) : none2())), "defects");
var interruptors = /* @__PURE__ */ __name((self) => reduce7(self, empty7(), (set11, cause5) => cause5._tag === OP_INTERRUPT ? some2(pipe(set11, add4(cause5.fiberId))) : none2()), "interruptors");
var failureOption = /* @__PURE__ */ __name((self) => find(self, (cause5) => cause5._tag === OP_FAIL ? some2(cause5.error) : none2()), "failureOption");
var failureOrCause = /* @__PURE__ */ __name((self) => {
  const option5 = failureOption(self);
  switch (option5._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option5.value);
    }
  }
}, "failureOrCause");
var interruptOption = /* @__PURE__ */ __name((self) => find(self, (cause5) => cause5._tag === OP_INTERRUPT ? some2(cause5.fiberId) : none2()), "interruptOption");
var keepDefects = /* @__PURE__ */ __name((self) => match4(self, {
  onEmpty: none2(),
  onFail: /* @__PURE__ */ __name(() => none2(), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => some2(die(defect)), "onDie"),
  onInterrupt: /* @__PURE__ */ __name(() => none2(), "onInterrupt"),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), "keepDefects");
var keepDefectsAndElectFailures = /* @__PURE__ */ __name((self) => match4(self, {
  onEmpty: none2(),
  onFail: /* @__PURE__ */ __name((failure) => some2(die(failure)), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => some2(die(defect)), "onDie"),
  onInterrupt: /* @__PURE__ */ __name(() => none2(), "onInterrupt"),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), "keepDefectsAndElectFailures");
var stripFailures = /* @__PURE__ */ __name((self) => match4(self, {
  onEmpty: empty16,
  onFail: /* @__PURE__ */ __name(() => empty16, "onFail"),
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
}), "stripFailures");
var electFailures = /* @__PURE__ */ __name((self) => match4(self, {
  onEmpty: empty16,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
}), "electFailures");
var flatMap6 = /* @__PURE__ */ dual(2, (self, f) => match4(self, {
  onEmpty: empty16,
  onFail: /* @__PURE__ */ __name((error) => f(error), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => die(defect), "onDie"),
  onInterrupt: /* @__PURE__ */ __name((fiberId5) => interrupt(fiberId5), "onInterrupt"),
  onSequential: /* @__PURE__ */ __name((left5, right5) => sequential(left5, right5), "onSequential"),
  onParallel: /* @__PURE__ */ __name((left5, right5) => parallel(left5, right5), "onParallel")
}));
var flatten3 = /* @__PURE__ */ __name((self) => flatMap6(self, identity), "flatten");
var causeEquals = /* @__PURE__ */ __name((left5, right5) => {
  let leftStack = of2(left5);
  let rightStack = of2(right5);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce7([empty7(), empty4()], ([parallel7, sequential7], cause5) => {
      const [par3, seq3] = evaluateCause(cause5);
      return some2([pipe(parallel7, union3(par3)), pipe(sequential7, appendAll2(seq3))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce7([empty7(), empty4()], ([parallel7, sequential7], cause5) => {
      const [par3, seq3] = evaluateCause(cause5);
      return some2([pipe(parallel7, union3(par3)), pipe(sequential7, appendAll2(seq3))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
}, "causeEquals");
var flattenCause = /* @__PURE__ */ __name((cause5) => {
  return flattenCauseLoop(of2(cause5), empty4());
}, "flattenCause");
var flattenCauseLoop = /* @__PURE__ */ __name((causes, flattened) => {
  while (1) {
    const [parallel7, sequential7] = pipe(causes, reduce([empty7(), empty4()], ([parallel8, sequential8], cause5) => {
      const [par3, seq3] = evaluateCause(cause5);
      return [pipe(parallel8, union3(par3)), pipe(sequential8, appendAll2(seq3))];
    }));
    const updated = size3(parallel7) > 0 ? pipe(flattened, prepend2(parallel7)) : flattened;
    if (isEmpty(sequential7)) {
      return reverse2(updated);
    }
    causes = sequential7;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
}, "flattenCauseLoop");
var find = /* @__PURE__ */ dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option5 = pf(item);
    switch (option5._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option5;
      }
    }
  }
  return none2();
});
var evaluateCause = /* @__PURE__ */ __name((self) => {
  let cause5 = self;
  const stack = [];
  let _parallel = empty7();
  let _sequential = empty4();
  while (cause5 !== void 0) {
    switch (cause5._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause5 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make6(cause5._tag, cause5.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause5 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make6(cause5._tag, cause5.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause5 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make6(cause5._tag, cause5.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause5 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause5.left._tag) {
          case OP_EMPTY: {
            cause5 = cause5.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause5 = sequential(cause5.left.left, sequential(cause5.left.right, cause5.right));
            break;
          }
          case OP_PARALLEL: {
            cause5 = parallel(sequential(cause5.left.left, cause5.right), sequential(cause5.left.right, cause5.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause5.right);
            cause5 = cause5.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause5.right);
        cause5 = cause5.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
}, "evaluateCause");
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: /* @__PURE__ */ __name((_, left5, right5) => left5 && right5, "sequentialCase"),
  parallelCase: /* @__PURE__ */ __name((_, left5, right5) => left5 && right5, "parallelCase")
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match4 = /* @__PURE__ */ dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt5,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: /* @__PURE__ */ __name(() => onEmpty, "emptyCase"),
    failCase: /* @__PURE__ */ __name((_, error) => onFail(error), "failCase"),
    dieCase: /* @__PURE__ */ __name((_, defect) => onDie(defect), "dieCase"),
    interruptCase: /* @__PURE__ */ __name((_, fiberId5) => onInterrupt5(fiberId5), "interruptCase"),
    sequentialCase: /* @__PURE__ */ __name((_, left5, right5) => onSequential(left5, right5), "sequentialCase"),
    parallelCase: /* @__PURE__ */ __name((_, left5, right5) => onParallel(left5, right5), "parallelCase")
  });
});
var reduce7 = /* @__PURE__ */ dual(3, (self, zero3, pf) => {
  let accumulator = zero3;
  let cause5 = self;
  const causes = [];
  while (cause5 !== void 0) {
    const option5 = pf(accumulator, cause5);
    accumulator = isSome2(option5) ? option5.value : accumulator;
    switch (cause5._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause5.right);
        cause5 = cause5.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause5.right);
        cause5 = cause5.left;
        break;
      }
      default: {
        cause5 = void 0;
        break;
      }
    }
    if (cause5 === void 0 && causes.length > 0) {
      cause5 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self, context7, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause5 = input.pop();
    switch (cause5._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context7)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context7, cause5.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context7, cause5.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context7, cause5.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause5.right);
        input.push(cause5.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause5.right);
        input.push(cause5.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either7 = output.pop();
    switch (either7._tag) {
      case "Left": {
        switch (either7.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left5 = accumulator.pop();
            const right5 = accumulator.pop();
            const value = reducer.sequentialCase(context7, left5, right5);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left5 = accumulator.pop();
            const right5 = accumulator.pop();
            const value = reducer.parallelCase(context7, left5, right5);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either7.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = /* @__PURE__ */ __name((cause5, options) => {
  if (isInterruptedOnly(cause5)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause5).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
}, "pretty");
var renderErrorCause = /* @__PURE__ */ __name((cause5, prefix) => {
  const lines = cause5.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause5.cause) {
    stack += ` {
${renderErrorCause(cause5.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
}, "renderErrorCause");
var PrettyError = class _PrettyError extends globalThis.Error {
  static {
    __name(this, "PrettyError");
  }
  span = void 0;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage = /* @__PURE__ */ __name((u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
}, "prettyErrorMessage");
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = /* @__PURE__ */ __name((message, stack, span3) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span3) {
    let current = span3;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match20 = false;
          for (const [, location] of locationMatchAll) {
            match20 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match20) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join("\n");
}, "prettyErrorStack");
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = /* @__PURE__ */ __name((cause5) => reduceWithContext(cause5, void 0, {
  emptyCase: /* @__PURE__ */ __name(() => [], "emptyCase"),
  dieCase: /* @__PURE__ */ __name((_, unknownError) => {
    return [new PrettyError(unknownError)];
  }, "dieCase"),
  failCase: /* @__PURE__ */ __name((_, error) => {
    return [new PrettyError(error)];
  }, "failCase"),
  interruptCase: /* @__PURE__ */ __name(() => [], "interruptCase"),
  parallelCase: /* @__PURE__ */ __name((_, l, r) => [...l, ...r], "parallelCase"),
  sequentialCase: /* @__PURE__ */ __name((_, l, r) => [...l, ...r], "sequentialCase")
}), "prettyErrors");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var pending = /* @__PURE__ */ __name((joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
}, "pending");
var done = /* @__PURE__ */ __name((effect) => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
}, "done");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  static {
    __name(this, "SingleShotGen");
  }
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/core.js
var blocked = /* @__PURE__ */ __name((blockedRequests, _continue5) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue5;
  return effect;
}, "blocked");
var runRequestBlock = /* @__PURE__ */ __name((blockedRequests) => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
}, "runRequestBlock");
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags = class {
  static {
    __name(this, "RevertFlags");
  }
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch17, op) {
    this.patch = patch17;
    this.op = op;
  }
};
var EffectPrimitive = class {
  static {
    __name(this, "EffectPrimitive");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  static {
    __name(this, "EffectPrimitiveFailure");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  static {
    __name(this, "EffectPrimitiveSuccess");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = /* @__PURE__ */ __name((u) => hasProperty(u, EffectTypeId2), "isEffect");
var withFiberRuntime = /* @__PURE__ */ __name((withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
}, "withFiberRuntime");
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap7(acquire, (a) => flatMap7(exit(suspend(() => restore(use(a)))), (exit7) => {
  return suspend(() => release(a, exit7)).pipe(matchCauseEffect({
    onFailure: /* @__PURE__ */ __name((cause5) => {
      switch (exit7._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit7.effect_instruction_i0, cause5));
        case OP_SUCCESS:
          return failCause(cause5);
      }
    }, "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => exit7, "onSuccess")
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self, value) => flatMap7(self, () => succeed(value)));
var asVoid = /* @__PURE__ */ __name((self) => as(self, void 0), "asVoid");
var custom = /* @__PURE__ */ __name(function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
}, "custom");
var unsafeAsync = /* @__PURE__ */ __name((register, blockingOn = none4) => {
  const effect = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect.effect_instruction_i0 = (resume3) => {
    cancelerRef = register(resume3);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
}, "unsafeAsync");
var asyncInterrupt = /* @__PURE__ */ __name((register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn)), "asyncInterrupt");
var async_ = /* @__PURE__ */ __name((resume3, blockingOn = none4) => {
  return custom(resume3, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect2) {
      if (backingResume) {
        backingResume(effect2);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect2;
      }
    }
    __name(proxyResume, "proxyResume");
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = (resume4) => {
      backingResume = resume4;
      if (pendingEffect) {
        resume4(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect;
  });
}, "async_");
var catchAllCause = /* @__PURE__ */ dual(2, (self, f) => {
  const effect = new EffectPrimitive(OP_ON_FAILURE);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
var catchAll = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause(self, (cause5) => {
  const either7 = failureOrCause(cause5);
  switch (either7._tag) {
    case "Left":
      return predicate(either7.left) ? f(either7.left) : failCause(cause5);
    case "Right":
      return failCause(either7.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause5) => {
  const either7 = failureOrCause(cause5);
  switch (either7._tag) {
    case "Left":
      return pipe(pf(either7.left), getOrElse(() => failCause(cause5)));
    case "Right":
      return failCause(either7.right);
  }
}));
var checkInterruptible = /* @__PURE__ */ __name((f) => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags))), "checkInterruptible");
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = /* @__PURE__ */ __name((obj, span3) => {
  if (isSome2(span3)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span3.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
}, "capture");
var die2 = /* @__PURE__ */ __name((defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect)), "die");
var dieMessage = /* @__PURE__ */ __name((message) => failCauseSync(() => die(new RuntimeException(message))), "dieMessage");
var dieSync = /* @__PURE__ */ __name((evaluate3) => flatMap7(sync(evaluate3), die2), "dieSync");
var either2 = /* @__PURE__ */ __name((self) => matchEffect(self, {
  onFailure: /* @__PURE__ */ __name((e) => succeed(left2(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed(right2(a)), "onSuccess")
}), "either");
var exit = /* @__PURE__ */ __name((self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
}), "exit");
var fail2 = /* @__PURE__ */ __name((error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error)), "fail");
var failSync = /* @__PURE__ */ __name((evaluate3) => flatMap7(sync(evaluate3), fail2), "failSync");
var failCause = /* @__PURE__ */ __name((cause5) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause5;
  return effect;
}, "failCause");
var failCauseSync = /* @__PURE__ */ __name((evaluate3) => flatMap7(sync(evaluate3), failCause), "failCauseSync");
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => f(state.id())), "fiberIdWith");
var flatMap7 = /* @__PURE__ */ dual(2, (self, f) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
var andThen2 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume3) => {
      b.then((a2) => resume3(succeed(a2)), (e) => resume3(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = /* @__PURE__ */ __name((self) => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self;
  return effect;
}, "step");
var flatten4 = /* @__PURE__ */ __name((self) => flatMap7(self, identity), "flatten");
var flip = /* @__PURE__ */ __name((self) => matchEffect(self, {
  onFailure: succeed,
  onSuccess: fail2
}), "flip");
var matchCause = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => succeed(options.onFailure(cause5)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed(options.onSuccess(a)), "onSuccess")
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self, options) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
var matchEffect = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const defects3 = defects(cause5);
    if (defects3.length > 0) {
      return failCause(electFailures(cause5));
    }
    const failures3 = failures(cause5);
    if (failures3.length > 0) {
      return options.onFailure(unsafeHead(failures3));
    }
    return failCause(cause5);
  }, "onFailure"),
  onSuccess: options.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: /* @__PURE__ */ __name(() => i < arr.length, "while"),
    body: /* @__PURE__ */ __name(() => f(arr[i], i), "body"),
    step: /* @__PURE__ */ __name((b) => {
      ret[i++] = b;
    }, "step")
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  let i = 0;
  return whileLoop({
    while: /* @__PURE__ */ __name(() => i < arr.length, "while"),
    body: /* @__PURE__ */ __name(() => f(arr[i], i), "body"),
    step: /* @__PURE__ */ __name(() => {
      i++;
    }, "step")
  });
}));
var if_ = /* @__PURE__ */ dual((args3) => typeof args3[0] === "boolean" || isEffect(args3[0]), (self, options) => isEffect(self) ? flatMap7(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap7(fiberId, (fiberId5) => interruptWith(fiberId5));
var interruptWith = /* @__PURE__ */ __name((fiberId5) => failCause(interrupt(fiberId5)), "interruptWith");
var interruptible2 = /* @__PURE__ */ __name((self) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
}, "interruptible");
var interruptibleMask = /* @__PURE__ */ __name((f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
}), "interruptibleMask");
var intoDeferred = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap7(exit(restore(self)), (exit7) => deferredDone(deferred, exit7))));
var map8 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (a) => sync(() => f(a))));
var mapBoth = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
  onFailure: /* @__PURE__ */ __name((e) => failSync(() => options.onFailure(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => sync(() => options.onSuccess(a)), "onSuccess")
}));
var mapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const either7 = failureOrCause(cause5);
    switch (either7._tag) {
      case "Left": {
        return failSync(() => f(either7.left));
      }
      case "Right": {
        return failCause(either7.right);
      }
    }
  }, "onFailure"),
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, (exit7) => exitIsSuccess(exit7) ? void_ : cleanup(exit7.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: /* @__PURE__ */ __name((cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: /* @__PURE__ */ __name((cause22) => exitFailCause(sequential(cause1, cause22)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => result, "onSuccess")
    });
  }, "onFailure"),
  onSuccess: /* @__PURE__ */ __name((success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }, "onSuccess")
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: /* @__PURE__ */ __name((cause5) => isInterruptedOnly(cause5) ? asVoid(cleanup(interruptors(cause5))) : void_, "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => void_, "onSuccess")
})));
var orElse = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = /* @__PURE__ */ __name((self) => orDieWith(self, identity), "orDie");
var orDieWith = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: /* @__PURE__ */ __name((e) => die2(f(e)), "onFailure"),
  onSuccess: succeed
}));
var partitionMap2 = partitionMap;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status) => succeed(status.runtimeFlags));
var succeed = /* @__PURE__ */ __name((value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
}, "succeed");
var suspend = /* @__PURE__ */ __name((evaluate3) => {
  const effect = new EffectPrimitive(OP_COMMIT);
  effect.commit = evaluate3;
  return effect;
}, "suspend");
var sync = /* @__PURE__ */ __name((thunk) => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = thunk;
  return effect;
}, "sync");
var tap = /* @__PURE__ */ dual((args3) => args3.length === 3 || args3.length === 2 && !(isObject(args3[1]) && "onlyEffect" in args3[1]), (self, f) => flatMap7(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume3) => {
      b.then((_) => resume3(succeed(a)), (e) => resume3(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope5 = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope5)));
}), "transplant");
var attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const defects3 = defects(cause5);
    if (defects3.length > 0) {
      return failCause(getOrThrow(keepDefectsAndElectFailures(cause5)));
    }
    return that();
  }, "onFailure"),
  onSuccess
}));
var uninterruptible = /* @__PURE__ */ __name((self) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
}, "uninterruptible");
var uninterruptibleMask = /* @__PURE__ */ __name((f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
}), "uninterruptibleMask");
var void_ = /* @__PURE__ */ succeed(void 0);
var updateRuntimeFlags = /* @__PURE__ */ __name((patch17) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch17;
  effect.effect_instruction_i1 = void 0;
  return effect;
}, "updateRuntimeFlags");
var whenEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap7(condition, (b) => {
  if (b) {
    return pipe(self, map8(some2));
  }
  return succeed(none2());
}));
var whileLoop = /* @__PURE__ */ __name((options) => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
}, "whileLoop");
var fromIterator = /* @__PURE__ */ __name((iterator) => suspend(() => {
  const effect = new EffectPrimitive(OP_ITERATOR);
  effect.effect_instruction_i0 = iterator();
  return effect;
}), "fromIterator");
var gen = /* @__PURE__ */ __name(function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
}, "gen");
var fnUntraced = /* @__PURE__ */ __name((body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args3) {
  return fromIterator(() => body.apply(this, args3));
} : function(...args3) {
  let effect = fromIterator(() => body.apply(this, args3));
  for (const x of pipeables) {
    effect = x(effect, ...args3);
  }
  return effect;
}, "length", {
  value: body.length,
  configurable: true
}), "fnUntraced");
var withConcurrency = /* @__PURE__ */ dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update9) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = update9;
  effect.effect_instruction_i1 = () => self;
  return effect;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect, enabled3) => fiberRefLocally(effect, currentTracerEnabled, enabled3));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect, enabled3) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled3));
var yieldNow = /* @__PURE__ */ __name((options) => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
}, "yieldNow");
var zip2 = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, (a) => map8(that, (b) => [a, b])));
var zipLeft = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, (a) => as(that, a)));
var zipRight = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, () => that));
var zipWith2 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap7(self, (a) => map8(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = /* @__PURE__ */ __name((self) => flatMap7(fiberId, (fiberId5) => pipe(self, interruptAsFiber(fiberId5))), "interruptFiber");
var interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId5) => flatMap7(self.interruptAsFork(fiberId5), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var fiberRefGet = /* @__PURE__ */ __name((self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self))), "fiberRefGet");
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap7(fiberRefGet(self), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self, value) => fiberRefModify(self, () => [void 0, value]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var RequestResolverImpl = class _RequestResolverImpl {
  static {
    __name(this, "RequestResolverImpl");
  }
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
  }
  [symbol]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol2](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids5) {
    return new _RequestResolverImpl(this.runAll, fromIterable2(ids5));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = /* @__PURE__ */ __name((u) => hasProperty(u, RequestResolverTypeId), "isRequestResolver");
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self, value) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))));
var fiberRefUnsafeMake = /* @__PURE__ */ __name((initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options?.fork ?? identity,
  join: options?.join
}), "fiberRefUnsafeMake");
var fiberRefUnsafeMakeHashSet = /* @__PURE__ */ __name((initial) => {
  const differ5 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ5,
    fork: differ5.empty
  });
}, "fiberRefUnsafeMakeHashSet");
var fiberRefUnsafeMakeReadonlyArray = /* @__PURE__ */ __name((initial) => {
  const differ5 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ5,
    fork: differ5.empty
  });
}, "fiberRefUnsafeMakeReadonlyArray");
var fiberRefUnsafeMakeContext = /* @__PURE__ */ __name((initial) => {
  const differ5 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ5,
    fork: differ5.empty
  });
}, "fiberRefUnsafeMakeContext");
var fiberRefUnsafeMakePatch = /* @__PURE__ */ __name((initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: /* @__PURE__ */ __name((oldValue, newValue) => options.differ.diff(oldValue, newValue), "diff"),
    combine: /* @__PURE__ */ __name((first3, second) => options.differ.combine(first3, second), "combine"),
    patch: /* @__PURE__ */ __name((patch17) => (oldValue) => options.differ.patch(patch17, oldValue), "patch"),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
}, "fiberRefUnsafeMakePatch");
var fiberRefUnsafeMakeRuntimeFlags = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
}), "fiberRefUnsafeMakeRuntimeFlags");
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty3()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty8()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty9()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: /* @__PURE__ */ __name(() => none2(), "fork"),
  join: /* @__PURE__ */ __name((parent, _) => parent, "join")
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty16, {
  fork: /* @__PURE__ */ __name(() => empty16, "fork"),
  join: /* @__PURE__ */ __name((parent, _) => parent, "join")
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty8()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty4()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = /* @__PURE__ */ __name((self, finalizer) => self.addFinalizer(() => asVoid(finalizer)), "scopeAddFinalizer");
var scopeAddFinalizerExit = /* @__PURE__ */ __name((self, finalizer) => self.addFinalizer(finalizer), "scopeAddFinalizerExit");
var scopeClose = /* @__PURE__ */ __name((self, exit7) => self.close(exit7), "scopeClose");
var scopeFork = /* @__PURE__ */ __name((self, strategy) => self.fork(strategy), "scopeFork");
var YieldableError = /* @__PURE__ */ (function() {
  class YieldableError3 extends globalThis.Error {
    static {
      __name(this, "YieldableError");
    }
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError3.prototype, StructuralCommitPrototype);
  return YieldableError3;
})();
var makeException = /* @__PURE__ */ __name((proto7, tag) => {
  class Base5 extends YieldableError {
    static {
      __name(this, "Base");
    }
    _tag = tag;
  }
  Object.assign(Base5.prototype, proto7);
  Base5.prototype.name = tag;
  return Base5;
}, "makeException");
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = /* @__PURE__ */ __name((u) => hasProperty(u, InterruptedExceptionTypeId), "isInterruptedException");
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = /* @__PURE__ */ __name((u) => hasProperty(u, NoSuchElementExceptionTypeId), "isNoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = /* @__PURE__ */ __name((duration) => new TimeoutException(`Operation timed out after '${format2(duration)}'`), "timeoutExceptionFromDuration");
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ (function() {
  class UnknownException3 extends YieldableError {
    static {
      __name(this, "UnknownException");
    }
    _tag = "UnknownException";
    error;
    constructor(cause5, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause5
      });
      this.error = cause5;
    }
  }
  Object.assign(UnknownException3.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException3;
})();
var exitIsExit = /* @__PURE__ */ __name((u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure"), "exitIsExit");
var exitIsFailure = /* @__PURE__ */ __name((self) => self._tag === "Failure", "exitIsFailure");
var exitIsSuccess = /* @__PURE__ */ __name((self) => self._tag === "Success", "exitIsSuccess");
var exitAs = /* @__PURE__ */ dual(2, (self, value) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value);
    }
  }
});
var exitAsVoid = /* @__PURE__ */ __name((self) => exitAs(self, void 0), "exitAsVoid");
var exitCollectAll = /* @__PURE__ */ __name((exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential), "exitCollectAll");
var exitDie = /* @__PURE__ */ __name((defect) => exitFailCause(die(defect)), "exitDie");
var exitFail = /* @__PURE__ */ __name((error) => exitFailCause(fail(error)), "exitFail");
var exitFailCause = /* @__PURE__ */ __name((cause5) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause5;
  return effect;
}, "exitFailCause");
var exitFlatMap = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self.effect_instruction_i0);
    }
  }
});
var exitFlatten = /* @__PURE__ */ __name((self) => pipe(self, exitFlatMap(identity)), "exitFlatten");
var exitInterrupt = /* @__PURE__ */ __name((fiberId5) => exitFailCause(interrupt(fiberId5)), "exitInterrupt");
var exitMap = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = /* @__PURE__ */ __name((value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
}, "exitSucceed");
var exitVoid = /* @__PURE__ */ exitSucceed(void 0);
var exitZipWith = /* @__PURE__ */ dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = /* @__PURE__ */ __name((exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: /* @__PURE__ */ __name((list2, value) => pipe(list2, prepend2(value)), "onSuccess"),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk3) => toReadonlyArray(chunk3)), some2);
}, "exitCollectAllInternal");
var deferredUnsafeMake = /* @__PURE__ */ __name((fiberId5) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make11(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId5
  };
  return _deferred;
}, "deferredUnsafeMake");
var deferredMake = /* @__PURE__ */ __name(() => flatMap7(fiberId, (id) => deferredMakeAs(id)), "deferredMake");
var deferredMakeAs = /* @__PURE__ */ __name((fiberId5) => sync(() => deferredUnsafeMake(fiberId5)), "deferredMakeAs");
var deferredAwait = /* @__PURE__ */ __name((self) => asyncInterrupt((resume3) => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume3(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume3);
      return deferredInterruptJoiner(self, resume3);
    }
  }
}, self.blockingOn), "deferredAwait");
var deferredComplete = /* @__PURE__ */ dual(2, (self, effect) => intoDeferred(effect, self));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect) => sync(() => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self.state, done(effect));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self, exit7) => deferredCompleteWith(self, exit7));
var deferredFailCause = /* @__PURE__ */ dual(2, (self, cause5) => deferredCompleteWith(self, failCause(cause5)));
var deferredInterrupt = /* @__PURE__ */ __name((self) => flatMap7(fiberId, (fiberId5) => deferredCompleteWith(self, interruptWith(fiberId5))), "deferredInterrupt");
var deferredSucceed = /* @__PURE__ */ dual(2, (self, value) => deferredCompleteWith(self, succeed(value)));
var deferredUnsafeDone = /* @__PURE__ */ __name((self, effect) => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self.state, done(effect));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect);
    }
  }
}, "deferredUnsafeDone");
var deferredInterruptJoiner = /* @__PURE__ */ __name((self, joiner) => sync(() => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
}), "deferredInterruptJoiner");
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = /* @__PURE__ */ __name(() => constContext, "context");
var contextWithEffect = /* @__PURE__ */ __name((f) => flatMap7(context(), f), "contextWithEffect");
var provideContext = /* @__PURE__ */ dual(2, (self, context7) => fiberRefLocally(currentContext, context7)(self));
var provideSomeContext = /* @__PURE__ */ dual(2, (self, context7) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context7))(self));
var mapInputContext = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect((context7) => provideContext(self, f(context7))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self, options) => flatMap7(self, (a) => flatMap7(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self, options) => filterEffectOrElse(self, {
  predicate: options.predicate,
  orElse: /* @__PURE__ */ __name((a) => fail2(options.orFailWith(a)), "orElse")
}));
var currentSpanFromFiber = /* @__PURE__ */ __name((fiber) => {
  const span3 = fiber.currentSpan;
  return span3 !== void 0 && span3._tag === "Span" ? some2(span3) : none2();
}, "currentSpanFromFiber");
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = /* @__PURE__ */ __name((options) => Object.assign(Object.create(NoopSpanProto), options), "noopSpan");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Deferred.js
var _await = deferredAwait;
var done2 = deferredDone;
var interrupt3 = deferredInterrupt;
var unsafeMake3 = deferredUnsafeMake;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Exit.js
var flatten5 = exitFlatten;
var succeed2 = exitSucceed;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/MutableHashMap.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId8]: TypeId8,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  static {
    __name(this, "MutableHashMapIterator");
  }
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  static {
    __name(this, "BucketIterator");
  }
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty17 = /* @__PURE__ */ __name(() => {
  const self = Object.create(MutableHashMapProto);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
}, "empty");
var get8 = /* @__PURE__ */ dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
  }
  const hash3 = key[symbol]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var getFromBucket = /* @__PURE__ */ __name((self, bucket, key, remove15 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove15) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some2(value);
    }
  }
  return none2();
}, "getFromBucket");
var has4 = /* @__PURE__ */ dual(2, (self, key) => isSome2(get8(self, key)));
var set4 = /* @__PURE__ */ dual(3, (self, key, value) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value);
    return self;
  }
  const hash3 = key[symbol]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    self.buckets.set(hash3, [[key, value]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = /* @__PURE__ */ __name((self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
}, "removeFromBucket");
var remove5 = /* @__PURE__ */ dual(2, (self, key) => {
  if (isEqual(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash3 = key[symbol]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    return self;
  }
  removeFromBucket(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash3);
  }
  return self;
});
var size4 = /* @__PURE__ */ __name((self) => {
  return self.referential.size + self.bucketsSize;
}, "size");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/MutableList.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId9]: TypeId9,
  [Symbol.iterator]() {
    let done13 = false;
    let head9 = this.head;
    return {
      next() {
        if (done13) {
          return this.return();
        }
        if (head9 == null) {
          done13 = true;
          return this.return();
        }
        const value = head9.value;
        head9 = head9.next;
        return {
          done: done13,
          value
        };
      },
      return(value) {
        if (!done13) {
          done13 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = /* @__PURE__ */ __name((value) => ({
  value,
  removed: false,
  prev: void 0,
  next: void 0
}), "makeNode");
var empty18 = /* @__PURE__ */ __name(() => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
}, "empty");
var isEmpty6 = /* @__PURE__ */ __name((self) => length(self) === 0, "isEmpty");
var length = /* @__PURE__ */ __name((self) => self._length, "length");
var append3 = /* @__PURE__ */ dual(2, (self, value) => {
  const node = makeNode(value);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var shift = /* @__PURE__ */ __name((self) => {
  const head9 = self.head;
  if (head9 !== void 0) {
    remove6(self, head9);
    return head9.value;
  }
  return void 0;
}, "shift");
var remove6 = /* @__PURE__ */ __name((self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
}, "remove");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/MutableQueue.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId10]: TypeId10,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make18 = /* @__PURE__ */ __name((capacity) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty18();
  queue.capacity = capacity;
  return queue;
}, "make");
var unbounded = /* @__PURE__ */ __name(() => make18(void 0), "unbounded");
var offer = /* @__PURE__ */ dual(2, (self, value) => {
  const queueLength = length(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append3(value)(self.queue);
  return true;
});
var poll = /* @__PURE__ */ dual(2, (self, def) => {
  if (isEmpty6(self.queue)) {
    return def;
  }
  return shift(self.queue);
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration) {
    const millis3 = toMillis(duration);
    if (millis3 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis3);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ (function() {
  const bigint1e63 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined" || typeof performance.now !== "function") {
    return () => BigInt(Date.now()) * bigint1e63;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e63 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
})();
var processOrPerformanceNow = /* @__PURE__ */ (function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
})();
var ClockImpl = class {
  static {
    __name(this, "ClockImpl");
  }
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration) {
    return async_((resume3) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume3(void_), duration);
      return asVoid(sync(canceler));
    });
  }
};
var make19 = /* @__PURE__ */ __name(() => new ClockImpl(), "make");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = /* @__PURE__ */ __name((self, that) => {
  const error = Object.create(proto2);
  error._op = OP_AND;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
}, "And");
var Or = /* @__PURE__ */ __name((self, that) => {
  const error = Object.create(proto2);
  error._op = OP_OR;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
}, "Or");
var InvalidData = /* @__PURE__ */ __name((path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, "InvalidData");
var MissingData = /* @__PURE__ */ __name((path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, "MissingData");
var SourceUnavailable = /* @__PURE__ */ __name((path, message, cause5, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause5;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, "SourceUnavailable");
var Unsupported = /* @__PURE__ */ __name((path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, "Unsupported");
var prefixed = /* @__PURE__ */ dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty19 = {
  _tag: "Empty"
};
var patch5 = /* @__PURE__ */ dual(2, (path, patch17) => {
  let input = of3(patch17);
  let output = path;
  while (isCons(input)) {
    const patch18 = input.head;
    switch (patch18._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch18.first, cons(patch18.second, input.tail));
        break;
      }
      case "MapName": {
        output = map2(output, patch18.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch18.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch18.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch18.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/configProvider.js
var concat = /* @__PURE__ */ __name((l, r) => [...l, ...r], "concat");
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make21 = /* @__PURE__ */ __name((options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
}), "make");
var makeFlat = /* @__PURE__ */ __name((options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: /* @__PURE__ */ __name((path, config, split = true) => options.load(path, config, split), "load"),
  enumerateChildren: options.enumerateChildren
}), "makeFlat");
var fromFlat = /* @__PURE__ */ __name((flat) => make21({
  load: /* @__PURE__ */ __name((config) => flatMap7(fromFlatLoop(flat, empty(), config, false), (chunk3) => match2(head(chunk3), {
    onNone: /* @__PURE__ */ __name(() => fail2(MissingData(empty(), `Expected a single value having structure: ${config}`)), "onNone"),
    onSome: succeed
  })), "load"),
  flattened: flat
}), "fromFlat");
var fromEnv = /* @__PURE__ */ __name((options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = /* @__PURE__ */ __name((path) => pipe(path, join(pathDelim)), "makePathString");
  const unmakePathString = /* @__PURE__ */ __name((pathString) => pathString.split(pathDelim), "unmakePathString");
  const getEnv = /* @__PURE__ */ __name(() => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {}, "getEnv");
  const load = /* @__PURE__ */ __name((path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap7((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
  }, "load");
  const enumerateChildren = /* @__PURE__ */ __name((path) => sync(() => {
    const current = getEnv();
    const keys9 = Object.keys(current);
    const keyPaths = keys9.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  }), "enumerateChildren");
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty19
  }));
}, "fromEnv");
var extend = /* @__PURE__ */ __name((leftDef, rightDef, left5, right5) => {
  const leftPad = unfold(left5.length, (index) => index >= right5.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right5.length, (index) => index >= left5.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left5, leftPad);
  const rightExtension = concat(right5, rightPad);
  return [leftExtension, rightExtension];
}, "extend");
var appendConfigPath = /* @__PURE__ */ __name((path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
}, "appendConfigPath");
var fromFlatLoop = /* @__PURE__ */ __name((flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap7(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split));
    }
    case OP_PRIMITIVE: {
      return pipe(patch5(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.load(prefix2, op, split), flatMap7((values5) => {
        if (values5.length === 0) {
          const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values5);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch5(prefix, flat.patch), flatMap7((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap7(indicesFrom), flatMap7((indices) => {
        if (indices.length === 0) {
          return suspend(() => map8(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map8((chunkChunk) => {
          const flattened = flatten(chunkChunk);
          if (flattened.length === 0) {
            return of(empty());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch5(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap7((keys9) => {
        return pipe(keys9, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split)), map8((matrix) => {
          if (matrix.length === 0) {
            return of(empty8());
          }
          return pipe(transpose(matrix), map2((values5) => fromIterable6(zip(fromIterable(keys9), values5))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either2, flatMap7((left5) => pipe(fromFlatLoop(flat, prefix, op.right, split), either2, flatMap7((right5) => {
        if (isLeft2(left5) && isLeft2(right5)) {
          return fail2(And(left5.left, right5.left));
        }
        if (isLeft2(left5) && isRight2(right5)) {
          return fail2(left5.left);
        }
        if (isRight2(left5) && isLeft2(right5)) {
          return fail2(right5.left);
        }
        if (isRight2(left5) && isRight2(right5)) {
          const path = pipe(prefix, join("."));
          const fail9 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend(fail9, fail9, pipe(left5.right, map2(right2)), pipe(right5.right, map2(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left6, right6]) => pipe(zip2(left6, right6), map8(([left7, right7]) => op.zip(left7, right7)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
}, "fromFlatLoop");
var fromFlatLoopFail = /* @__PURE__ */ __name((prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`)), "fromFlatLoopFail");
var splitPathString = /* @__PURE__ */ __name((text, delim) => {
  const split = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split;
}, "splitPathString");
var parsePrimitive = /* @__PURE__ */ __name((text, path, primitive, delimiter, split) => {
  if (!split) {
    return pipe(primitive.parse(text), mapBoth({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError(prefixed(path)));
}, "parsePrimitive");
var transpose = /* @__PURE__ */ __name((array6) => {
  return Object.keys(array6[0]).map((column) => array6.map((row) => row[column]));
}, "transpose");
var indicesFrom = /* @__PURE__ */ __name((quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
  onFailure: /* @__PURE__ */ __name(() => empty(), "onFailure"),
  onSuccess: sort(Order)
}), either2, map8(merge)), "indicesFrom");
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = /* @__PURE__ */ __name((str) => {
  const match20 = str.match(QUOTED_INDEX_REGEX);
  if (match20 !== null) {
    const matchedIndex = match20[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
}, "parseQuotedIndex");
var parseInteger = /* @__PURE__ */ __name((str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
}, "parseInteger");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId11]: TypeId11,
  assert(condition, ...args3) {
    return sync(() => {
      console.assert(condition, ...args3);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args3) {
    return sync(() => {
      console.debug(...args3);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args3) {
    return sync(() => {
      console.dirxml(...args3);
    });
  },
  error(...args3) {
    return sync(() => {
      console.error(...args3);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args3) {
    return sync(() => {
      console.info(...args3);
    });
  },
  log(...args3) {
    return sync(() => {
      console.log(...args3);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args3) {
    return sync(() => {
      console.timeLog(label, ...args3);
    });
  },
  trace(...args3) {
    return sync(() => {
      console.trace(...args3);
    });
  },
  warn(...args3) {
    return sync(() => {
      console.warn(...args3);
    });
  },
  unsafe: console
};

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");
var RandomImpl = class {
  static {
    __name(this, "RandomImpl");
  }
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map8(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min5, max9) {
    return map8(this.next, (n) => (max9 - min5) * n + min5);
  }
  nextIntBetween(min5, max9) {
    return sync(() => this.PRNG.integer(max9 - min5) + min5);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith = /* @__PURE__ */ __name((elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap7((buffer) => {
    const numbers = [];
    for (let i = buffer.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map8((k) => swap(buffer, n - 1, k)))), as(fromIterable2(buffer)));
  })));
}, "shuffleWith");
var swap = /* @__PURE__ */ __name((buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
}, "swap");
var make22 = /* @__PURE__ */ __name((seed) => new RandomImpl(hash(seed)), "make");
var FixedRandomImpl = class {
  static {
    __name(this, "FixedRandomImpl");
  }
  values;
  [RandomTypeId] = RandomTypeId;
  index = 0;
  constructor(values5) {
    this.values = values5;
    if (values5.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value;
  }
  get next() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number") {
        return Math.max(0, Math.min(1, value));
      }
      return hash(value) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "boolean") {
        return value;
      }
      return hash(value) % 2 === 0;
    });
  }
  get nextInt() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number" && Number.isFinite(value)) {
        return Math.round(value);
      }
      return Math.abs(hash(value));
    });
  }
  nextRange(min5, max9) {
    return map8(this.next, (n) => (max9 - min5) * n + min5);
  }
  nextIntBetween(min5, max9) {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number" && Number.isFinite(value)) {
        return Math.max(min5, Math.min(max9 - 1, Math.round(value)));
      }
      const hash3 = Math.abs(hash(value));
      return min5 + hash3 % (max9 - min5);
    });
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var fixed = /* @__PURE__ */ __name((values5) => new FixedRandomImpl(values5), "fixed");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make23 = /* @__PURE__ */ __name((options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
}), "make");
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ (function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length3) {
    let result = "";
    for (let i = 0; i < length3; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
})();
var NativeSpan = class {
  static {
    __name(this, "NativeSpan");
  }
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context7, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context7;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit7) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit7,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = /* @__PURE__ */ make23({
  span: /* @__PURE__ */ __name((name, parent, context7, links, startTime, kind) => new NativeSpan(name, parent, context7, links, startTime, kind), "span"),
  context: /* @__PURE__ */ __name((f) => f(), "context")
});
var addSpanStackTrace = /* @__PURE__ */ __name((options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options,
    captureStackTrace: /* @__PURE__ */ __name(() => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }, "captureStackTrace")
  };
}, "addSpanStackTrace");
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty3(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make19()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make22(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = /* @__PURE__ */ __name((duration) => {
  const decodedDuration = decode(duration);
  return clockWith((clock5) => clock5.sleep(decodedDuration));
}, "sleep");
var defaultServicesWith = /* @__PURE__ */ __name((f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices)), "defaultServicesWith");
var clockWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key))), "clockWith");
var currentTimeMillis = /* @__PURE__ */ clockWith((clock5) => clock5.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock5) => clock5.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect));
var withConfigProvider = /* @__PURE__ */ dual(2, (self, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self));
var configProviderWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key))), "configProviderWith");
var randomWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key))), "randomWith");
var withRandom = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect));
var tracerWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key))), "tracerWith");
var withTracer = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake4(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
__name(unsafeMake4, "unsafeMake");
function empty20() {
  return unsafeMake4(/* @__PURE__ */ new Map());
}
__name(empty20, "empty");
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
  static {
    __name(this, "FiberRefsImpl");
  }
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = /* @__PURE__ */ __name((_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
}, "findAncestor");
var joinAs = /* @__PURE__ */ dual(3, (self, fiberId5, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId5)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId5, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch17 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch17)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId5)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId5, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self, childId) => {
  const map23 = /* @__PURE__ */ new Map();
  unsafeForkAs(self, map23, childId);
  return new FiberRefsImpl(map23);
});
var unsafeForkAs = /* @__PURE__ */ __name((self, map23, fiberId5) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map23.set(fiberRef, stack);
    } else {
      map23.set(fiberRef, [[fiberId5, newValue], ...stack]);
    }
  });
}, "unsafeForkAs");
var fiberRefs = /* @__PURE__ */ __name((self) => fromIterable5(self.locals.keys()), "fiberRefs");
var setAll = /* @__PURE__ */ __name((self) => forEachSequentialDiscard(fiberRefs(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self, fiberRef))), "setAll");
var delete_ = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get9 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get9(self, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self, {
  fiberId: fiberId5,
  fiberRef,
  value
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId5, value]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId5, fiberRef, value);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = /* @__PURE__ */ __name((locals, fiberId5, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId5)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId5, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId5, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId5, value]];
  }
  locals.set(fiberRef, newStack);
}, "unsafeUpdateAs");
var updateManyAs = /* @__PURE__ */ dual(2, (self, {
  entries: entries3,
  forkAs: forkAs3
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries3));
  }
  const locals = new Map(self.locals);
  if (forkAs3 !== void 0) {
    unsafeForkAs(self, locals, forkAs3);
  }
  entries3.forEach(([fiberRef, values5]) => {
    if (values5.length === 1) {
      unsafeUpdateAs(locals, values5[0][0], fiberRef, values5[0][1]);
    } else {
      values5.forEach(([fiberId5, value]) => {
        unsafeUpdateAs(locals, fiberId5, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/FiberRefs.js
var get10 = get9;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateManyAs2 = updateManyAs;
var empty21 = empty20;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan2 = /* @__PURE__ */ greaterThan(Order2);
var fromLiteral = /* @__PURE__ */ __name((literal) => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
}, "fromLiteral");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/logSpan.js
var make24 = /* @__PURE__ */ __name((label, startTime) => ({
  label,
  startTime
}), "make");
var formatLabel = /* @__PURE__ */ __name((key) => key.replace(/[\s="]/g, "_"), "formatLabel");
var render = /* @__PURE__ */ __name((now) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now - self.startTime}ms`;
}, "render");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/LogSpan.js
var make25 = make24;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
var Class2 = class extends Base2 {
  static {
    __name(this, "Class");
  }
};

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Readable.js
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId12]: TypeId12,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var RefImpl = class extends Class2 {
  static {
    __name(this, "RefImpl");
  }
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId12] = TypeId12;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = get6(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake5 = /* @__PURE__ */ __name((value) => new RefImpl(make11(value)), "unsafeMake");
var make26 = /* @__PURE__ */ __name((value) => sync(() => unsafeMake5(value)), "make");
var get11 = /* @__PURE__ */ __name((self) => self.get, "get");
var set5 = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [void 0, value]));
var getAndSet = /* @__PURE__ */ dual(2, (self, value) => self.modify((a) => [a, value]));
var modify3 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
var update2 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Ref.js
var make27 = make26;
var get12 = get11;
var getAndSet2 = getAndSet;
var update3 = update2;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Tracer.js
var tracerWith2 = tracerWith;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty22 = {
  _tag: OP_EMPTY2
};
var diff5 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch17 = empty22;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch17 = combine7({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch17);
      }
    } else {
      patch17 = combine7({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch17);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch17 = combine7({
      _tag: OP_REMOVE,
      fiberRef
    })(patch17);
  }
  return patch17;
}, "diff");
var combine7 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch6 = /* @__PURE__ */ dual(3, (self, fiberId5, oldValue) => {
  let fiberRefs5 = oldValue;
  let patches = of(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head9 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head9._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs5 = updateAs(fiberRefs5, {
          fiberId: fiberId5,
          fiberRef: head9.fiberRef,
          value: head9.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs5 = delete_(fiberRefs5, head9.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value = getOrDefault(fiberRefs5, head9.fiberRef);
        fiberRefs5 = updateAs(fiberRefs5, {
          fiberId: fiberId5,
          fiberRef: head9.fiberRef,
          value: head9.fiberRef.patch(head9.patch)(value)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head9.first)(prepend(head9.second)(tail));
        break;
      }
    }
  }
  return fiberRefs5;
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
  static {
    __name(this, "MetricLabelImpl");
  }
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make28 = /* @__PURE__ */ __name((key, value) => {
  return new MetricLabelImpl(key, value);
}, "make");
var isMetricLabel = /* @__PURE__ */ __name((u) => hasProperty(u, MetricLabelTypeId), "isMetricLabel");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), function() {
  const args3 = arguments;
  return fiberRefLocallyWith(args3[0], currentLogAnnotations, typeof args3[1] === "string" ? set3(args3[1], args3[2]) : (annotations) => Object.entries(args3[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations));
});
var asSome = /* @__PURE__ */ __name((self) => map8(self, some2), "asSome");
var asSomeError = /* @__PURE__ */ __name((self) => mapError(self, some2), "asSomeError");
var try_ = /* @__PURE__ */ __name((arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate3));
    } catch (error) {
      return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
    }
  });
}, "try_");
var _catch = /* @__PURE__ */ dual(3, (self, tag, options) => catchAll(self, (e) => {
  if (hasProperty(e, tag) && e[tag] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self, f) => catchAllCause(self, (cause5) => {
  const option5 = find(cause5, (_) => isDieType(_) ? some2(_) : none2());
  switch (option5._tag) {
    case "None": {
      return failCause(cause5);
    }
    case "Some": {
      return f(option5.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const option5 = f(cause5);
    switch (option5._tag) {
      case "None": {
        return failCause(cause5);
      }
      case "Some": {
        return option5.value;
      }
    }
  }, "onFailure"),
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause5) => {
  const option5 = find(cause5, (_) => isDieType(_) ? some2(_) : none2());
  switch (option5._tag) {
    case "None": {
      return failCause(cause5);
    }
    case "Some": {
      const optionEffect = pf(option5.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause5);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (self, ...args3) => {
  const f = args3[args3.length - 1];
  let predicate;
  if (args3.length === 2) {
    predicate = isTagged(args3[0]);
  } else {
    predicate = /* @__PURE__ */ __name((e) => {
      const tag = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag) return false;
      for (let i = 0; i < args3.length - 1; i++) {
        if (args3[i] === tag) return true;
      }
      return false;
    }, "predicate");
  }
  return catchIf(self, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self, cases) => {
  let keys9;
  return catchIf(self, (e) => {
    keys9 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys9.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = /* @__PURE__ */ __name((self) => matchCause(self, {
  onFailure: identity,
  onSuccess: /* @__PURE__ */ __name(() => empty16, "onSuccess")
}), "cause");
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self, duration) => zipRight(sleep2(duration), self));
var descriptorWith = /* @__PURE__ */ __name((f) => withFiberRuntime((state, status) => f({
  id: state.id(),
  status,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
})), "descriptorWith");
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor5) => size3(descriptor5.interruptors) > 0 ? interrupt2 : void_);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = /* @__PURE__ */ __name((self) => summarized(self, fiberRefs2, diff5), "diffFiberRefs");
var diffFiberRefsAndRuntimeFlags = /* @__PURE__ */ __name((self) => summarized(self, zip2(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]), "diffFiberRefsAndRuntimeFlags");
var Do = /* @__PURE__ */ succeed({});
var bind2 = /* @__PURE__ */ bind(map8, flatMap7);
var bindTo2 = /* @__PURE__ */ bindTo(map8);
var let_2 = /* @__PURE__ */ let_(map8);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap7(dropping, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return map8(dropping, () => builder);
}));
var dropWhile = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap7(dropping, (d) => map8(d ? predicate(a, index) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map8(dropping, () => builder);
}));
var contextWith = /* @__PURE__ */ __name((f) => map8(context(), f), "contextWith");
var eventually = /* @__PURE__ */ __name((self) => orElse(self, () => flatMap7(yieldNow(), () => eventually(self))), "eventually");
var filterMap3 = /* @__PURE__ */ dual(2, (elements, pf) => map8(forEachSequential(elements, identity), filterMap(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self, predicate, orDieWith5) => filterOrElse(self, predicate, (a) => dieSync(() => orDieWith5(a))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self, predicate, orElse5) => flatMap7(self, (a) => predicate(a) ? succeed(a) : orElse5(a)));
var liftPredicate = /* @__PURE__ */ dual(3, (self, predicate, orFailWith) => suspend(() => predicate(self) ? succeed(self) : fail2(orFailWith(self))));
var filterOrFail = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
var findFirst3 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, predicate, next.value);
  }
  return succeed(none2());
}));
var findLoop = /* @__PURE__ */ __name((iterator, index, f, value) => flatMap7(f(value, index), (result) => {
  if (result) {
    return succeed(some2(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index + 1, f, next.value);
  }
  return succeed(none2());
}), "findLoop");
var firstSuccessOf = /* @__PURE__ */ __name((effects) => suspend(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left5, right5) => orElse(left5, () => right5)));
}), "firstSuccessOf");
var flipWith = /* @__PURE__ */ dual(2, (self, f) => flip(f(flip(self))));
var match6 = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
  onFailure: /* @__PURE__ */ __name((e) => succeed(options.onFailure(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed(options.onSuccess(a)), "onSuccess")
}));
var every4 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = /* @__PURE__ */ __name((iterator, index, f) => {
  const next = iterator.next();
  return next.done ? succeed(true) : flatMap7(f(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
}, "forAllLoop");
var forever = /* @__PURE__ */ __name((self) => {
  const loop5 = flatMap7(flatMap7(self, () => yieldNow()), () => loop5);
  return loop5;
}, "forever");
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head3 = /* @__PURE__ */ __name((self) => flatMap7(self, (as7) => {
  const iterator = as7[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return fail2(new NoSuchElementException());
  }
  return succeed(next.value);
}), "head");
var ignore = /* @__PURE__ */ __name((self) => match6(self, {
  onFailure: constVoid,
  onSuccess: constVoid
}), "ignore");
var ignoreLogged = /* @__PURE__ */ __name((self) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => logDebug(cause5, "An error was silently ignored because it is not anticipated to be useful"), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => void_, "onSuccess")
}), "ignoreLogged");
var inheritFiberRefs = /* @__PURE__ */ __name((childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs)), "inheritFiberRefs");
var isFailure = /* @__PURE__ */ __name((self) => match6(self, {
  onFailure: constTrue,
  onSuccess: constFalse
}), "isFailure");
var isSuccess = /* @__PURE__ */ __name((self) => match6(self, {
  onFailure: constFalse,
  onSuccess: constTrue
}), "isSuccess");
var iterate = /* @__PURE__ */ __name((initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap7(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
}), "iterate");
var logWithLevel = /* @__PURE__ */ __name((level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause5 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause5 !== void 0) {
        cause5 = sequential(cause5, msg);
      } else {
        cause5 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause5 === void 0) {
    cause5 = empty16;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause5, levelOption);
    return void_;
  });
}, "logWithLevel");
var log = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect, label) => flatMap7(currentTimeMillis2, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend3(make25(label, now)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = /* @__PURE__ */ __name((initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map8(loopInternal(initial, options.while, options.step, options.body), fromIterable), "loop");
var loopInternal = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap7(body(initial), (a) => map8(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty9())), "loopInternal");
var loopDiscard = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap7(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_), "loopDiscard");
var mapAccum2 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index = i++;
    const value = next.value;
    result = flatMap7(result, (state) => map8(f(state, value, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map8(result, (z) => [z, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((c) => failCauseSync(() => f(c)), "onFailure"),
  onSuccess: succeed
}));
var memoize = /* @__PURE__ */ __name((self) => pipe(deferredMake(), flatMap7((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map8((complete5) => zipRight(complete5, pipe(deferredAwait(deferred), flatMap7(([patch17, a]) => as(zip2(patchFiberRefs(patch17[0]), updateRuntimeFlags(patch17[1])), a)))))))), "memoize");
var merge5 = /* @__PURE__ */ __name((self) => matchEffect(self, {
  onFailure: /* @__PURE__ */ __name((e) => succeed(e), "onFailure"),
  onSuccess: succeed
}), "merge");
var negate = /* @__PURE__ */ __name((self) => map8(self, (b) => !b), "negate");
var none6 = /* @__PURE__ */ __name((self) => flatMap7(self, (option5) => {
  switch (option5._tag) {
    case "None":
      return void_;
    case "Some":
      return fail2(new NoSuchElementException());
  }
}), "none");
var once = /* @__PURE__ */ __name((self) => map8(make27(true), (ref) => asVoid(whenEffect(self, getAndSet2(ref, false)))), "once");
var option = /* @__PURE__ */ __name((self) => matchEffect(self, {
  onFailure: /* @__PURE__ */ __name(() => succeed(none2()), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed(some2(a)), "onSuccess")
}), "option");
var orElseFail = /* @__PURE__ */ dual(2, (self, evaluate3) => orElse(self, () => failSync(evaluate3)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self, evaluate3) => orElse(self, () => sync(evaluate3)));
var parallelErrors = /* @__PURE__ */ __name((self) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const errors = fromIterable(failures(cause5));
    return errors.length === 0 ? failCause(cause5) : fail2(errors);
  }, "onFailure"),
  onSuccess: succeed
}), "parallelErrors");
var patchFiberRefs = /* @__PURE__ */ __name((patch17) => updateFiberRefs((fiberId5, fiberRefs5) => pipe(patch17, patch6(fiberId5, fiberRefs5))), "patchFiberRefs");
var promise = /* @__PURE__ */ __name((evaluate3) => evaluate3.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate3(signal).then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
  } catch (e) {
    resolve(die2(e));
  }
}) : async_((resolve) => {
  try {
    ;
    evaluate3().then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
  } catch (e) {
    resolve(die2(e));
  }
}), "promise");
var provideService = /* @__PURE__ */ dual(3, (self, tag, service) => contextWithEffect((env) => provideContext(self, add2(env, tag, service))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self, tag, effect) => contextWithEffect((env) => flatMap7(effect, (service) => provideContext(self, pipe(env, add2(tag, service))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce8 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable(elements).reduce((acc, el, i) => flatMap7(acc, (a) => f(a, el, i)), succeed(zero3)));
var reduceRight2 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable(elements).reduceRight((acc, el, i) => flatMap7(acc, (a) => f(el, a, i)), succeed(zero3)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero3, options) => flatMap7(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop = /* @__PURE__ */ __name((iterator, index, state, predicate, f) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return flatMap7(f(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
}, "reduceWhileLoop");
var repeatN = /* @__PURE__ */ dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = /* @__PURE__ */ __name((self, n) => flatMap7(self, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self, n - 1))), "repeatNLoop");
var sandbox = /* @__PURE__ */ __name((self) => matchCauseEffect(self, {
  onFailure: fail2,
  onSuccess: succeed
}), "sandbox");
var setFiberRefs = /* @__PURE__ */ __name((fiberRefs5) => suspend(() => setAll2(fiberRefs5)), "setFiberRefs");
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = /* @__PURE__ */ __name((value) => succeed(some2(value)), "succeedSome");
var summarized = /* @__PURE__ */ dual(3, (self, summary9, f) => flatMap7(summary9, (start5) => flatMap7(self, (value) => map8(summary9, (end5) => [f(start5, end5), value]))));
var tagMetrics = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make28(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make28(k, v)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    effect = flatMap7(effect, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map8(effect, () => builder);
}));
var takeWhile = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    taking = flatMap7(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map8((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map8(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const either7 = failureOrCause(cause5);
    switch (either7._tag) {
      case "Left": {
        return zipRight(onFailure(either7.left), failCause(cause5));
      }
      case "Right": {
        return failCause(cause5);
      }
    }
  }, "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => as(onSuccess(a), a), "onSuccess")
}));
var tapDefect = /* @__PURE__ */ dual(2, (self, f) => catchAllCause(self, (cause5) => match2(keepDefects(cause5), {
  onNone: /* @__PURE__ */ __name(() => failCause(cause5), "onNone"),
  onSome: /* @__PURE__ */ __name((a) => zipRight(f(a), failCause(cause5)), "onSome")
})));
var tapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const either7 = failureOrCause(cause5);
    switch (either7._tag) {
      case "Left":
        return zipRight(f(either7.left), failCause(cause5));
      case "Right":
        return failCause(cause5);
    }
  }, "onFailure"),
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self, k, f) => tapError(self, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => zipRight(f(cause5), failCause(cause5)), "onFailure"),
  onSuccess: succeed
}));
var timed = /* @__PURE__ */ __name((self) => timedWith(self, currentTimeNanos2), "timed");
var timedWith = /* @__PURE__ */ dual(2, (self, nanos3) => summarized(self, nanos3, (start5, end5) => nanos(end5 - start5)));
var tracerWith3 = tracerWith2;
var tracer = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = /* @__PURE__ */ __name((arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  const fail9 = /* @__PURE__ */ __name((e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise")), "fail");
  if (evaluate3.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate3(signal).then((a) => resolve(succeed(a)), (e) => resolve(fail9(e)));
      } catch (e) {
        resolve(fail9(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate3().then((a) => resolve(succeed(a)), (e) => resolve(fail9(e)));
    } catch (e) {
      resolve(fail9(e));
    }
  });
}, "tryPromise");
var tryMap = /* @__PURE__ */ dual(2, (self, options) => flatMap7(self, (a) => try_({
  try: /* @__PURE__ */ __name(() => options.try(a), "try"),
  catch: options.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self, options) => flatMap7(self, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
var unlessEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap7(condition, (b) => b ? succeedNone : asSome(self)));
var unsandbox = /* @__PURE__ */ __name((self) => mapErrorCause(self, flatten3), "unsandbox");
var updateFiberRefs = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
}), "updateFiberRefs");
var updateService = /* @__PURE__ */ dual(3, (self, tag, f) => mapInputContext(self, (context7) => add2(context7, tag, f(unsafeGet3(context7, tag)))));
var when = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? map8(self, some2) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self, fiberRef, predicate) => flatMap7(fiberRefGet(fiberRef), (s) => predicate(s) ? map8(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self, ref, predicate) => flatMap7(get12(ref), (s) => predicate(s) ? map8(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self, metric) => metric(self));
var serviceFunctionEffect = /* @__PURE__ */ __name((getService, f) => (...args3) => flatMap7(getService, (a) => f(a)(...args3)), "serviceFunctionEffect");
var serviceFunction = /* @__PURE__ */ __name((getService, f) => (...args3) => map8(getService, (a) => f(a)(...args3)), "serviceFunction");
var serviceFunctions = /* @__PURE__ */ __name((getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args3) => flatMap7(getService, (s) => s[prop](...args3));
  }
}), "serviceFunctions");
var serviceConstants = /* @__PURE__ */ __name((getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap7(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
}), "serviceConstants");
var serviceMembers = /* @__PURE__ */ __name((getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
}), "serviceMembers");
var serviceOption = /* @__PURE__ */ __name((tag) => map8(context(), getOption2(tag)), "serviceOption");
var serviceOptional = /* @__PURE__ */ __name((tag) => flatMap7(context(), getOption2(tag)), "serviceOptional");
var annotateCurrentSpan = /* @__PURE__ */ __name(function() {
  const args3 = arguments;
  return ignore(flatMap7(currentSpan, (span3) => sync(() => {
    if (typeof args3[0] === "string") {
      span3.attribute(args3[0], args3[1]);
    } else {
      for (const key in args3[0]) {
        span3.attribute(key, args3[0][key]);
      }
    }
  })));
}, "annotateCurrentSpan");
var linkSpanCurrent = /* @__PURE__ */ __name(function() {
  const args3 = arguments;
  const links = Array.isArray(args3[0]) ? args3[0] : [{
    _tag: "SpanLink",
    span: args3[0],
    attributes: args3[1] ?? {}
  }];
  return ignore(flatMap7(currentSpan, (span3) => sync(() => span3.addLinks(links))));
}, "linkSpanCurrent");
var annotateSpans = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), function() {
  const args3 = arguments;
  return fiberRefLocallyWith(args3[0], currentTracerSpanAnnotations, typeof args3[1] === "string" ? set3(args3[1], args3[2]) : (annotations) => Object.entries(args3[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap7(/* @__PURE__ */ context(), (context7) => {
  const span3 = context7.unsafeMap.get(spanTag.key);
  return span3 !== void 0 && span3._tag === "Span" ? succeed(span3) : fail2(new NoSuchElementException());
});
var linkSpans = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (self, span3, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span3,
  attributes: attributes ?? {}
})));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span3) => get3(span3.context, DisablePropagation) ? span3._tag === "Span" ? filterDisablePropagation(span3.parent) : none2() : some2(span3));
var unsafeMakeSpan = /* @__PURE__ */ __name((fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
  const context7 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context7, spanTag));
  let span3;
  if (disablePropagation) {
    span3 = noopSpan({
      name,
      parent,
      context: add2(options.context ?? empty3(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer5 = get3(services, tracerTag);
    const clock5 = get3(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs5 = fiber.getFiberRefs();
    const annotationsFromEnv = get10(fiberRefs5, currentTracerSpanAnnotations);
    const linksFromEnv = get10(fiberRefs5, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty();
    span3 = tracer5.span(name, parent, options.context ?? empty3(), links, timingEnabled ? clock5.unsafeCurrentTimeNanos() : bigint02, options.kind ?? "internal", options);
    if (annotationsFromEnv._tag === "Some") {
      forEach3(annotationsFromEnv.value, (value, key) => span3.attribute(key, value));
    }
    if (options.attributes !== void 0) {
      Object.entries(options.attributes).forEach(([k, v]) => span3.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span3, options.captureStackTrace);
  }
  return span3;
}, "unsafeMakeSpan");
var makeSpan = /* @__PURE__ */ __name((name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
}, "makeSpan");
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = /* @__PURE__ */ __name((span3, exit7, clock5, timingEnabled) => sync(() => {
  if (span3.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit7) && spanToTrace.has(span3)) {
    span3.attribute("code.stacktrace", spanToTrace.get(span3)());
  }
  span3.end(timingEnabled ? clock5.unsafeCurrentTimeNanos() : bigint02, exit7);
}), "endSpan");
var useSpan = /* @__PURE__ */ __name((name, ...args3) => {
  const options = addSpanStackTrace(args3.length === 1 ? void 0 : args3[0]);
  const evaluate3 = args3[args3.length - 1];
  return withFiberRuntime((fiber) => {
    const span3 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock5 = get3(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate3(span3), (exit7) => endSpan(span3, exit7, clock5, timingEnabled));
  });
}, "useSpan");
var withParentSpan = /* @__PURE__ */ dual(2, (self, span3) => provideService(self, spanTag, span3));
var withSpan = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan(name, options, (span3) => withParentSpan(self, span3));
  }
  return (self) => useSpan(name, options, (span3) => withParentSpan(self, span3));
}, "withSpan");
var functionWithSpan = /* @__PURE__ */ __name((options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error();
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = /* @__PURE__ */ __name(() => {
      if (cache !== false) {
        return cache;
      }
      if (error.stack) {
        const stack = error.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    }, "captureStackTrace");
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
}, "functionWithSpan");
var fromNullable2 = /* @__PURE__ */ __name((value) => value == null ? fail2(new NoSuchElementException()) : succeed(value), "fromNullable");
var optionFromOptional = /* @__PURE__ */ __name((self) => catchAll(map8(self, some2), (error) => isNoSuchElementException(error) ? succeedNone : fail2(error)), "optionFromOptional");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = /* @__PURE__ */ __name((parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
}), "parallelN");
var isSequential = /* @__PURE__ */ __name((self) => self._tag === OP_SEQUENTIAL2, "isSequential");
var isParallel = /* @__PURE__ */ __name((self) => self._tag === OP_PARALLEL2, "isParallel");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6 = diff5;
var patch7 = patch6;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);
var Done = class {
  static {
    __name(this, "Done");
  }
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var Running = class {
  static {
    __name(this, "Running");
  }
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags3) {
    this.runtimeFlags = runtimeFlags3;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var Suspended = class {
  static {
    __name(this, "Suspended");
  }
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags3, blockingOn) {
    this.runtimeFlags = runtimeFlags3;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done3 = /* @__PURE__ */ new Done();
var running = /* @__PURE__ */ __name((runtimeFlags3) => new Running(runtimeFlags3), "running");
var suspended = /* @__PURE__ */ __name((runtimeFlags3, blockingOn) => new Suspended(runtimeFlags3, blockingOn), "suspended");
var isFiberStatus = /* @__PURE__ */ __name((u) => hasProperty(u, FiberStatusTypeId), "isFiberStatus");
var isDone = /* @__PURE__ */ __name((self) => self._tag === OP_DONE, "isDone");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/FiberStatus.js
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isDone2 = isDone;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Micro.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};
var MicroCauseImpl = class extends globalThis.Error {
  static {
    __name(this, "MicroCauseImpl");
  }
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
};
var Die = class extends MicroCauseImpl {
  static {
    __name(this, "Die");
  }
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
var causeDie = /* @__PURE__ */ __name((defect, traces = []) => new Die(defect, traces), "causeDie");
var Interrupt = class extends MicroCauseImpl {
  static {
    __name(this, "Interrupt");
  }
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = /* @__PURE__ */ __name((traces = []) => new Interrupt(traces), "causeInterrupt");
var causeIsInterrupt = /* @__PURE__ */ __name((self) => self._tag === "Interrupt", "causeIsInterrupt");
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var MicroFiberImpl = class {
  static {
    __name(this, "MicroFiberImpl");
  }
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context7, interruptible9 = true) {
    this.context = context7;
    this.interruptible = interruptible9;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit7 = this.runLoop(effect);
    if (exit7 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap8(interruptChildren, () => exit7));
    }
    this._exit = exit7;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit7);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap8(yieldNow2, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error) {
      if (!hasProperty(current, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie2(error);
    }
  }
  getCont(symbol5) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol5]: cont
      };
      if (op[symbol5]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberInterruptAll = /* @__PURE__ */ __name((fibers) => suspend2(() => {
  for (const fiber of fibers) fiber.unsafeInterrupt();
  const iter = fibers[Symbol.iterator]();
  const wait = suspend2(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async((resume3) => {
        fiber.addObserver((_) => {
          resume3(wait);
        });
      });
    }
    return exitVoid2;
  });
  return wait;
}), "fiberInterruptAll");
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId13]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
__name(defaultEvaluate, "defaultEvaluate");
var makePrimitiveProto = /* @__PURE__ */ __name((options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
}), "makePrimitiveProto");
var makePrimitive = /* @__PURE__ */ __name((options) => {
  const Proto3 = makePrimitiveProto(options);
  return function() {
    const self = Object.create(Proto3);
    self[args] = options.single === false ? arguments : arguments[0];
    return self;
  };
}, "makePrimitive");
var makeExit = /* @__PURE__ */ __name((options) => {
  const Proto3 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options.op))(hash(this[args])));
    }
  };
  return function(value) {
    const self = Object.create(Proto3);
    self[args] = value;
    self[successCont] = void 0;
    self[failureCont] = void 0;
    self[ensureCont] = void 0;
    return self;
  };
}, "makeExit");
var succeed3 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause2 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var sync2 = /* @__PURE__ */ makePrimitive({
  op: "Sync",
  eval(fiber) {
    const value = this[args]();
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](value, fiber) : fiber.yieldWith(exitSucceed2(value));
  }
});
var suspend2 = /* @__PURE__ */ makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_2 = /* @__PURE__ */ succeed3(void 0);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var asyncOptions = /* @__PURE__ */ makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : void 0;
    const onCancel = register((effect) => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect);
      } else {
        yielded = effect;
      }
    }, controller?.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid2;
    }));
    return Yield;
  }
});
var asyncFinalizer = /* @__PURE__ */ makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause5, _fiber) {
    return causeIsInterrupt(cause5) ? flatMap8(this[args](), () => failCause2(cause5)) : failCause2(cause5);
  }
});
var async = /* @__PURE__ */ __name((register) => asyncOptions(register, register.length >= 2), "async");
var as2 = /* @__PURE__ */ dual(2, (self, value) => map9(self, (_) => value));
var exit2 = /* @__PURE__ */ __name((self) => matchCause2(self, {
  onFailure: exitFailCause2,
  onSuccess: exitSucceed2
}), "exit");
var flatMap8 = /* @__PURE__ */ dual(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var map9 = /* @__PURE__ */ dual(2, (self, f) => flatMap8(self, (a) => succeed3(f(a))));
var isMicroExit = /* @__PURE__ */ __name((u) => hasProperty(u, MicroExitTypeId), "isMicroExit");
var exitSucceed2 = succeed3;
var exitFailCause2 = failCause2;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = /* @__PURE__ */ __name((defect) => exitFailCause2(causeDie(defect)), "exitDie");
var exitVoid2 = /* @__PURE__ */ exitSucceed2(void 0);
var exitVoidAll = /* @__PURE__ */ __name((exits) => {
  for (const exit7 of exits) {
    if (exit7._tag === "Failure") {
      return exit7;
    }
  }
  return exitVoid2;
}, "exitVoidAll");
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault = class {
  static {
    __name(this, "MicroSchedulerDefault");
  }
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = /* @__PURE__ */ __name(() => {
    this.running = false;
    this.runTasks();
  }, "afterScheduled");
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self, () => {
    fiber.context = prev;
    return void_2;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge3(provided)));
var MaxOpsBeforeYield = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: /* @__PURE__ */ __name(() => 2048, "defaultValue")
})) {
  static {
    __name(this, "MaxOpsBeforeYield");
  }
};
var CurrentConcurrency = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentConcurrency", {
  defaultValue: /* @__PURE__ */ __name(() => "unbounded", "defaultValue")
})) {
  static {
    __name(this, "CurrentConcurrency");
  }
};
var CurrentScheduler = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: /* @__PURE__ */ __name(() => new MicroSchedulerDefault(), "defaultValue")
})) {
  static {
    __name(this, "CurrentScheduler");
  }
};
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self, options) => {
  const primitive = Object.create(OnSuccessAndFailureProto);
  primitive[args] = self;
  primitive[successCont] = options.onSuccess;
  primitive[failureCont] = options.onFailure;
  return primitive;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var matchCause2 = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect2(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => sync2(() => options.onFailure(cause5)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((value) => sync2(() => options.onSuccess(value)), "onSuccess")
}));
var MicroScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
var MicroScopeImpl = class _MicroScopeImpl {
  static {
    __name(this, "MicroScopeImpl");
  }
  [MicroScopeTypeId];
  state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Set()
  };
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer);
    }
  }
  addFinalizer(finalizer) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer);
        return void_2;
      }
      return finalizer(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer);
    }
  }
  close(microExit) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap8(forEach4(finalizers, (finalizer) => exit2(finalizer(microExit))), exitVoidAll);
      }
      return void_2;
    });
  }
  get fork() {
    return sync2(() => {
      const newScope = new _MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit7) {
        return newScope.close(exit7);
      }
      __name(fin, "fin");
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_) => sync2(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
var onExit2 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
  onFailure: /* @__PURE__ */ __name((cause5) => flatMap8(f(exitFailCause2(cause5)), () => failCause2(cause5)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => flatMap8(f(exitSucceed2(a)), () => succeed3(a)), "onSuccess")
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = /* @__PURE__ */ __name((self) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self;
}), "interruptible");
var uninterruptibleMask2 = /* @__PURE__ */ __name((f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
}), "uninterruptibleMask");
var whileLoop2 = /* @__PURE__ */ makePrimitive({
  op: "While",
  contA(value, fiber) {
    this[args].step(value);
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  },
  eval(fiber) {
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  }
});
var forEach4 = /* @__PURE__ */ __name((iterable, f, options) => withMicroFiber((parent) => {
  const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable(iterable);
  let length3 = items.length;
  if (length3 === 0) {
    return options?.discard ? void_2 : succeed3([]);
  }
  const out = options?.discard ? void 0 : new Array(length3);
  let index = 0;
  if (concurrency === 1) {
    return as2(whileLoop2({
      while: /* @__PURE__ */ __name(() => index < items.length, "while"),
      body: /* @__PURE__ */ __name(() => f(items[index], index), "body"),
      step: out ? (b) => out[index++] = b : (_) => index++
    }), out);
  }
  return async((resume3) => {
    const fibers = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index < length3) {
        const currentIndex = index;
        const item = items[currentIndex];
        index++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f(item, currentIndex), true, true);
          fibers.add(child);
          child.addObserver((exit7) => {
            fibers.delete(child);
            if (interrupted) {
              return;
            } else if (exit7._tag === "Failure") {
              if (result === void 0) {
                result = exit7;
                length3 = index;
                fibers.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit7.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length3) {
              resume3(result ?? succeed3(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err) {
          result = exitDie2(err);
          length3 = index;
          fibers.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    __name(pump, "pump");
    pump();
    return suspend2(() => {
      interrupted = true;
      index = length3;
      return fiberInterruptAll(fibers);
    });
  });
}), "forEach");
var unsafeFork = /* @__PURE__ */ __name((parent, effect, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect), 0);
  }
  return child;
}, "unsafeFork");
var runFork = /* @__PURE__ */ __name((effect, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
  fiber.evaluate(effect);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = /* @__PURE__ */ __name(() => fiber.unsafeInterrupt(), "abort");
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
}, "runFork");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Scheduler.js
var PriorityBuckets = class {
  static {
    __name(this, "PriorityBuckets");
  }
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length3 = this.buckets.length;
    let bucket = void 0;
    let index = 0;
    for (; index < length3; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length3) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  static {
    __name(this, "MixedScheduler");
  }
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  static {
    __name(this, "SyncScheduler");
  }
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentScheduler, scheduler));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/concurrency.js
var match8 = /* @__PURE__ */ __name((concurrency, sequential7, unbounded3, bounded) => {
  switch (concurrency) {
    case void 0:
      return sequential7();
    case "unbounded":
      return unbounded3();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded3() : concurrency2 > 1 ? bounded(concurrency2) : sequential7());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential7();
  }
}, "match");
var matchSimple = /* @__PURE__ */ __name((concurrency, sequential7, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential7();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential7());
    default:
      return concurrency > 1 ? concurrent() : sequential7();
  }
}, "matchSimple");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = /* @__PURE__ */ __name((cause5) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause5
}), "interruptSignal");
var stateful = /* @__PURE__ */ __name((onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
}), "stateful");
var resume = /* @__PURE__ */ __name((effect) => ({
  _tag: OP_RESUME,
  effect
}), "resume");
var yieldNow3 = /* @__PURE__ */ __name(() => ({
  _tag: OP_YIELD_NOW
}), "yieldNow");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
var Global = class {
  static {
    __name(this, "Global");
  }
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var Local = class {
  static {
    __name(this, "Local");
  }
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId5, parent) {
    this.fiberId = fiberId5;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake6 = /* @__PURE__ */ __name((fiber) => {
  return new Local(fiber.id(), fiber);
}, "unsafeMake");
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var isRuntimeFiber = /* @__PURE__ */ __name((self) => RuntimeFiberTypeId in self, "isRuntimeFiber");
var _await2 = /* @__PURE__ */ __name((self) => self.await, "_await");
var inheritAll = /* @__PURE__ */ __name((self) => self.inheritAll, "inheritAll");
var interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers, fiberId5) {
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber)) {
      fiber.unsafeInterruptAsFork(fiberId5);
      continue;
    }
    yield* fiber.interruptAsFork(fiberId5);
  }
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
      continue;
    }
    yield* fiber.await;
  }
}));
var interruptAsFork = /* @__PURE__ */ dual(2, (self, fiberId5) => self.interruptAsFork(fiberId5));
var join2 = /* @__PURE__ */ __name((self) => zipLeft(flatten4(self.await), self.inheritAll), "join");
var _never = {
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: /* @__PURE__ */ __name(() => none4, "id"),
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: /* @__PURE__ */ __name(() => never, "interruptAsFork")
};
var currentFiberURI = "effect/FiberCurrent";

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: /* @__PURE__ */ __name((_) => _, "_Message"),
  /* c8 ignore next */
  _Output: /* @__PURE__ */ __name((_) => _, "_Output")
};
var makeLogger = /* @__PURE__ */ __name((log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: log5,
  pipe() {
    return pipeArguments(this, arguments);
  }
}), "makeLogger");
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var textOnly = /^[^\s"=]*$/;
var format3 = /* @__PURE__ */ __name((quoteValue, whitespace) => ({
  annotations,
  cause: cause5,
  date,
  fiberId: fiberId5,
  logLevel,
  message,
  spans
}) => {
  const formatValue = /* @__PURE__ */ __name((value) => value.match(textOnly) ? value : quoteValue(value), "formatValue");
  const format7 = /* @__PURE__ */ __name((label, value) => `${formatLabel(label)}=${formatValue(value)}`, "format");
  const append7 = /* @__PURE__ */ __name((label, value) => " " + format7(label, value), "append");
  let out = format7("timestamp", date.toISOString());
  out += append7("level", logLevel.label);
  out += append7("fiber", threadName(fiberId5));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append7("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause5)) {
    out += append7("cause", pretty(cause5, {
      renderErrorCause: true
    }));
  }
  for (const span3 of spans) {
    out += " " + render(date.getTime())(span3);
  }
  for (const [label, value] of annotations) {
    out += append7(label, toStringUnknown(value, whitespace));
  }
  return out;
}, "format");
var escapeDoubleQuotes = /* @__PURE__ */ __name((s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`, "escapeDoubleQuotes");
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
  static {
    __name(this, "MetricBoundariesImpl");
  }
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values5) {
    this.values = values5;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = /* @__PURE__ */ __name((u) => hasProperty(u, MetricBoundariesTypeId), "isMetricBoundaries");
var fromIterable7 = /* @__PURE__ */ __name((iterable) => {
  const values5 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values5);
}, "fromIterable");
var exponential = /* @__PURE__ */ __name((options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable7), "exponential");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var CounterKeyType = class {
  static {
    __name(this, "CounterKeyType");
  }
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FrequencyKeyTypeHash = /* @__PURE__ */ string(FrequencyKeyTypeSymbolKey);
var FrequencyKeyType = class {
  static {
    __name(this, "FrequencyKeyType");
  }
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [symbol]() {
    return FrequencyKeyTypeHash;
  }
  [symbol2](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeKeyTypeHash = /* @__PURE__ */ string(GaugeKeyTypeSymbolKey);
var GaugeKeyType = class {
  static {
    __name(this, "GaugeKeyType");
  }
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint) {
    this.bigint = bigint;
  }
  [symbol]() {
    return GaugeKeyTypeHash;
  }
  [symbol2](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramKeyType = class {
  static {
    __name(this, "HistogramKeyType");
  }
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryKeyType = class {
  static {
    __name(this, "SummaryKeyType");
  }
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
  constructor(maxAge, maxSize, error, quantiles) {
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error;
    this.quantiles = quantiles;
    this._hash = pipe(string(SummaryKeyTypeSymbolKey), combine(hash(this.maxAge)), combine(hash(this.maxSize)), combine(hash(this.error)), combine(array2(this.quantiles)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter = /* @__PURE__ */ __name((options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false), "counter");
var histogram = /* @__PURE__ */ __name((boundaries) => {
  return new HistogramKeyType(boundaries);
}, "histogram");
var isCounterKey = /* @__PURE__ */ __name((u) => hasProperty(u, CounterKeyTypeTypeId), "isCounterKey");
var isFrequencyKey = /* @__PURE__ */ __name((u) => hasProperty(u, FrequencyKeyTypeTypeId), "isFrequencyKey");
var isGaugeKey = /* @__PURE__ */ __name((u) => hasProperty(u, GaugeKeyTypeTypeId), "isGaugeKey");
var isHistogramKey = /* @__PURE__ */ __name((u) => hasProperty(u, HistogramKeyTypeTypeId), "isHistogramKey");
var isSummaryKey = /* @__PURE__ */ __name((u) => hasProperty(u, SummaryKeyTypeTypeId), "isSummaryKey");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type")
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence(equals);
var MetricKeyImpl = class {
  static {
    __name(this, "MetricKeyImpl");
  }
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = /* @__PURE__ */ __name((u) => hasProperty(u, MetricKeyTypeId), "isMetricKey");
var counter2 = /* @__PURE__ */ __name((name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description)), "counter");
var histogram2 = /* @__PURE__ */ __name((name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description)), "histogram");
var taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union(self.tags, extraTags)));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var CounterState = class {
  static {
    __name(this, "CounterState");
  }
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = /* @__PURE__ */ getEquivalence(equals);
var FrequencyState = class {
  static {
    __name(this, "FrequencyState");
  }
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeState = class {
  static {
    __name(this, "GaugeState");
  }
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramState = class {
  static {
    __name(this, "HistogramState");
  }
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min5, max9, sum3) {
    this.buckets = buckets;
    this.count = count;
    this.min = min5;
    this.max = max9;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryState = class {
  static {
    __name(this, "SummaryState");
  }
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min5, max9, sum3) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min5;
    this.max = max9;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter3 = /* @__PURE__ */ __name((count) => new CounterState(count), "counter");
var frequency2 = /* @__PURE__ */ __name((occurrences) => {
  return new FrequencyState(occurrences);
}, "frequency");
var gauge2 = /* @__PURE__ */ __name((count) => new GaugeState(count), "gauge");
var histogram3 = /* @__PURE__ */ __name((options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum), "histogram");
var summary2 = /* @__PURE__ */ __name((options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum), "summary");
var isCounterState = /* @__PURE__ */ __name((u) => hasProperty(u, CounterStateTypeId), "isCounterState");
var isFrequencyState = /* @__PURE__ */ __name((u) => hasProperty(u, FrequencyStateTypeId), "isFrequencyState");
var isGaugeState = /* @__PURE__ */ __name((u) => hasProperty(u, GaugeStateTypeId), "isGaugeState");
var isHistogramState = /* @__PURE__ */ __name((u) => hasProperty(u, HistogramStateTypeId), "isHistogramState");
var isSummaryState = /* @__PURE__ */ __name((u) => hasProperty(u, SummaryStateTypeId), "isSummaryState");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var make29 = /* @__PURE__ */ __name((options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
}), "make");
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = /* @__PURE__ */ __name((key) => {
  let sum3 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint03 : (value) => value >= 0 : (_value) => true;
  const update9 = /* @__PURE__ */ __name((value) => {
    if (canUpdate(value)) {
      sum3 = sum3 + value;
    }
  }, "update");
  return make29({
    get: /* @__PURE__ */ __name(() => counter3(sum3), "get"),
    update: update9,
    modify: update9
  });
}, "counter");
var frequency3 = /* @__PURE__ */ __name((key) => {
  const values5 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values5.set(word, 0);
  }
  const update9 = /* @__PURE__ */ __name((word) => {
    const slotCount = values5.get(word) ?? 0;
    values5.set(word, slotCount + 1);
  }, "update");
  return make29({
    get: /* @__PURE__ */ __name(() => frequency2(values5), "get"),
    update: update9,
    modify: update9
  });
}, "frequency");
var gauge3 = /* @__PURE__ */ __name((_key, startAt) => {
  let value = startAt;
  return make29({
    get: /* @__PURE__ */ __name(() => gauge2(value), "get"),
    update: /* @__PURE__ */ __name((v) => {
      value = v;
    }, "update"),
    modify: /* @__PURE__ */ __name((v) => {
      value = value + v;
    }, "modify")
  });
}, "gauge");
var histogram4 = /* @__PURE__ */ __name((key) => {
  const bounds = key.keyType.boundaries.values;
  const size17 = bounds.length;
  const values5 = new Uint32Array(size17 + 1);
  const boundaries = new Float64Array(size17);
  let count = 0;
  let sum3 = 0;
  let min5 = Number.MAX_VALUE;
  let max9 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map2((n, i) => {
    boundaries[i] = n;
  }));
  const update9 = /* @__PURE__ */ __name((value) => {
    let from = 0;
    let to = size17;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values5[from] = values5[from] + 1;
    count = count + 1;
    sum3 = sum3 + value;
    if (value < min5) {
      min5 = value;
    }
    if (value > max9) {
      max9 = value;
    }
  }, "update");
  const getBuckets = /* @__PURE__ */ __name(() => {
    const builder = allocate(size17);
    let cumulated = 0;
    for (let i = 0; i < size17; i++) {
      const boundary = boundaries[i];
      const value = values5[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  }, "getBuckets");
  return make29({
    get: /* @__PURE__ */ __name(() => histogram3({
      buckets: getBuckets(),
      count,
      min: min5,
      max: max9,
      sum: sum3
    }), "get"),
    update: update9,
    modify: update9
  });
}, "histogram");
var summary3 = /* @__PURE__ */ __name((key) => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values5 = allocate(maxSize);
  let head9 = 0;
  let count = 0;
  let sum3 = 0;
  let min5 = 0;
  let max9 = 0;
  const snapshot = /* @__PURE__ */ __name((now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values5[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo2(age, zero) && lessThanOrEqualTo2(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Order));
  }, "snapshot");
  const observe = /* @__PURE__ */ __name((value, timestamp) => {
    if (maxSize > 0) {
      head9 = head9 + 1;
      const target = head9 % maxSize;
      values5[target] = [timestamp, value];
    }
    min5 = count === 0 ? value : Math.min(min5, value);
    max9 = count === 0 ? value : Math.max(max9, value);
    count = count + 1;
    sum3 = sum3 + value;
  }, "observe");
  return make29({
    get: /* @__PURE__ */ __name(() => summary2({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min: min5,
      max: max9,
      sum: sum3
    }), "get"),
    update: /* @__PURE__ */ __name(([value, timestamp]) => observe(value, timestamp), "update"),
    modify: /* @__PURE__ */ __name(([value, timestamp]) => observe(value, timestamp), "modify")
  });
}, "summary");
var calculateQuantiles = /* @__PURE__ */ __name((error, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty();
  }
  const head9 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head9, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map2(resolved, (rq) => [rq.quantile, rq.value]);
}, "calculateQuantiles");
var resolveQuantile = /* @__PURE__ */ __name((error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "resolveQuantile");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type")
};
var unsafeMake7 = /* @__PURE__ */ __name((metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
}, "unsafeMake");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
var MetricRegistryImpl = class {
  static {
    __name(this, "MetricRegistryImpl");
  }
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty17();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake7(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get8(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const counter11 = counter4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, counter11));
      }
      value = counter11;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const frequency9 = frequency3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, frequency9));
      }
      value = frequency9;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const gauge9 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, gauge9));
      }
      value = gauge9;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const histogram11 = histogram4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, histogram11));
      }
      value = histogram11;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const summary9 = summary3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, summary9));
      }
      value = summary9;
    }
    return value;
  }
};
var make30 = /* @__PURE__ */ __name(() => {
  return new MetricRegistryImpl();
}, "make");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make30());
var make31 = /* @__PURE__ */ __name(function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect) => tap(effect, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
}, "make");
var counter5 = /* @__PURE__ */ __name((name, options) => fromMetricKey(counter2(name, options)), "counter");
var fromMetricKey = /* @__PURE__ */ __name((key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = /* @__PURE__ */ __name((extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  }, "hook");
  return make31(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
}, "fromMetricKey");
var histogram5 = /* @__PURE__ */ __name((name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description)), "histogram");
var tagged = /* @__PURE__ */ dual(3, (self, key, value) => taggedWithLabels2(self, [make28(key, value)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self, extraTags) => {
  return make31(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self.unsafeUpdate(input, tags))));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = /* @__PURE__ */ __name((u) => hasProperty(u, RequestTypeId), "isRequest");
var complete = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map23) => sync(() => {
  if (map23.has(self)) {
    const entry = map23.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var Listeners = class {
  static {
    __name(this, "Listeners");
  }
  count = 0;
  observers = /* @__PURE__ */ new Set();
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
};

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  static {
    __name(this, "RedBlackTreeIterator");
  }
  self;
  stack;
  direction;
  count = 0;
  constructor(self, stack, direction) {
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone = /* @__PURE__ */ __name(({
  color,
  count,
  key,
  left: left5,
  right: right5,
  value
}) => ({
  color,
  key,
  value,
  left: left5,
  right: right5,
  count
}), "clone");
function swap2(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
__name(swap2, "swap");
var repaint = /* @__PURE__ */ __name(({
  count,
  key,
  left: left5,
  right: right5,
  value
}, color) => ({
  color,
  key,
  value,
  left: left5,
  right: right5,
  count
}), "repaint");
var recount = /* @__PURE__ */ __name((node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
}, "recount");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash3 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash3 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash3);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries3 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries3[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = /* @__PURE__ */ __name((ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
}, "makeImpl");
var isRedBlackTree = /* @__PURE__ */ __name((u) => hasProperty(u, RedBlackTreeTypeId), "isRedBlackTree");
var findFirst4 = /* @__PURE__ */ dual(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some2(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var has5 = /* @__PURE__ */ dual(2, (self, key) => isSome2(findFirst4(self, key)));
var insert = /* @__PURE__ */ dual(3, (self, key, value) => {
  const cmp = self._ord;
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self._ord, n_stack[0]);
});
var keysForward = /* @__PURE__ */ __name((self) => keys3(self, Direction.Forward), "keysForward");
var keys3 = /* @__PURE__ */ __name((self, direction) => {
  const begin = self[Symbol.iterator]();
  let count = 0;
  return {
    [Symbol.iterator]: () => keys3(self, direction),
    next: /* @__PURE__ */ __name(() => {
      count++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }, "next")
  };
}, "keys");
var removeFirst = /* @__PURE__ */ dual(2, (self, key) => {
  if (!has5(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split - 1].key = n.key;
    cstack[split - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split - 1].left = cstack[split];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap2(n, n.left);
      } else if (n.right !== void 0) {
        swap2(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var fixDoubleBlack = /* @__PURE__ */ __name((stack) => {
  let n, p, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.right = clone(s);
        z = s.right = clone(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.right = clone(s);
        z = s.left = clone(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.right = repaint(s, Color.Red);
          return;
        } else {
          p.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.left = clone(s);
        z = s.left = clone(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.left = clone(s);
        z = s.right = clone(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.left = repaint(s, Color.Red);
          return;
        } else {
          p.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
}, "fixDoubleBlack");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/RedBlackTree.js
var has6 = has5;
var insert2 = insert;
var keys4 = keysForward;
var removeFirst2 = removeFirst;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/SortedSet.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId14]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId14)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys4(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = /* @__PURE__ */ __name((keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
}, "fromTree");
var isSortedSet = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId14), "isSortedSet");
var add5 = /* @__PURE__ */ dual(2, (self, value) => has6(self.keyTree, value) ? self : fromTree(insert2(self.keyTree, value, true)));
var remove7 = /* @__PURE__ */ dual(2, (self, value) => fromTree(removeFirst2(self.keyTree, value)));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: /* @__PURE__ */ __name((_) => _, "_T")
};
var ProxySupervisor = class _ProxySupervisor {
  static {
    __name(this, "ProxySupervisor");
  }
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context7, effect, parent, fiber) {
    this.underlying.onStart(context7, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new _ProxySupervisor(this, pipe(this.value, map8(f)));
  }
  zip(right5) {
    return new Zip(this, right5);
  }
};
var Zip = class _Zip {
  static {
    __name(this, "Zip");
  }
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left5, right5) {
    this.left = left5;
    this.right = right5;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context7, effect, parent, fiber) {
    this.left.onStart(context7, effect, parent, fiber);
    this.right.onStart(context7, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map8(f)));
  }
  zip(right5) {
    return new _Zip(this, right5);
  }
};
var isZip = /* @__PURE__ */ __name((self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip"), "isZip");
var Track = class {
  static {
    __name(this, "Track");
  }
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set();
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map8(f)));
  }
  zip(right5) {
    return new Zip(this, right5);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var Const = class {
  static {
    __name(this, "Const");
  }
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map8(f)));
  }
  zip(right5) {
    return new Zip(this, right5);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var FibersIn = class {
  static {
    __name(this, "FibersIn");
  }
  ref;
  [SupervisorTypeId] = supervisorVariance;
  constructor(ref) {
    this.ref = ref;
  }
  get value() {
    return sync(() => get6(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set2(pipe(get6(this.ref), add5(fiber))));
  }
  onEnd(_value, fiber) {
    pipe(this.ref, set2(pipe(get6(this.ref), remove7(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map8(f)));
  }
  zip(right5) {
    return new Zip(this, right5);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var unsafeTrack = /* @__PURE__ */ __name(() => {
  return new Track();
}, "unsafeTrack");
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect = /* @__PURE__ */ __name((effect) => {
  return new Const(effect);
}, "fromEffect");
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Differ.js
var make33 = make14;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty25 = {
  _tag: OP_EMPTY3
};
var combine8 = /* @__PURE__ */ __name((self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
}, "combine");
var patch8 = /* @__PURE__ */ __name((self, supervisor) => {
  return patchLoop(supervisor, of2(self));
}, "patch");
var patchLoop = /* @__PURE__ */ __name((_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head9 = headNonEmpty2(patches);
    switch (head9._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head9.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head9.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head9.first)(prepend2(head9.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
}, "patchLoop");
var removeSupervisor = /* @__PURE__ */ __name((self, that) => {
  if (equals(self, that)) {
    return none8;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
}, "removeSupervisor");
var toSet2 = /* @__PURE__ */ __name((self) => {
  if (equals(self, none8)) {
    return empty7();
  } else {
    if (isZip(self)) {
      return pipe(toSet2(self.left), union3(toSet2(self.right)));
    } else {
      return make10(self);
    }
  }
}, "toSet");
var diff7 = /* @__PURE__ */ __name((oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty25;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce4(empty25, (patch17, supervisor) => combine8(patch17, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce4(empty25, (patch17, supervisor) => combine8(patch17, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine8(added, removed);
}, "diff");
var differ2 = /* @__PURE__ */ make33({
  empty: empty25,
  patch: patch8,
  combine: combine8,
  diff: diff7
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var absurd = /* @__PURE__ */ __name((_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
}, "absurd");
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: /* @__PURE__ */ __name((_, _cont, value) => {
    return exitSucceed(exitSucceed(value));
  }, "OnStep"),
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS]: (self, cont, value) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value);
    }
  },
  [OP_WHILE]: (self, cont, value) => {
    internalCall(() => cont.effect_instruction_i2(value));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self, cont, value) => {
    while (true) {
      const state = internalCall(() => cont.effect_instruction_i0.next(value));
      if (state.done) {
        return exitSucceed(state.value);
      }
      const primitive = yieldWrapGet(state.value);
      if (!exitIsExit(primitive)) {
        self.pushStack(cont);
        return primitive;
      } else if (primitive._tag === "Failure") {
        return primitive;
      }
      value = primitive.value;
    }
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags3, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags3) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags3, cur, message) => {
    message.onFiber(self, running2(runtimeFlags3));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap7(yieldNow(), () => cur);
  }
};
var runBlockedRequests = /* @__PURE__ */ __name((self) => forEachSequentialDiscard(flatten2(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential7]) => {
  const map23 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential7) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map23.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map23);
}, false, false)), "runBlockedRequests");
var _version = /* @__PURE__ */ getCurrentVersion();
var FiberRuntime = class extends Class2 {
  static {
    __name(this, "FiberRuntime");
  }
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array();
  _children = null;
  _observers = /* @__PURE__ */ new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId5, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId5;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect) {
    this.tell(resume(effect));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status) => status);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (isDone2(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake6(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume3) => {
      const cb = /* @__PURE__ */ __name((exit7) => resume3(succeed(exit7)), "cb");
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch17 = pipe(
        diff4(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch17);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId5) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId5))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId5) {
    this.tell(interruptSignal(interrupt(fiberId5)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs5) {
    this._fiberRefs = fiberRefs5;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope5) {
    const children = this._children;
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        if (child._exitValue === null) {
          scope5.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags3, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags3, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty5(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause5) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause5));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause5) {
    this.addInterruptedCause(cause5);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone9 = false;
      const body = /* @__PURE__ */ __name(() => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone9 = true;
          });
        }
      }, "body");
      return whileLoop({
        while: /* @__PURE__ */ __name(() => !isDone9, "while"),
        body,
        step: /* @__PURE__ */ __name(() => {
        }, "step")
      });
    }
    return null;
  }
  reportExitValue(exit7) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit7._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit7._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit7.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit7.cause, level);
      }
    }
  }
  setExitValue(exit7) {
    this._exitValue = exit7;
    this.reportExitValue(exit7);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit7);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause5, overrideLogLevel) {
    const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan2(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get3(this.getFiberRef(currentServices), clockTag);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause: cause5,
            context: contextMap,
            spans,
            annotations,
            date
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit7 = this.runLoop(eff);
        if (exit7 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect = null;
            } else {
              effect = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption3 = this.interruptAllChildren();
          if (interruption3 !== null) {
            effect = flatMap7(interruption3, () => exit7);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit7);
            } else {
              this.tell(resume(exit7));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect) {
    this.tell(resume(effect));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch17) {
    const newRuntimeFlags = patch4(oldRuntimeFlags, patch17);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags3, asyncRegister) {
    let alreadyCalled = false;
    const callback = /* @__PURE__ */ __name((effect) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect));
      }
    }, "callback");
    if (interruptible(runtimeFlags3)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume3 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit7) => {
        if (exit7._tag === "Success") {
          return resume3(exitSucceed(exit7.value));
        }
        switch (exit7.cause._tag) {
          case "Interrupt": {
            return resume3(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume3(fail2(exit7.cause.error));
          }
          case "Die": {
            return resume3(die2(exit7.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume3 = /* @__PURE__ */ __name((_) => {
          abortResume(void_);
        }, "resume");
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause5 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause5));
          } else {
            return exitFailCause(stripFailures(cause5));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause5));
          } else {
            return exitFailCause(stripFailures(cause5));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause5, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause5);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause5);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff6(snap.refs, refs);
      const patchFlags = diff4(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap7(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check3 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check3()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap7(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty16, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = /* @__PURE__ */ __name(() => {
    this.drainQueueOnCurrentThread();
  }, "run");
};
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = /* @__PURE__ */ __name((self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get3(services, consoleTag).unsafe.log(self.log(opts));
}), "loggerWithConsoleLog");
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations,
  cause: cause5,
  context: context7,
  fiberId: fiberId5,
  logLevel,
  message
}) => {
  const span3 = getOption2(getOrDefault(context7, currentContext), spanTag);
  if (span3._tag === "None" || span3.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context7, currentServices), clockTag);
  const attributes = {};
  for (const [key, value] of annotations) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName2(fiberId5);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause5 !== null && cause5._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause5, {
      renderErrorCause: true
    });
  }
  span3.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make10(defaultLogger, tracerLogger)));
var annotateLogsScoped = /* @__PURE__ */ __name(function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
  }
  const entries3 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations) => {
    for (let i = 0; i < entries3.length; i++) {
      const [key, value] = entries3[i];
      set3(annotations, key, value);
    }
    return annotations;
  }));
}, "annotateLogsScoped");
var whenLogLevel = /* @__PURE__ */ dual(2, (effect, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan2(minimumLogLevel, requiredLogLevel)) {
      return succeed(none2());
    }
    return map8(effect, some2);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit7) => release(a, exit7)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit7) => release(exit7))));
var addFinalizer = /* @__PURE__ */ __name((finalizer) => withFiberRuntime((runtime7) => {
  const acquireRefs = runtime7.getFiberRefs();
  const acquireFlags = disable2(runtime7.currentRuntimeFlags, Interruption);
  return flatMap7(scope, (scope5) => scopeAddFinalizerExit(scope5, (exit7) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff6(preRefs, acquireRefs);
    const patchFlags = diff4(preFlags, acquireFlags);
    const inverseRefs = diff6(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer(exit7), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
}), "addFinalizer");
var daemonChildren = /* @__PURE__ */ __name((self) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self);
}, "daemonChildren");
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists = /* @__PURE__ */ dual((args3) => isIterable(args3[0]) && !isEffect(args3[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach7(elements, (a, i) => if_(predicate(a, i), {
  onTrue: /* @__PURE__ */ __name(() => fail2(_existsParFound), "onTrue"),
  onFalse: /* @__PURE__ */ __name(() => void_, "onFalse")
}), options), {
  onFailure: /* @__PURE__ */ __name((e) => e === _existsParFound ? succeed(true) : fail2(e), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => succeed(false), "onSuccess")
})));
var existsLoop = /* @__PURE__ */ __name((iterator, index, f) => {
  const next = iterator.next();
  if (next.done) {
    return succeed(false);
  }
  return flatMap7(f(next.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f));
}, "existsLoop");
var filter4 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]) && !isEffect(args3[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map8(predicate(a, i), not) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i) => zipWith2(effect, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map8(forEach7(elements, (a, i) => map8(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
});
var allResolveInput = /* @__PURE__ */ __name((input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys9 = Object.keys(input);
  const size17 = keys9.length;
  return [keys9.map((k) => input[k]), some2((values5) => {
    const res = {};
    for (let i = 0; i < size17; i++) {
      ;
      res[keys9[i]] = values5[i];
    }
    return res;
  })];
}, "allResolveInput");
var allValidate = /* @__PURE__ */ __name((effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  return flatMap7(forEach7(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none19 = none2();
    const size17 = eithers.length;
    const errors = new Array(size17);
    const successes = new Array(size17);
    let errored = false;
    for (let i = 0; i < size17; i++) {
      const either7 = eithers[i];
      if (either7._tag === "Left") {
        errors[i] = some2(either7.left);
        errored = true;
      } else {
        successes[i] = either7.right;
        errors[i] = none19;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
}, "allValidate");
var allEither = /* @__PURE__ */ __name((effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  if (options?.discard) {
    return forEach7(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map8(forEach7(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
}, "allEither");
var all2 = /* @__PURE__ */ __name((arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map8(forEach7(effects, identity, options), reconcile.value) : forEach7(effects, identity, options);
}, "all");
var allWith = /* @__PURE__ */ __name((options) => (arg) => all2(arg, options), "allWith");
var allSuccesses = /* @__PURE__ */ __name((elements, options) => map8(all2(fromIterable(elements).map(exit), options), filterMap((exit7) => exitIsSuccess(exit7) ? some2(exit7.effect_instruction_i0) : none2())), "allSuccesses");
var replicate = /* @__PURE__ */ dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (self, n, options) => all2(replicate(self, n), options));
var forEach7 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (self, f, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match8(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match8(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = /* @__PURE__ */ __name((self, f, batching) => suspend(() => {
  const as7 = fromIterable(self);
  const array6 = new Array(as7.length);
  const fn3 = /* @__PURE__ */ __name((a, i) => flatMap7(f(a, i), (b) => sync(() => array6[i] = b)), "fn");
  return zipRight(forEachConcurrentDiscard(as7, fn3, batching, false), succeed(array6));
}), "forEachParUnbounded");
var forEachConcurrentDiscard = /* @__PURE__ */ __name((self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter11 = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll = /* @__PURE__ */ __name(() => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  }), "interruptAll");
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = /* @__PURE__ */ __name(() => {
    const exits = results.filter(({
      exit: exit7
    }) => exit7._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit7
    }) => exit7);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  }, "collectExits");
  const runFiber = /* @__PURE__ */ __name((eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  }, "runFiber");
  const onInterruptSignal = /* @__PURE__ */ __name(() => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  }, "onInterruptSignal");
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume3) => {
    const pushResult = /* @__PURE__ */ __name((res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    }, "pushResult");
    const next = /* @__PURE__ */ __name(() => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter11++;
        const returnNextElement = /* @__PURE__ */ __name(() => {
          const a2 = todos.pop();
          index = counter11++;
          return flatMap7(yieldNow(), () => flatMap7(stepOrExit(restore(f(a2, index))), onRes));
        }, "returnNextElement");
        const onRes = /* @__PURE__ */ __name((res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        }, "onRes");
        const todo = flatMap7(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit7;
          if (wrapped._op === "Failure") {
            exit7 = wrapped;
          } else {
            exit7 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit7, index);
          if (results.length === target) {
            resume3(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked5) => blocked5.effect_instruction_i0).reduce(par);
            resume3(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked5) => blocked5.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    }, "next");
    for (let i = 0; i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit(flatten4(restore(join2(processingFiber))), exitMatch({
    onFailure: /* @__PURE__ */ __name((cause5) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check3 = /* @__PURE__ */ __name((index2, hitNext) => (exit7) => {
          exits[index2] = exit7;
          count++;
          if (count === target2) {
            cb(exitSucceed(exitFailCause(cause5)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        }, "check");
        const next = /* @__PURE__ */ __name(() => {
          runFiber(toPop.pop(), true).addObserver(check3(index, true));
          index++;
        }, "next");
        processingFiber.addObserver(check3(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next();
        }
      });
    }, "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => forEachSequential(joinOrder, (f2) => f2.inheritAll), "onSuccess")
  })));
}))), "forEachConcurrentDiscard");
var forEachParN = /* @__PURE__ */ __name((self, n, f, batching) => suspend(() => {
  const as7 = fromIterable(self);
  const array6 = new Array(as7.length);
  const fn3 = /* @__PURE__ */ __name((a, i) => map8(f(a, i), (b) => array6[i] = b), "fn");
  return zipRight(forEachConcurrentDiscard(as7, fn3, batching, false, n), succeed(array6));
}), "forEachParN");
var fork = /* @__PURE__ */ __name((self) => withFiberRuntime((state, status) => succeed(unsafeFork2(self, state, status.runtimeFlags))), "fork");
var forkDaemon = /* @__PURE__ */ __name((self) => forkWithScopeOverride(self, globalScope), "forkDaemon");
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self, handler) => fork(onError(self, (cause5) => {
  const either7 = failureOrCause(cause5);
  switch (either7._tag) {
    case "Left":
      return handler(either7.left);
    case "Right":
      return failCause(either7.right);
  }
})));
var unsafeFork2 = /* @__PURE__ */ __name((effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
}, "unsafeFork");
var unsafeForkUnstarted = /* @__PURE__ */ __name((effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
}, "unsafeForkUnstarted");
var unsafeMakeChildFiber = /* @__PURE__ */ __name((effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake2();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
  childFiber.addObserver((exit7) => supervisor.onEnd(exit7, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
}, "unsafeMakeChildFiber");
var forkWithScopeOverride = /* @__PURE__ */ __name((self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self, parentFiber, parentStatus.runtimeFlags, scopeOverride))), "forkWithScopeOverride");
var mergeAll3 = /* @__PURE__ */ dual((args3) => isFunction2(args3[2]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith2(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap7(make27(zero3), (acc) => flatMap7(forEach7(elements, (effect, i) => flatMap7(effect, (a) => update3(acc, (b) => f(b, a, i))), options), () => get12(acc)))));
var partition3 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (elements, f, options) => pipe(forEach7(elements, (a, i) => either2(f(a, i)), options), map8((chunk3) => partitionMap2(chunk3, identity))));
var validateAll = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (elements, f, options) => flatMap7(partition3(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_ : succeed(bs)));
var raceAll = /* @__PURE__ */ __name((all7) => withFiberRuntime((state, status) => async_((resume3) => {
  const fibers = /* @__PURE__ */ new Set();
  let winner;
  let failures3 = empty16;
  const interruptAll = /* @__PURE__ */ __name(() => {
    for (const fiber of fibers) {
      fiber.unsafeInterruptAsFork(state.id());
    }
  }, "interruptAll");
  let latch = false;
  let empty57 = true;
  for (const self of all7) {
    empty57 = false;
    const fiber = unsafeFork2(interruptible2(self), state, status.runtimeFlags);
    fibers.add(fiber);
    fiber.addObserver((exit7) => {
      fibers.delete(fiber);
      if (!winner) {
        if (exit7._tag === "Success") {
          latch = true;
          winner = fiber;
          failures3 = empty16;
          interruptAll();
        } else {
          failures3 = parallel(exit7.cause, failures3);
        }
      }
      if (latch && fibers.size === 0) {
        resume3(winner ? zipRight(inheritAll(winner), winner.unsafePoll()) : failCause(failures3));
      }
    });
    if (winner) break;
  }
  if (empty57) {
    return resume3(dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`)));
  }
  latch = true;
  return interruptAllAs(fibers, state.id());
})), "raceAll");
var reduceEffect = /* @__PURE__ */ dual((args3) => isIterable(args3[0]) && !isEffect(args3[0]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith2(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f(acc.value, elem, i));
    }
  }
}, options), map8((option5) => {
  switch (option5._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option5.value;
    }
  }
})))));
var parallelFinalizers = /* @__PURE__ */ __name((self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: /* @__PURE__ */ __name(() => self, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    switch (scope5.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap7(scopeFork(scope5, parallel3), (inner) => scopeExtend(self, inner));
    }
  }, "onSome")
})), "parallelFinalizers");
var parallelNFinalizers = /* @__PURE__ */ __name((parallelism) => (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: /* @__PURE__ */ __name(() => self, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap7(scopeFork(scope5, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }, "onSome")
})), "parallelNFinalizers");
var finalizersMask = /* @__PURE__ */ __name((strategy) => (self) => finalizersMaskInternal(strategy, true)(self), "finalizersMask");
var finalizersMaskInternal = /* @__PURE__ */ __name((strategy, concurrentFinalizers) => (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: /* @__PURE__ */ __name(() => self(identity), "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    if (concurrentFinalizers === true) {
      const patch17 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope5.strategy._tag) {
        case "Parallel":
          return patch17(self(parallelFinalizers));
        case "Sequential":
          return patch17(self(sequentialFinalizers));
        case "ParallelN":
          return patch17(self(parallelNFinalizers(scope5.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }, "onSome")
})), "finalizersMaskInternal");
var scopeWith = /* @__PURE__ */ __name((f) => flatMap7(scopeTag, f), "scopeWith");
var scopedWith = /* @__PURE__ */ __name((f) => flatMap7(scopeMake(), (scope5) => onExit(f(scope5), (exit7) => scope5.close(exit7))), "scopedWith");
var scopedEffect = /* @__PURE__ */ __name((effect) => flatMap7(scopeMake(), (scope5) => scopeUse(effect, scope5)), "scopedEffect");
var sequentialFinalizers = /* @__PURE__ */ __name((self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: /* @__PURE__ */ __name(() => self, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    switch (scope5.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap7(scopeFork(scope5, sequential3), (inner) => scopeExtend(self, inner));
    }
  }, "onSome")
})), "sequentialFinalizers");
var tagMetricsScoped = /* @__PURE__ */ __name((key, value) => labelMetricsScoped([make28(key, value)]), "tagMetricsScoped");
var labelMetricsScoped = /* @__PURE__ */ __name((labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels)), "labelMetricsScoped");
var using = /* @__PURE__ */ dual(2, (self, use) => scopedWith((scope5) => flatMap7(scopeExtend(self, scope5), use)));
var validate = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
var validateWith = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, f, options) => flatten4(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: /* @__PURE__ */ __name((ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb), "onFailure")
}), options)));
var validateFirst = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (elements, f, options) => flip(forEach7(elements, (a, i) => flip(f(a, i)), options)));
var withClockScoped = /* @__PURE__ */ __name((c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c)), "withClockScoped");
var withRandomScoped = /* @__PURE__ */ __name((value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value)), "withRandomScoped");
var withConfigProviderScoped = /* @__PURE__ */ __name((provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider)), "withConfigProviderScoped");
var withEarlyRelease = /* @__PURE__ */ __name((self) => scopeWith((parent) => flatMap7(scopeFork(parent, sequential2), (child) => pipe(self, scopeExtend(child), map8((value) => [fiberIdWith((fiberId5) => scopeClose(child, exitInterrupt(fiberId5))), value])))), "withEarlyRelease");
var zipOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
var zipLeftOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipLeft(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options);
});
var zipRightOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipRight(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options);
});
var zipWithOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self, that, f, options) => map8(all2([self, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = /* @__PURE__ */ __name((update9) => {
  if (update9 === empty14) {
    return void_;
  }
  return pipe(runtimeFlags, flatMap7((runtimeFlags3) => {
    const updatedRuntimeFlags = patch4(runtimeFlags3, update9);
    const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags3);
    return pipe(updateRuntimeFlags(update9), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
  }), uninterruptible);
}, "withRuntimeFlagsScoped");
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = /* @__PURE__ */ __name((scope5, fin) => {
  if (scope5.state._tag === "Open") {
    scope5.state.finalizers.set({}, fin);
  }
}, "scopeUnsafeAddFinalizer");
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = /* @__PURE__ */ __name((exit7) => newScope.close(exit7), "fin");
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit7) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit7
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit7))), flatMap7((results) => pipe(exitCollectAll(results), map(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit7)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit7)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = /* @__PURE__ */ __name((strategy = sequential2) => {
  const scope5 = Object.create(ScopeImplProto);
  scope5.strategy = strategy;
  scope5.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope5;
}, "scopeUnsafeMake");
var scopeMake = /* @__PURE__ */ __name((strategy = sequential2) => sync(() => scopeUnsafeMake(strategy)), "scopeMake");
var scopeExtend = /* @__PURE__ */ dual(2, (effect, scope5) => mapInputContext(
  effect,
  // @ts-expect-error
  merge3(make5(scopeTag, scope5))
));
var scopeUse = /* @__PURE__ */ dual(2, (effect, scope5) => pipe(effect, scopeExtend(scope5), onExit((exit7) => scope5.close(exit7))));
var fiberRefUnsafeMakeSupervisor = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty25
}), "fiberRefUnsafeMakeSupervisor");
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self, value) => asVoid(acquireRelease(flatMap7(fiberRefGet(self), (oldValue) => as(fiberRefSet(self, value), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self, f) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f(a))));
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = /* @__PURE__ */ __name((fibers) => forEach7(fibers, _await2), "fiberAwaitAll");
var fiberAll = /* @__PURE__ */ __name((fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join2(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: /* @__PURE__ */ __name(() => fromIterable(fibers).reduce((id, fiber) => combine3(id, fiber.id()), none4), "id"),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten4(fiber.await), false)),
    children: map8(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map8(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: /* @__PURE__ */ __name((a, chunk3) => [a, ...chunk3], "onSuccess"),
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: /* @__PURE__ */ __name((fiberId5) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId5)), "interruptAsFork")
  };
  return _fiberAll;
}, "fiberAll");
var raceWith = /* @__PURE__ */ dual(3, (self, other, options) => raceFibersWith(self, other, {
  onSelfWin: /* @__PURE__ */ __name((winner, loser) => flatMap7(winner.await, (exit7) => {
    switch (exit7._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options.onSelfDone(exit7, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit7, loser);
      }
    }
  }), "onSelfWin"),
  onOtherWin: /* @__PURE__ */ __name((winner, loser) => flatMap7(winner.await, (exit7) => {
    switch (exit7._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options.onOtherDone(exit7, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit7, loser);
      }
    }
  }), "onOtherWin")
}));
var disconnect = /* @__PURE__ */ __name((self) => uninterruptibleMask((restore) => fiberIdWith((fiberId5) => flatMap7(forkDaemon(restore(self)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId5))))))), "disconnect");
var race = /* @__PURE__ */ dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: /* @__PURE__ */ __name((exit7, right5) => exitMatchEffect(exit7, {
    onFailure: /* @__PURE__ */ __name((cause5) => pipe(join2(right5), mapErrorCause((cause22) => parallel(cause5, cause22))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value) => pipe(right5, interruptAsFiber(parentFiberId), as(value)), "onSuccess")
  }), "onSelfDone"),
  onOtherDone: /* @__PURE__ */ __name((exit7, left5) => exitMatchEffect(exit7, {
    onFailure: /* @__PURE__ */ __name((cause5) => pipe(join2(left5), mapErrorCause((cause22) => parallel(cause22, cause5))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value) => pipe(left5, interruptAsFiber(parentFiberId), as(value)), "onSuccess")
  }), "onOtherDone")
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make11(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = /* @__PURE__ */ __name((winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
}, "completeRace");
var ensuring = /* @__PURE__ */ dual(2, (self, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: /* @__PURE__ */ __name((cause1) => matchCauseEffect(finalizer, {
    onFailure: /* @__PURE__ */ __name((cause22) => failCause(sequential(cause1, cause22)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => failCause(cause1), "onSuccess")
  }), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => as(finalizer, a), "onSuccess")
})));
var invokeWithInterrupt = /* @__PURE__ */ __name((self, entries3, onInterrupt5) => fiberIdWith((id) => flatMap7(flatMap7(forkDaemon(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries3.map((_) => _.listeners.count);
  const checkDone = /* @__PURE__ */ __name(() => {
    if (counts.every((count) => count === 0)) {
      if (entries3.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt5?.();
        cb(interruptFiber(processing));
      }
    }
  }, "checkDone");
  processing.addObserver((exit7) => {
    cleanup.forEach((f) => f());
    cb(exit7);
  });
  const cleanup = entries3.map((r, i) => {
    const observer = /* @__PURE__ */ __name((count) => {
      counts[i] = count;
      checkDone();
    }, "observer");
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries3.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id)));
}))), "invokeWithInterrupt");
var makeSpanScoped = /* @__PURE__ */ __name((name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope5 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
    const span3 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
    return as(scopeAddFinalizerExit(scope5, (exit7) => endSpan(span3, exit7, clock_, timingEnabled)), span3);
  }));
}, "makeSpanScoped");
var withTracerScoped = /* @__PURE__ */ __name((value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value)), "withTracerScoped");
var withSpanScoped = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return flatMap7(makeSpanScoped(name, addSpanStackTrace(options)), (span3) => provideService(self, spanTag, span3));
  }
  return (self) => flatMap7(makeSpanScoped(name, addSpanStackTrace(options)), (span3) => provideService(self, spanTag, span3));
}, "withSpanScoped");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/cache.js
var complete2 = /* @__PURE__ */ __name((key, exit7, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit7,
  entryStats,
  timeToLiveMillis
}), "complete");
var pending2 = /* @__PURE__ */ __name((key, deferred) => struct({
  _tag: "Pending",
  key,
  deferred
}), "pending");
var refreshing = /* @__PURE__ */ __name((deferred, complete5) => struct({
  _tag: "Refreshing",
  deferred,
  complete: complete5
}), "refreshing");
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
var MapKeyImpl = class {
  static {
    __name(this, "MapKeyImpl");
  }
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = void 0;
  next = void 0;
  constructor(current) {
    this.current = current;
  }
  [symbol]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
var makeMapKey = /* @__PURE__ */ __name((current) => new MapKeyImpl(current), "makeMapKey");
var isMapKey = /* @__PURE__ */ __name((u) => hasProperty(u, MapKeyTypeId), "isMapKey");
var KeySetImpl = class {
  static {
    __name(this, "KeySetImpl");
  }
  head = void 0;
  tail = void 0;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous = key.previous;
        const next = key.next;
        if (next !== void 0) {
          key.next = void 0;
          if (previous !== void 0) {
            previous.next = next;
            next.previous = previous;
          } else {
            this.head = next;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next = key.next;
      if (next !== void 0) {
        key.next = void 0;
        this.head = next;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet = /* @__PURE__ */ __name(() => new KeySetImpl(), "makeKeySet");
var makeCacheState = /* @__PURE__ */ __name((map23, keys9, accesses, updating, hits, misses) => ({
  map: map23,
  keys: keys9,
  accesses,
  updating,
  hits,
  misses
}), "makeCacheState");
var initialCacheState = /* @__PURE__ */ __name(() => makeCacheState(empty17(), makeKeySet(), unbounded(), make11(false), 0, 0), "initialCacheState");
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Error: /* @__PURE__ */ __name((_) => _, "_Error"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Error: /* @__PURE__ */ __name((_) => _, "_Error"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var makeCacheStats = /* @__PURE__ */ __name((options) => options, "makeCacheStats");
var makeEntryStats = /* @__PURE__ */ __name((loadedMillis) => ({
  loadedMillis
}), "makeEntryStats");
var CacheImpl = class {
  static {
    __name(this, "CacheImpl");
  }
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity, context7, fiberId5, lookup, timeToLive) {
    this.capacity = capacity;
    this.context = context7;
    this.fiberId = fiberId5;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map8(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size4(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get8(this.cacheState.map, key), {
      onNone: /* @__PURE__ */ __name(() => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      }, "onNone"),
      onSome: /* @__PURE__ */ __name((value) => this.resolveMapValue(value), "onSome")
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get8(this.cacheState.map, key), {
      onNone: /* @__PURE__ */ __name(() => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      }, "onNone"),
      onSome: /* @__PURE__ */ __name((value) => this.resolveMapValue(value, true), "onSome")
    }));
  }
  contains(key) {
    return sync(() => has4(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option5 = get8(this.cacheState.map, key);
      if (isSome2(option5)) {
        switch (option5.value._tag) {
          case "Complete": {
            const loaded = option5.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option5.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value = getOrUndefined(get8(this.cacheState.map, k));
      if (value === void 0) {
        deferred = unsafeMake3(this.fiberId);
        mapKey = makeMapKey(k);
        if (has4(this.cacheState.map, k)) {
          value = getOrUndefined(get8(this.cacheState.map, k));
        } else {
          set4(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map8(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap7(this.resolveMapValue(value), match2({
          onNone: /* @__PURE__ */ __name(() => this.getEither(key), "onNone"),
          onSome: /* @__PURE__ */ __name((value2) => succeed(left2(value2)), "onSome")
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove5(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when5) {
    return sync(() => {
      const value = get8(this.cacheState.map, key);
      if (isSome2(value) && value.value._tag === "Complete") {
        if (value.value.exit._tag === "Success") {
          if (when5(value.value.exit.value)) {
            remove5(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty17();
    });
  }
  refresh(key) {
    return clockWith3((clock5) => suspend(() => {
      const k = key;
      const deferred = unsafeMake3(this.fiberId);
      let value = getOrUndefined(get8(this.cacheState.map, k));
      if (value === void 0) {
        if (has4(this.cacheState.map, k)) {
          value = getOrUndefined(get8(this.cacheState.map, k));
        } else {
          set4(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value === void 0) {
        return asVoid(this.lookupValueOf(key, deferred));
      } else {
        switch (value._tag) {
          case "Complete": {
            if (this.hasExpired(clock5, value.timeToLiveMillis)) {
              const found = getOrUndefined(get8(this.cacheState.map, k));
              if (equals(found, value)) {
                remove5(this.cacheState.map, k);
              }
              return asVoid(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current = getOrUndefined(get8(this.cacheState.map, k));
              if (equals(current, value)) {
                const mapValue = refreshing(deferred, value);
                set4(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid);
          }
          case "Pending": {
            return _await(value.deferred);
          }
          case "Refreshing": {
            return _await(value.deferred);
          }
        }
      }
    }));
  }
  set(key, value) {
    return clockWith3((clock5) => sync(() => {
      const now = clock5.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed2(value);
      const mapValue = complete2(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
      set4(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size4(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values5.push(entry[1].exit.value);
        }
      }
      return values5;
    });
  }
  get entries() {
    return sync(() => {
      const values5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values5.push([entry[0], entry[1].exit.value]);
        }
      }
      return values5;
    });
  }
  get keys() {
    return sync(() => {
      const keys9 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys9.push(entry[0]);
        }
      }
      return keys9;
    });
  }
  resolveMapValue(value, ignorePending = false) {
    return clockWith3((clock5) => {
      switch (value._tag) {
        case "Complete": {
          this.trackAccess(value.key);
          if (this.hasExpired(clock5, value.timeToLiveMillis)) {
            remove5(this.cacheState.map, value.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map8(value.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map8(_await(value.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value.complete.key);
          this.trackHit();
          if (this.hasExpired(clock5, value.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map8(_await(value.deferred), some2);
          }
          return map8(value.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size17 = size4(this.cacheState.map);
      loop5 = size17 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has4(this.cacheState.map, key2.current)) {
            remove5(this.cacheState.map, key2.current);
            size17 = size17 - 1;
            loop5 = size17 > this.capacity;
          }
        } else {
          loop5 = false;
        }
      }
      set2(this.cacheState.updating, false);
    }
  }
  hasExpired(clock5, timeToLiveMillis) {
    return clock5.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock5) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap7((exit7) => {
        const now = clock5.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now);
        const value = complete2(makeMapKey(key), exit7, stats, now + toMillis(decode(this.timeToLive(exit7))));
        set4(this.cacheState.map, key, value);
        return zipRight(done2(deferred, exit7), exit7);
      }), onInterrupt(() => zipRight(interrupt3(deferred), sync(() => {
        remove5(this.cacheState.map, key);
      }))));
    }));
  }
};
var unsafeMakeWith = /* @__PURE__ */ __name((capacity, lookup, timeToLive) => new CacheImpl(capacity, empty3(), none3, lookup, (exit7) => decode(timeToLive(exit7))), "unsafeMakeWith");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do2,
  EffectTypeId: () => EffectTypeId3,
  Service: () => Service,
  Tag: () => Tag2,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer2,
  all: () => all3,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen3,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs2,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans2,
  ap: () => ap,
  as: () => as3,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid3,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind3,
  bindAll: () => bindAll2,
  bindTo: () => bindTo3,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll2,
  catchAllCause: () => catchAllCause2,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context3,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die3,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync2,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect2,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile2,
  either: () => either3,
  ensureErrorType: () => ensureErrorType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureSuccessType: () => ensureSuccessType,
  ensuring: () => ensuring2,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every5,
  exists: () => exists2,
  exit: () => exit3,
  fail: () => fail4,
  failCause: () => failCause4,
  failCauseSync: () => failCauseSync2,
  failSync: () => failSync2,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter5,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap4,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst5,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap9,
  flatten: () => flatten6,
  flip: () => flip2,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach8,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable3,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen2,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head4,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt4,
  interruptWith: () => interruptWith2,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure2,
  isSuccess: () => isSuccess2,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_3,
  liftPredicate: () => liftPredicate2,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log2,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map11,
  mapAccum: () => mapAccum3,
  mapBoth: () => mapBoth2,
  mapError: () => mapError2,
  mapErrorCause: () => mapErrorCause2,
  mapInputContext: () => mapInputContext2,
  match: () => match9,
  matchCause: () => matchCause3,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect2,
  merge: () => merge6,
  mergeAll: () => mergeAll5,
  metricLabels: () => metricLabels2,
  negate: () => negate2,
  never: () => never2,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt2,
  once: () => once3,
  option: () => option2,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie2,
  orDieWith: () => orDieWith2,
  orElse: () => orElse2,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition4,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService2,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith2,
  reduce: () => reduce10,
  reduceEffect: () => reduceEffect2,
  reduceRight: () => reduceRight3,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate2,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime3,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope2,
  scopeWith: () => scopeWith2,
  scoped: () => scoped2,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed6,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync4,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile2,
  tap: () => tap2,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect2,
  tapError: () => tapError2,
  tapErrorCause: () => tapErrorCause2,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption2,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_2,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs2,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan2,
  withRandom: () => withRandom2,
  withRandomFixed: () => withRandomFixed,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan2,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip4,
  zipLeft: () => zipLeft2,
  zipRight: () => zipRight2,
  zipWith: () => zipWith3
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty26 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make34 = /* @__PURE__ */ __name((startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty26;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
}, "make");
var lessThan2 = /* @__PURE__ */ dual(2, (self, that) => min2(self, that) === self);
var min2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
var isEmpty7 = /* @__PURE__ */ __name((self) => {
  return self.startMillis >= self.endMillis;
}, "isEmpty");
var intersect = /* @__PURE__ */ dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end5 = Math.min(self.endMillis, that.endMillis);
  return make34(start5, end5);
});
var after = /* @__PURE__ */ __name((startMilliseconds) => {
  return make34(startMilliseconds, Number.POSITIVE_INFINITY);
}, "after");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/ScheduleInterval.js
var empty27 = empty26;
var lessThan3 = lessThan2;
var isEmpty8 = isEmpty7;
var intersect2 = intersect;
var after2 = after;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make36 = /* @__PURE__ */ __name((intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
}, "make");
var intersect3 = /* @__PURE__ */ dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty4()));
var intersectLoop = /* @__PURE__ */ __name((_left, _right, _acc) => {
  let left5 = _left;
  let right5 = _right;
  let acc = _acc;
  while (isNonEmpty(left5) && isNonEmpty(right5)) {
    const interval = pipe(headNonEmpty2(left5), intersect2(headNonEmpty2(right5)));
    const intervals = isEmpty8(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left5), lessThan3(headNonEmpty2(right5)))) {
      left5 = tailNonEmpty2(left5);
    } else {
      right5 = tailNonEmpty2(right5);
    }
    acc = intervals;
  }
  return make36(reverse2(acc));
}, "intersectLoop");
var start = /* @__PURE__ */ __name((self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty27)).startMillis;
}, "start");
var end = /* @__PURE__ */ __name((self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty27)).endMillis;
}, "end");
var lessThan4 = /* @__PURE__ */ dual(2, (self, that) => start(self) < start(that));
var isNonEmpty3 = /* @__PURE__ */ __name((self) => {
  return isNonEmpty(self.intervals);
}, "isNonEmpty");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/ScheduleIntervals.js
var make37 = make36;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan5 = lessThan4;
var isNonEmpty4 = isNonEmpty3;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = /* @__PURE__ */ __name((intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
}, "_continue");
var continueWith = /* @__PURE__ */ __name((interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make37(of2(interval))
  };
}, "continueWith");
var done5 = {
  _tag: OP_DONE2
};
var isContinue = /* @__PURE__ */ __name((self) => {
  return self._tag === OP_CONTINUE;
}, "isContinue");
var isDone3 = /* @__PURE__ */ __name((self) => {
  return self._tag === OP_DONE2;
}, "isDone");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done6 = done5;
var isContinue2 = isContinue;
var isDone4 = isDone3;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Scope.js
var close = scopeClose;
var fork2 = scopeFork;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  static {
    __name(this, "Semaphore");
  }
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = /* @__PURE__ */ __name((n) => asyncInterrupt((resume3) => {
    if (this.free < n) {
      const observer = /* @__PURE__ */ __name(() => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume3(succeed(n));
      }, "observer");
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume3(succeed(n));
  }), "take");
  updateTakenUnsafe(fiber, f) {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  }
  updateTaken(f) {
    return withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f));
  }
  resize = /* @__PURE__ */ __name((permits) => asVoid(withFiberRuntime((fiber) => {
    this.permits = permits;
    if (this.free < 0) {
      return void_;
    }
    return this.updateTakenUnsafe(fiber, (taken) => taken);
  })), "resize");
  release = /* @__PURE__ */ __name((n) => this.updateTaken((taken) => taken - n), "release");
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = /* @__PURE__ */ __name((n) => (self) => uninterruptibleMask((restore) => flatMap7(restore(this.take(n)), (permits) => ensuring(restore(self), this.release(permits)))), "withPermits");
  withPermitsIfAvailable = /* @__PURE__ */ __name((n) => (self) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self)), this.release(n));
  })), "withPermitsIfAvailable");
};
var unsafeMakeSemaphore = /* @__PURE__ */ __name((permits) => new Semaphore(permits), "unsafeMakeSemaphore");
var makeSemaphore = /* @__PURE__ */ __name((permits) => sync(() => unsafeMakeSemaphore(permits)), "makeSemaphore");
var Latch = class extends Class2 {
  static {
    __name(this, "Latch");
  }
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_;
  }
  flushWaiters = /* @__PURE__ */ __name(() => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0; i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  }, "flushWaiters");
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume3) => {
    if (this.isOpen) {
      return resume3(void_);
    }
    this.waiters.push(resume3);
    return sync(() => {
      const index = this.waiters.indexOf(resume3);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = /* @__PURE__ */ __name((self) => {
    return zipRight(this.await, self);
  }, "whenOpen");
};
var unsafeMakeLatch = /* @__PURE__ */ __name((open) => new Latch(open ?? false), "unsafeMakeLatch");
var makeLatch = /* @__PURE__ */ __name((open) => sync(() => unsafeMakeLatch(open)), "makeLatch");
var awaitAllChildren = /* @__PURE__ */ __name((self) => ensuringChildren(self, fiberAwaitAll), "awaitAllChildren");
var cached2 = /* @__PURE__ */ dual(2, (self, timeToLive) => map8(cachedInvalidateWithTTL(self, timeToLive), (tuple2) => tuple2[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self, timeToLive) => {
  const duration = decode(timeToLive);
  return flatMap7(context(), (env) => map8(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self, duration, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = /* @__PURE__ */ __name((self, timeToLive, start5) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap((deferred) => intoDeferred(self, deferred)), map8((deferred) => some2([start5 + timeToLiveMillis, deferred])));
}, "computeCachedValue");
var getCachedValue = /* @__PURE__ */ __name((self, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock5) => clock5.currentTimeMillis), flatMap7((time) => updateSomeAndGetEffectSynchronized(cache, (option5) => {
  switch (option5._tag) {
    case "None": {
      return some2(computeCachedValue(self, timeToLive, time));
    }
    case "Some": {
      const [end5] = option5.value;
      return end5 - time <= 0 ? some2(computeCachedValue(self, timeToLive, time)) : none2();
    }
  }
})), flatMap7((option5) => isNone2(option5) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option5.value[1]))))), "getCachedValue");
var invalidateCache = /* @__PURE__ */ __name((cache) => set5(cache, none2()), "invalidateCache");
var ensuringChild = /* @__PURE__ */ dual(2, (self, f) => ensuringChildren(self, (children) => f(fiberAll(children))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self, children) => flatMap7(track, (supervisor) => pipe(supervised(self, supervisor), ensuring(flatMap7(supervisor.value, children)))));
var forkAll = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map8(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self, scope5) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope5;
  const fiber = unsafeFork2(self, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer = /* @__PURE__ */ __name(() => fiberIdWith((fiberId5) => equals(fiberId5, fiber.id()) ? void_ : asVoid(interruptFiber(fiber))), "finalizer");
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = /* @__PURE__ */ __name((self) => scopeWith((scope5) => forkIn(self, scope5)), "forkScoped");
var fromFiber = /* @__PURE__ */ __name((fiber) => join2(fiber), "fromFiber");
var fromFiberEffect = /* @__PURE__ */ __name((fiber) => suspend(() => flatMap7(fiber, join2)), "fromFiberEffect");
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
  static {
    __name(this, "Key");
  }
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var cachedFunction = /* @__PURE__ */ __name((f, eq) => {
  return pipe(sync(() => empty17()), flatMap7(makeSynchronized), map8((ref) => (a) => pipe(ref.modifyEffect((map23) => {
    const result = pipe(map23, get8(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map8((deferred) => [deferred, pipe(map23, set4(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map23]);
  }), flatMap7(deferredAwait), flatMap7(([patch17, b]) => pipe(patchFiberRefs(patch17), as(b))))));
}, "cachedFunction");
var raceFirst = /* @__PURE__ */ dual(2, (self, that) => pipe(exit(self), race(exit(that)), (effect) => flatten4(effect)));
var supervised = /* @__PURE__ */ dual(2, (self, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self);
});
var timeout = /* @__PURE__ */ dual(2, (self, duration) => timeoutFail(self, {
  onTimeout: /* @__PURE__ */ __name(() => timeoutExceptionFromDuration(duration), "onTimeout"),
  duration
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self, {
  duration,
  onTimeout
}) => flatten4(timeoutTo(self, {
  onTimeout: /* @__PURE__ */ __name(() => failSync(onTimeout), "onTimeout"),
  onSuccess: succeed,
  duration
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self, {
  duration,
  onTimeout
}) => flatten4(timeoutTo(self, {
  onTimeout: /* @__PURE__ */ __name(() => failCauseSync(onTimeout), "onTimeout"),
  onSuccess: succeed,
  duration
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self, duration) => timeoutTo(self, {
  duration,
  onSuccess: some2,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self, {
  duration,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration)), {
  onSelfWin: /* @__PURE__ */ __name((winner, loser) => flatMap7(winner.await, (exit7) => {
    if (exit7._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit7.value)));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit7.cause));
    }
  }), "onSelfWin"),
  onOtherWin: /* @__PURE__ */ __name((winner, loser) => flatMap7(winner.await, (exit7) => {
    if (exit7._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit7.cause));
    }
  }), "onOtherWin"),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var SynchronizedImpl = class extends Class2 {
  static {
    __name(this, "SynchronizedImpl");
  }
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId12] = TypeId12;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get11(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap7(get11(this.ref), f), flatMap7(([b, a]) => as(set5(this.ref, a), b))));
  }
};
var makeSynchronized = /* @__PURE__ */ __name((value) => sync(() => unsafeMakeSynchronized(value)), "makeSynchronized");
var unsafeMakeSynchronized = /* @__PURE__ */ __name((value) => {
  const ref = unsafeMake5(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
}, "unsafeMakeSynchronized");
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self, pf) => self.modifyEffect((value) => {
  const result = pf(value);
  switch (result._tag) {
    case "None": {
      return succeed([value, value]);
    }
    case "Some": {
      return map8(result.value, (a) => [a, a]);
    }
  }
}));
var bindAll = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (self, f, options) => flatMap7(self, (a) => all2(f(a), options).pipe(map8((record) => Object.assign({}, a, record)))));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_MERGE_ALL = "MergeAll";

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Fiber.js
var interruptAs = interruptAsFiber;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = /* @__PURE__ */ __name((f) => function() {
  if (arguments.length === 1) {
    const runtime7 = arguments[0];
    return (effect, ...args3) => f(runtime7, effect, ...args3);
  }
  return f.apply(this, arguments);
}, "makeDual");
var unsafeFork3 = /* @__PURE__ */ makeDual((runtime7, self, options) => {
  const fiberId5 = unsafeMake2();
  const fiberRefUpdates = [[currentContext, [[fiberId5, runtime7.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId5, options.scheduler]]]);
  }
  let fiberRefs5 = updateManyAs2(runtime7.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId5
  });
  if (options?.updateRefs) {
    fiberRefs5 = options.updateRefs(fiberRefs5, fiberId5);
  }
  const fiberRuntime = new FiberRuntime(fiberId5, fiberRefs5, runtime7.runtimeFlags);
  let effect = self;
  if (options?.scope) {
    effect = flatMap7(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id) => equals(id, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id))), onExit(self, (exit7) => close(closeableScope, exit7))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime7.context, effect, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit7) => supervisor.onEnd(exit7, fiberRuntime));
  }
  globalScope.add(runtime7.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime7, effect, options = {}) => {
  const fiberRuntime = unsafeFork3(runtime7, effect, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit7) => {
      options.onExit(exit7);
    });
  }
  return (id, cancelOptions) => unsafeRunCallback(runtime7)(pipe(fiberRuntime, interruptAs(id ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit7) => cancelOptions.onExit(flatten5(exit7)) : void 0
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime7, effect) => {
  const result = unsafeRunSyncExit(runtime7)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  static {
    __name(this, "AsyncFiberExceptionImpl");
  }
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = /* @__PURE__ */ __name((fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
}, "asyncFiberException");
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
  static {
    __name(this, "FiberFailureImpl");
  }
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause5) {
    const head9 = prettyErrors(cause5)[0];
    super(head9?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause5;
    this.name = head9 ? `(FiberFailure) ${head9.name}` : "FiberFailure";
    if (head9?.stack) {
      this.stack = head9.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var fiberFailure = /* @__PURE__ */ __name((cause5) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause5);
  Error.stackTraceLimit = limit;
  return error;
}, "fiberFailure");
var fastPath = /* @__PURE__ */ __name((effect) => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(new NoSuchElementException());
    }
  }
}, "fastPath");
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime7, effect) => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime7)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime7, effect, options) => unsafeRunPromiseExit(runtime7, effect, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime7, effect, options) => new Promise((resolve) => {
  const op = fastPath(effect);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork3(runtime7)(effect);
  fiber.addObserver((exit7) => {
    resolve(exit7);
  });
  if (options?.signal !== void 0) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  static {
    __name(this, "RuntimeImpl");
  }
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context7, runtimeFlags3, fiberRefs5) {
    this.context = context7;
    this.runtimeFlags = runtimeFlags3;
    this.fiberRefs = fiberRefs5;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make38 = /* @__PURE__ */ __name((options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs), "make");
var runtime2 = /* @__PURE__ */ __name(() => withFiberRuntime((state, status) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status.runtimeFlags, state.getFiberRefs()))), "runtime");
var defaultRuntimeFlags = /* @__PURE__ */ make16(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make38({
  context: /* @__PURE__ */ empty3(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty21()
});
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork3(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = /* @__PURE__ */ __name((register) => suspend(() => {
  let cleanup = void 0;
  return flatMap7(deferredMake(), (deferred) => flatMap7(runtime2(), (runtime7) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime7)(intoDeferred(cb, deferred))), {
    onFailure: /* @__PURE__ */ __name((cause5) => deferredFailCause(deferred, cause5), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((cleanup_) => {
      cleanup = cleanup_;
      return void_;
    }, "onSuccess")
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_))))));
}), "asyncEffect");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: /* @__PURE__ */ __name((_) => _, "_RIn"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _ROut: /* @__PURE__ */ __name((_) => _, "_ROut")
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: /* @__PURE__ */ __name(() => unsafeMakeMemoMap(), "defaultValue")
});
var isLayer = /* @__PURE__ */ __name((u) => hasProperty(u, LayerTypeId), "isLayer");
var isFresh = /* @__PURE__ */ __name((self) => {
  return self._op_layer === OP_FRESH;
}, "isFresh");
var MemoMapImpl = class {
  static {
    __name(this, "MemoMapImpl");
  }
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer, scope5) {
    return pipe(modifyEffect(this.ref, (map23) => {
      const inMap = map23.get(layer);
      if (inMap !== void 0) {
        const [acquire, release] = inMap;
        const cached7 = pipe(acquire, flatMap7(([patch17, b]) => pipe(patchFiberRefs(patch17), as(b))), onExit(exitMatch({
          onFailure: /* @__PURE__ */ __name(() => void_, "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => scopeAddFinalizerExit(scope5, release), "onSuccess")
        })));
        return succeed([cached7, map23]);
      }
      return pipe(make26(0), flatMap7((observers) => pipe(deferredMake(), flatMap7((deferred) => pipe(make26(() => void_), map8((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap7((innerScope) => pipe(restore(flatMap7(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap7((exit7) => {
          switch (exit7._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit7.effect_instruction_i0), zipRight(scopeClose(innerScope, exit7)), zipRight(failCause(exit7.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set5(finalizerRef, (exit8) => pipe(scopeClose(innerScope, exit8), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope5, (exit8) => pipe(sync(() => map23.delete(layer)), zipRight(get11(finalizerRef)), flatMap7((finalizer) => finalizer(exit8))))), zipRight(deferredSucceed(deferred, exit7.effect_instruction_i0)), as(exit7.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: /* @__PURE__ */ __name(() => void_, "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => update2(observers, (n) => n + 1), "onSuccess")
        }))), (exit7) => pipe(get11(finalizerRef), flatMap7((finalizer) => finalizer(exit7)))];
        return [resource, isFresh(layer) ? map23 : map23.set(layer, memoized)];
      }))))));
    }), flatten4);
  }
};
var makeMemoMap = /* @__PURE__ */ suspend(() => map8(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = /* @__PURE__ */ __name(() => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map())), "unsafeMakeMemoMap");
var buildWithScope = /* @__PURE__ */ dual(2, (self, scope5) => flatMap7(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope5)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope5) => flatMap7(makeBuilder(self, scope5), (run) => provideService(run(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = /* @__PURE__ */ __name((self, scope5, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect({
        onFailure: /* @__PURE__ */ __name((cause5) => memoMap.getOrElseMemoize(op.failureK(cause5), scope5), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((value) => memoMap.getOrElseMemoize(op.successK(value), scope5), "onSuccess")
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope5)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), flatMap7((env) => pipe(memoMap.getOrElseMemoize(op.second, scope5), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope5)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWith2(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
    }
    case "ZipWith": {
      return gen(function* () {
        const parallelScope = yield* scopeFork(scope5, parallel2);
        const firstScope = yield* scopeFork(parallelScope, sequential2);
        const secondScope = yield* scopeFork(parallelScope, sequential2);
        return (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {
          concurrent: true
        }));
      });
    }
    case "MergeAll": {
      const layers = op.layers;
      return map8(scopeFork(scope5, parallel2), (parallelScope) => (memoMap) => {
        const contexts = new Array(layers.length);
        return map8(forEachConcurrentDiscard(layers, fnUntraced(function* (layer, i) {
          const scope6 = yield* scopeFork(parallelScope, sequential2);
          const context7 = yield* memoMap.getOrElseMemoize(layer, scope6);
          contexts[i] = context7;
        }), false, false), () => mergeAll2(...contexts));
      });
    }
  }
}, "makeBuilder");
var context2 = /* @__PURE__ */ __name(() => fromEffectContext(context()), "context");
var fromEffect2 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return fromEffectContext(map8(effect, (service) => make5(tag, service)));
});
function fromEffectContext(effect) {
  const fromEffect5 = Object.create(proto3);
  fromEffect5._op_layer = OP_FROM_EFFECT;
  fromEffect5.effect = effect;
  return fromEffect5;
}
__name(fromEffectContext, "fromEffectContext");
var mergeAll4 = /* @__PURE__ */ __name((...layers) => {
  const mergeAll11 = Object.create(proto3);
  mergeAll11._op_layer = OP_MERGE_ALL;
  mergeAll11.layers = layers;
  return mergeAll11;
}, "mergeAll");
var scoped = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return scopedContext(map8(effect, (service) => make5(tag, service)));
});
var scopedContext = /* @__PURE__ */ __name((effect) => {
  const scoped5 = Object.create(proto3);
  scoped5._op_layer = OP_SCOPED;
  scoped5.effect = effect;
  return scoped5;
}, "scopedContext");
var succeed4 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make5(tag, resource)));
});
var suspend3 = /* @__PURE__ */ __name((evaluate3) => {
  const suspend9 = Object.create(proto3);
  suspend9._op_layer = OP_SUSPEND;
  suspend9.evaluate = evaluate3;
  return suspend9;
}, "suspend");
var sync3 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const evaluate3 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make5(tag, evaluate3())));
});
var provide = /* @__PURE__ */ dual(2, (self, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll4(...that) : that
    },
    zipK: {
      value: /* @__PURE__ */ __name((a, b) => pipe(a, merge3(b)), "value")
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer) => scopedWith((scope5) => flatMap7(buildWithScope(layer, scope5), (context7) => provideSomeContext(self, context7))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
  const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch4(patchFlags)(oldFlags);
    const rollbackRefs = diff6(newRefs, oldRefs);
    const rollbackFlags = diff4(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self, mergeAll4(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self, source);
  } else if (TypeId15 in source) {
    return flatMap7(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
  } else {
    return provideSomeRuntime(self, source);
  }
});

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map8(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
var consoleWith = /* @__PURE__ */ __name((f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag))), "consoleWith");
var withConsole = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add2(consoleTag, value)));
var withConsoleScoped = /* @__PURE__ */ __name((console6) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console6)), "withConsoleScoped");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Data.js
var Data_exports = {};
__export(Data_exports, {
  Class: () => Class3,
  Error: () => Error3,
  Structural: () => Structural2,
  TaggedClass: () => TaggedClass,
  TaggedError: () => TaggedError,
  array: () => array3,
  case: () => _case,
  struct: () => struct2,
  tagged: () => tagged2,
  taggedEnum: () => taggedEnum,
  tuple: () => tuple,
  unsafeArray: () => unsafeArray,
  unsafeStruct: () => unsafeStruct
});
var struct2 = struct;
var unsafeStruct = /* @__PURE__ */ __name((as7) => Object.setPrototypeOf(as7, StructuralPrototype), "unsafeStruct");
var tuple = /* @__PURE__ */ __name((...as7) => unsafeArray(as7), "tuple");
var array3 = /* @__PURE__ */ __name((as7) => unsafeArray(as7.slice(0)), "array");
var unsafeArray = /* @__PURE__ */ __name((as7) => Object.setPrototypeOf(as7, ArrayProto), "unsafeArray");
var _case = /* @__PURE__ */ __name(() => (args3) => args3 === void 0 ? Object.create(StructuralPrototype) : struct2(args3), "_case");
var tagged2 = /* @__PURE__ */ __name((tag) => (args3) => {
  const value = args3 === void 0 ? Object.create(StructuralPrototype) : struct2(args3);
  value._tag = tag;
  return value;
}, "tagged");
var Class3 = Structural;
var TaggedClass = /* @__PURE__ */ __name((tag) => {
  class Base5 extends Class3 {
    static {
      __name(this, "Base");
    }
    _tag = tag;
  }
  return Base5;
}, "TaggedClass");
var Structural2 = Structural;
var taggedEnum = /* @__PURE__ */ __name(() => new Proxy({}, {
  get(_target, tag, _receiver) {
    if (tag === "$is") {
      return isTagged;
    } else if (tag === "$match") {
      return taggedMatch;
    }
    return tagged2(tag);
  }
}), "taggedEnum");
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value2) {
      return cases2[value2._tag](value2);
    };
  }
  const value = arguments[0];
  const cases = arguments[1];
  return cases[value._tag](value);
}
__name(taggedMatch, "taggedMatch");
var Error3 = /* @__PURE__ */ (function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      static {
        __name(this, "BaseEffectError");
      }
      constructor(args3) {
        super(args3?.message, args3?.cause ? {
          cause: args3.cause
        } : void 0);
        if (args3) {
          Object.assign(this, args3);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args3,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
})();
var TaggedError = /* @__PURE__ */ __name((tag) => {
  const O = {
    BaseEffectError: class extends Error3 {
      static {
        __name(this, "BaseEffectError");
      }
      _tag = tag;
    }
  };
  O.BaseEffectError.prototype.name = tag;
  return O.BaseEffectError;
}, "TaggedError");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Random.js
var fixed2 = fixed;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = /* @__PURE__ */ __name((u) => hasProperty(u, ScheduleTypeId), "isSchedule");
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: void 0,
  output: void 0,
  elapsed: zero,
  elapsedSincePrevious: zero,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: /* @__PURE__ */ __name(() => defaultIterationMetadata, "defaultValue")
});
var scheduleVariance = {
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var ScheduleImpl = class {
  static {
    __name(this, "ScheduleImpl");
  }
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step7) {
    this.initial = initial;
    this.step = step7;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var updateInfo = /* @__PURE__ */ __name((iterationMetaRef, now, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero,
  elapsedSincePrevious: zero,
  start: now
} : {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now - prev.start),
  elapsedSincePrevious: millis(now - prev.now),
  start: prev.start
}), "updateInfo");
var ScheduleDriverImpl = class {
  static {
    __name(this, "ScheduleDriverImpl");
  }
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule3, ref) {
    this.schedule = schedule3;
    this.ref = ref;
  }
  get state() {
    return map8(get11(this.ref), (tuple2) => tuple2[1]);
  }
  get last() {
    return flatMap7(get11(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake5(defaultIterationMetadata);
  get reset() {
    return set5(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set5(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map8(get11(this.ref), (tuple2) => tuple2[1]), flatMap7((state) => pipe(currentTimeMillis2, flatMap7((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap7(([state2, out, decision]) => {
      const setState = set5(this.ref, [some2(out), state2]);
      if (isDone4(decision)) {
        return setState.pipe(zipRight(fail2(none2())));
      }
      const millis3 = start2(decision.intervals) - now;
      if (millis3 <= 0) {
        return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input, out)), as(out));
      }
      const duration = millis(millis3);
      return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input, out)), zipRight(sleep3(duration)), as(out));
    }))))));
  }
};
var makeWithState = /* @__PURE__ */ __name((initial, step7) => new ScheduleImpl(initial, step7), "makeWithState");
var asVoid2 = /* @__PURE__ */ __name((self) => map10(self, constVoid), "asVoid");
var check = /* @__PURE__ */ dual(2, (self, test) => checkEffect(self, (input, out) => sync(() => test(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out, decision]) => {
  if (isDone4(decision)) {
    return succeed([state2, out, done6]);
  }
  return map8(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
})));
var driver = /* @__PURE__ */ __name((self) => pipe(make26([none2(), self.initial]), map8((ref) => new ScheduleDriverImpl(self, ref))), "driver");
var intersect5 = /* @__PURE__ */ dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith2(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap7(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done6]);
}))));
var intersectWithLoop = /* @__PURE__ */ __name((self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan5(rInterval))) {
    return flatMap7(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone4(decision)) {
        return succeed([[lState2, rState], [out3, out2], done6]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap7(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone4(decision)) {
      return succeed([[lState, rState2], [out, out22], done6]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
}, "intersectWithLoop");
var map10 = /* @__PURE__ */ dual(2, (self, f) => mapEffect(self, (out) => sync(() => f(out))));
var mapEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out, decision]) => map8(f(out), (out2) => [state2, out2, decision]))));
var passthrough = /* @__PURE__ */ __name((self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map8(([state2, _, decision]) => [state2, input, decision]))), "passthrough");
var recurs = /* @__PURE__ */ __name((n) => whileOutput(forever2, (out) => out < n), "recurs");
var unfold2 = /* @__PURE__ */ __name((initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))])), "unfold");
var untilInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => f(out)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
  static {
    __name(this, "ScheduleDefect");
  }
  error;
  [ScheduleDefectTypeId];
  constructor(error) {
    this.error = error;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = /* @__PURE__ */ __name((u) => hasProperty(u, ScheduleDefectTypeId), "isScheduleDefect");
var scheduleDefectWrap = /* @__PURE__ */ __name((self) => catchAll(self, (e) => die2(new ScheduleDefect(e))), "scheduleDefectWrap");
var scheduleDefectRefailCause = /* @__PURE__ */ __name((cause5) => match2(find(cause5, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: /* @__PURE__ */ __name(() => cause5, "onNone"),
  onSome: /* @__PURE__ */ __name((error) => fail(error.error), "onSome")
}), "scheduleDefectRefailCause");
var scheduleDefectRefail = /* @__PURE__ */ __name((effect) => catchAllCause(effect, (cause5) => failCause(scheduleDefectRefailCause(cause5))), "scheduleDefectRefail");
var repeat_Effect = /* @__PURE__ */ dual(2, (self, schedule3) => repeatOrElse_Effect(self, schedule3, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map10((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self, schedule3, orElse5) => flatMap7(driver(schedule3), (driver3) => matchEffect(self, {
  onFailure: /* @__PURE__ */ __name((error) => orElse5(error, none2()), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((value) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (error, option5) => provideServiceEffect(orElse5(error, option5), CurrentIterationMetadata, get11(driver3.iterationMeta)), value), "onSuccess")
})));
var repeatOrElseEffectLoop = /* @__PURE__ */ __name((self, driver3, orElse5, value) => matchEffect(driver3.next(value), {
  onFailure: /* @__PURE__ */ __name(() => orDie(driver3.last), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((b) => matchEffect(self, {
    onFailure: /* @__PURE__ */ __name((error) => orElse5(error, some2(b)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value2) => repeatOrElseEffectLoop(self, driver3, orElse5, value2), "onSuccess")
  }), "onSuccess")
}), "repeatOrElseEffectLoop");
var retry_Effect = /* @__PURE__ */ dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
var fromRetryOptions = /* @__PURE__ */ __name((options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
}, "fromRetryOptions");
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self, policy, orElse5) => flatMap7(driver(policy), (driver3) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect(orElse5(e, out), CurrentIterationMetadata, get11(driver3.iterationMeta)))));
var retryOrElse_EffectLoop = /* @__PURE__ */ __name((self, driver3, orElse5) => {
  return catchAll(self, (e) => matchEffect(driver3.next(e), {
    onFailure: /* @__PURE__ */ __name(() => pipe(driver3.last, orDie, flatMap7((out) => orElse5(e, out))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => retryOrElse_EffectLoop(self, driver3, orElse5), "onSuccess")
  }));
}, "retryOrElse_EffectLoop");
var schedule_Effect = /* @__PURE__ */ dual(2, (self, schedule3) => scheduleFrom_Effect(self, void 0, schedule3));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self, initial, schedule3) => flatMap7(driver(schedule3), (driver3) => scheduleFrom_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver3.iterationMeta)), initial, driver3)));
var scheduleFrom_EffectLoop = /* @__PURE__ */ __name((self, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: /* @__PURE__ */ __name(() => orDie(driver3.last), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => flatMap7(self, (a) => scheduleFrom_EffectLoop(self, a, driver3)), "onSuccess")
}), "scheduleFrom_EffectLoop");
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var once2 = /* @__PURE__ */ asVoid2(/* @__PURE__ */ recurs(1));
var scheduleForked = /* @__PURE__ */ dual(2, (self, schedule3) => forkScoped(schedule_Effect(self, schedule3)));

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/executionPlan.js
var withExecutionPlan = /* @__PURE__ */ dual(2, (effect, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap7(whileLoop({
    while: /* @__PURE__ */ __name(() => i < plan.steps.length && (result === void 0 || isLeft2(result)), "while"),
    body: /* @__PURE__ */ __name(() => {
      const step7 = plan.steps[i];
      let nextEffect = effect_provide(effect, step7.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted) return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step7, false)));
      } else {
        const schedule3 = scheduleFromStep(step7, true);
        nextEffect = schedule3 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule3)) : nextEffect;
      }
      return either2(nextEffect);
    }, "body"),
    step: /* @__PURE__ */ __name((either7) => {
      result = either7;
      i++;
    }, "step")
  }), () => result);
}));
var scheduleFromStep = /* @__PURE__ */ __name((step7, first3) => {
  if (!first3) {
    return fromRetryOptions({
      schedule: step7.schedule ? step7.schedule : step7.attempts ? void 0 : once2,
      times: step7.attempts,
      while: step7.while
    });
  } else if (step7.attempts === 1 || !(step7.schedule || step7.attempts)) {
    return void 0;
  }
  return fromRetryOptions({
    schedule: step7.schedule,
    while: step7.while,
    times: step7.attempts ? step7.attempts - 1 : void 0
  });
}, "scheduleFromStep");

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map8(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = /* @__PURE__ */ __name((request3, dataSource) => flatMap7(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id) => {
  const proxy = new Proxy(request3, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached7 = fiberRefGetWith(currentCache, (cache) => flatMap7(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap7(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached7);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap7(exit(blocked(empty15, restore(deferredAwait(orNew.left.handle)))), (exit7) => {
              orNew.left.listeners.decrement();
              return exit7;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap7(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached7;
    }
    const listeners = new Listeners();
    listeners.increment();
    return flatMap7(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
})), "fromRequest");
var cacheRequest = /* @__PURE__ */ __name((request3, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap7(cache.getEither(request3), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_;
  });
}, "cacheRequest");
var withRequestCaching = /* @__PURE__ */ dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(
  2,
  // @ts-expect-error
  (self, cache) => fiberRefLocally(self, currentCache, cache)
);

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Request.js
var isRequest2 = isRequest;

// ../node_modules/.bun/effect@3.19.13/node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all3 = all2;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile2 = dropWhile;
var takeUntil2 = takeUntil;
var takeWhile2 = takeWhile;
var every5 = every4;
var exists2 = exists;
var filter5 = filter4;
var filterMap4 = filterMap3;
var findFirst5 = findFirst3;
var forEach8 = forEach7;
var head4 = head3;
var mergeAll5 = mergeAll3;
var partition4 = partition3;
var reduce10 = reduce8;
var reduceWhile2 = reduceWhile;
var reduceRight3 = reduceRight2;
var reduceEffect2 = reduceEffect;
var replicate2 = replicate;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async2 = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail4 = fail2;
var failSync2 = failSync;
var failCause4 = failCause;
var failCauseSync2 = failCauseSync;
var die3 = die2;
var dieMessage2 = dieMessage;
var dieSync2 = dieSync;
var gen2 = gen;
var never2 = never;
var none9 = none6;
var promise2 = promise;
var succeed6 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend4 = suspend;
var sync4 = sync;
var _void = void_;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll2 = catchAll;
var catchAllCause2 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_2 = try_;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt4 = interrupt2;
var interruptWith2 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate2 = liftPredicate;
var as3 = as;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid3 = asVoid;
var flip2 = flip;
var flipWith2 = flipWith;
var map11 = map8;
var mapAccum3 = mapAccum2;
var mapBoth2 = mapBoth;
var mapError2 = mapError;
var mapErrorCause2 = mapErrorCause;
var merge6 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer2 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope2 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext2 = mapInputContext;
var provide2 = effect_provide;
var provideService2 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do2 = Do;
var bind3 = bind2;
var bindAll2 = bindAll;
var bindTo3 = bindTo2;
var let_3 = let_2;
var option2 = option;
var either3 = either2;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap9 = flatMap7;
var andThen3 = andThen2;
var flatten6 = flatten4;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap2 = tap;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError2 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause2 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop3 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs2 = updateFiberRefs;
var isFailure2 = isFailure;
var isSuccess2 = isSuccess;
var match9 = match6;
var matchCause3 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var log2 = log;
var logWithLevel2 = /* @__PURE__ */ __name((level, ...message) => logWithLevel(level)(...message), "logWithLevel");
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs2 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie2 = orDie;
var orDieWith2 = orDieWith;
var orElse2 = orElse;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomFixed = /* @__PURE__ */ dual(2, (effect, values5) => withRandom2(effect, fixed2(values5)));
var withRandomScoped2 = withRandomScoped;
var runtime3 = runtime2;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip4 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight2 = zipRightOptions;
var zipWith3 = zipWithOptions;
var ap = /* @__PURE__ */ dual(2, (self, that) => zipWith3(self, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args3) => isRequest2(args3[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans2 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan2 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan2 = withParentSpan;
var fromNullable3 = fromNullable2;
var optionFromOptional2 = optionFromOptional;
var transposeOption = /* @__PURE__ */ __name((self) => {
  return isNone(self) ? succeedNone2 : map11(self.value, some);
}, "transposeOption");
var transposeMapOption = /* @__PURE__ */ dual(2, (self, f) => isNone(self) ? succeedNone2 : map11(f(self.value), some));
var makeTagProxy = /* @__PURE__ */ __name((TagClass) => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn3 = /* @__PURE__ */ __name((...args3) => andThen2(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args4) => andThen2(target, (s2) => s2[prop](...args4)));
          return s[prop](...args3);
        }
        cache.set(prop, andThen2(target, (s2) => s2[prop]));
        return s[prop];
      }), "fn");
      const cn = andThen2(target, (s) => s[prop]);
      Object.assign(fn3, cn);
      const apply = fn3.apply;
      const bind7 = fn3.bind;
      const call = fn3.call;
      const proto7 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
      proto7.apply = apply;
      proto7.bind = bind7;
      proto7.call = call;
      Object.setPrototypeOf(fn3, proto7);
      cache.set(prop, fn3);
      return fn3;
    }
  });
}, "makeTagProxy");
var Tag2 = /* @__PURE__ */ __name((id) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  __name(TagClass, "TagClass");
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen2(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
}, "Tag");
var Service = /* @__PURE__ */ __name(function() {
  return function() {
    const [id, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = /* @__PURE__ */ __name(function(service) {
      if (patchState === "unchecked") {
        const proto7 = Object.getPrototypeOf(service);
        if (proto7 === Object.prototype || proto7 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto7);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service, Object.getPrototypeOf(this));
        return service;
      }
    }, "TagClass");
    TagClass.prototype._tag = id;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service) => new this(service);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen2(this, body);
      }
    });
    TagClass.key = id;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction5 = false;
    if ("effect" in maker) {
      isFunction5 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction5) {
            return function() {
              return fromEffect2(TagClass, map11(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect2(TagClass, map11(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction5 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction5) {
            return function() {
              return scoped(TagClass, map11(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped(TagClass, map11(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync3(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed4(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction5) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
}, "Service");
var fn = /* @__PURE__ */ __name(function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args3) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args3,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args3) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args3,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
}, "fn");
function defineLength(length3, fn3) {
  return Object.defineProperty(fn3, "length", {
    value: length3,
    configurable: true
  });
}
__name(defineLength, "defineLength");
function fnApply(options) {
  let effect;
  let fnError = void 0;
  if (isGeneratorFunction(options.body)) {
    effect = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect = options.body.apply(options.self, options.args);
    } catch (error) {
      fnError = error;
      effect = die3(error);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect = x(effect, ...options.args);
      }
    } catch (error) {
      effect = fnError ? failCause4(sequential(die(fnError), die(error))) : die3(error);
    }
  }
  let cache = false;
  const captureStackTrace = /* @__PURE__ */ __name(() => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split("\n");
      const stackCall = options.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  }, "captureStackTrace");
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan2(effect, options.spanName, opts);
}
__name(fnApply, "fnApply");
var fnUntraced2 = fnUntraced;
var ensureSuccessType = /* @__PURE__ */ __name(() => (effect) => effect, "ensureSuccessType");
var ensureErrorType = /* @__PURE__ */ __name(() => (effect) => effect, "ensureErrorType");
var ensureRequirementsType = /* @__PURE__ */ __name(() => (effect) => effect, "ensureRequirementsType");

// ../src/index.ts
var HandlerMissing = class extends Data_exports.TaggedError("HandlerMissing") {
  static {
    __name(this, "HandlerMissing");
  }
};
var ReliableScheduler = class {
  static {
    __name(this, "ReliableScheduler");
  }
  storage;
  handlers = /* @__PURE__ */ new Map();
  /**
   * Creates a new scheduler instance with the provided Durable Object storage.
   */
  constructor(storage) {
    this.storage = storage;
  }
  /**
   * Register a named task handler. The handler receives the scheduler, taskId, and params.
   */
  register(taskName, handler) {
    this.handlers.set(taskName, handler);
  }
  /**
   * Get a registered handler by name. Returns undefined if not found.
   */
  getHandler(taskName) {
    return this.handlers.get(taskName);
  }
  /**
   * Schedule a task to run at a future time (Unix timestamp or Date).
   */
  async schedule(at, taskId, taskName, params = {}) {
    return Effect_exports.runPromise(this._schedule(at, taskId, taskName, params));
  }
  _schedule(at, taskId, taskName, params) {
    return Effect_exports.gen(this, function* () {
      if (!this.handlers.has(taskName)) {
        yield* new HandlerMissing({ taskName });
      }
      const scheduledAt = typeof at === "number" ? at : at.getTime();
      const now = Date.now();
      const task = {
        taskId,
        taskName,
        params,
        scheduledAt,
        startedAt: now,
        status: "pending",
        progress: {}
      };
      yield* Effect_exports.promise(
        () => this.storage.transaction(async (txn) => {
          await txn.put(`task:${taskId}`, task);
          await this._rebuildQueueSync(txn);
          await this._updateAlarmSync(txn);
        })
      );
      if (scheduledAt <= Date.now()) {
        yield* Effect_exports.promise(() => this.processTask(taskId));
      }
    });
  }
  /**
   * Start a task immediately with eviction safety. Sets a 30s safety alarm for automatic retry.
   * @param options.maxRetries - Override default retry count (default: 3, use Infinity for infinite loop tasks)
   */
  async runNow(taskId, taskName, params = {}, options) {
    return Effect_exports.runPromise(this._runNow(taskId, taskName, params, options));
  }
  _runNow(taskId, taskName, params, options) {
    return Effect_exports.gen(this, function* () {
      if (!this.handlers.has(taskName)) {
        yield* new HandlerMissing({ taskName });
      }
      const now = Date.now();
      const safetyDelay = 3e4;
      const safetyAt = now + safetyDelay;
      const task = {
        taskId,
        taskName,
        params,
        scheduledAt: now,
        startedAt: now,
        status: "running",
        safetyAlarmAt: safetyAt,
        progress: {},
        maxRetries: options?.maxRetries
      };
      yield* Effect_exports.promise(
        () => this.storage.transaction(async (txn) => {
          await txn.put(`task:${taskId}`, task);
          await this._rebuildQueueSync(txn);
          await this._updateAlarmSync(txn);
          await txn.setAlarm(safetyAt);
        })
      );
      void this.processTask(taskId);
    });
  }
  /**
   * Save progress for a task. Use this to mark completion of expensive operations.
   */
  async checkpoint(taskId, key, value) {
    return Effect_exports.runPromise(this._checkpoint(taskId, key, value));
  }
  _checkpoint(taskId, key, value) {
    return Effect_exports.gen(this, function* () {
      const updated = yield* this._updateTask(taskId, (task) => {
        if (task.status !== "running" && task.status !== "completed" && task.status !== "failed") {
          console.error(`[checkpoint] Task ${taskId} status is ${task.status}, cannot checkpoint`);
          return false;
        }
        if (task.status === "failed") {
          task.status = "running";
          task.retryCount = 0;
          if (task.progress.error) {
            delete task.progress.error;
          }
        }
        task.progress[key] = value;
        return true;
      });
      if (!updated) {
        console.error(`[checkpoint] Failed to update checkpoint ${key} for task ${taskId}`);
      }
    });
  }
  /**
   * Retrieve saved progress for a task. Returns undefined if not found.
   */
  async getCheckpoint(taskId, key) {
    return Effect_exports.runPromise(this._getCheckpoint(taskId, key));
  }
  _getCheckpoint(taskId, key) {
    return Effect_exports.gen(this, function* () {
      const task = yield* Effect_exports.promise(
        () => this.storage.get(`task:${taskId}`)
      );
      return task?.progress[key];
    });
  }
  /**
   * Mark a task as complete and clean up its state.
   */
  async completeTask(taskId) {
    return Effect_exports.runPromise(this._completeTask(taskId));
  }
  _completeTask(taskId) {
    return Effect_exports.gen(this, function* () {
      yield* this._updateTask(taskId, (task) => {
        task.status = "completed";
        task.progress.completed = true;
        return true;
      });
    });
  }
  /**
   * Get a single task by ID. Returns undefined if not found.
   */
  async getTask(taskId) {
    return Effect_exports.runPromise(this._getTask(taskId));
  }
  _getTask(taskId) {
    return Effect_exports.promise(() => this.storage.get(`task:${taskId}`));
  }
  /**
   * Get all tasks, optionally filtered by status.
   */
  async getTasks(status) {
    return Effect_exports.runPromise(this._getTasks(status));
  }
  _getTasks(status) {
    return Effect_exports.gen(this, function* () {
      const list = yield* Effect_exports.promise(
        () => this.storage.list({ prefix: "task:" })
      );
      const tasks = [];
      for (const [, value] of list) {
        const task = value;
        if (!status || task.status === status) {
          tasks.push(task);
        }
      }
      return tasks;
    });
  }
  /**
   * Cancel and delete a task. Returns true if successful, false if task not found.
   */
  async cancelTask(taskId) {
    return Effect_exports.runPromise(this._cancelTask(taskId));
  }
  _cancelTask(taskId) {
    return Effect_exports.gen(this, function* () {
      const task = yield* Effect_exports.promise(
        () => this.storage.get(`task:${taskId}`)
      );
      if (!task) return false;
      yield* Effect_exports.promise(() => this.storage.delete(`task:${taskId}`));
      yield* Effect_exports.promise(
        () => this.storage.transaction(async (txn) => {
          await this._rebuildQueueSync(txn);
          await this._updateAlarmSync(txn);
        })
      );
      return true;
    });
  }
  /**
   * Pause a running task. Returns true if successful, false if task not found or cannot be paused.
   */
  async pauseTask(taskId) {
    return Effect_exports.runPromise(this._pauseTask(taskId));
  }
  _pauseTask(taskId) {
    return Effect_exports.gen(this, function* () {
      const updated = yield* this._updateTask(taskId, (task) => {
        if (task.status === "completed" || task.status === "failed" || task.status === "paused")
          return false;
        task.status = "paused";
        task.pausedAt = Date.now();
        return true;
      });
      if (updated) {
        yield* Effect_exports.promise(
          () => this.storage.transaction(async (txn) => {
            await this._rebuildQueueSync(txn);
            await this._updateAlarmSync(txn);
          })
        );
      }
      return updated;
    });
  }
  /**
   * Resume a paused task. Returns true if successful, false if task not found or not paused.
   */
  async resumeTask(taskId) {
    return Effect_exports.runPromise(this._resumeTask(taskId));
  }
  _resumeTask(taskId) {
    return Effect_exports.gen(this, function* () {
      const updated = yield* this._updateTask(taskId, (task) => {
        if (task.status !== "paused") return false;
        if (task.pausedAt) {
          const pauseDuration = Date.now() - task.pausedAt;
          task.totalPausedMs = (task.totalPausedMs ?? 0) + pauseDuration;
        }
        task.status = "running";
        task.pausedAt = void 0;
        task.safetyAlarmAt = Date.now() + 3e4;
        return true;
      });
      if (updated) {
        yield* Effect_exports.promise(
          () => this.storage.transaction(async (txn) => {
            await this._rebuildQueueSync(txn);
            await this._updateAlarmSync(txn);
          })
        );
        void this.processTask(taskId);
      }
      return updated;
    });
  }
  /**
   * Delete all completed tasks. Returns the count of deleted tasks.
   */
  async clearCompleted() {
    return Effect_exports.runPromise(this._clearCompleted());
  }
  _clearCompleted() {
    return Effect_exports.gen(this, function* () {
      const tasks = yield* this._getTasks("completed");
      let count = 0;
      for (const task of tasks) {
        yield* Effect_exports.promise(
          () => this.storage.delete(`task:${task.taskId}`)
        );
        count++;
      }
      if (count > 0) {
        yield* Effect_exports.promise(
          () => this.storage.transaction(async (txn) => {
            await this._rebuildQueueSync(txn);
            await this._updateAlarmSync(txn);
          })
        );
      }
      return count;
    });
  }
  /**
   * Delete all tasks regardless of status. Returns the count of deleted tasks.
   */
  async clearAll() {
    return Effect_exports.runPromise(this._clearAll());
  }
  _clearAll() {
    return Effect_exports.gen(this, function* () {
      const tasks = yield* this._getTasks();
      let count = 0;
      for (const task of tasks) {
        yield* Effect_exports.promise(
          () => this.storage.delete(`task:${task.taskId}`)
        );
        count++;
      }
      if (count > 0) {
        yield* Effect_exports.promise(
          () => this.storage.transaction(async (txn) => {
            await this._rebuildQueueSync(txn);
            await this._updateAlarmSync(txn);
          })
        );
      }
      return count;
    });
  }
  /**
   * Call this from your Durable Object's alarm handler to process scheduled tasks.
   */
  async alarm() {
    return Effect_exports.runPromise(this._alarm());
  }
  _alarm() {
    return Effect_exports.gen(this, function* () {
      const now = Date.now();
      const dueTaskIds = yield* this._getDueTaskIds(now);
      for (const taskId of dueTaskIds) {
        void this.processTask(taskId);
      }
      yield* Effect_exports.promise(
        () => this.storage.transaction(async (txn) => {
          await this._rebuildQueueSync(txn);
          await this._updateAlarmSync(txn);
        })
      );
    });
  }
  async processTask(taskId) {
    const task = await this.storage.get(`task:${taskId}`);
    if (!task) return;
    if (task.status === "paused") return;
    if (task.progress.completed) {
      await this._updateTaskSync(taskId, (t) => {
        t.status = "completed";
        return true;
      });
      return;
    }
    const handler = this.handlers.get(task.taskName);
    if (!handler) {
      console.error(`No handler for taskName "${task.taskName}"`);
      return;
    }
    const isRetry = task.safetyAlarmAt && task.status === "running";
    const maxRetries = task.maxRetries ?? 3;
    const retryCount = task.retryCount ?? 0;
    if (isRetry && retryCount >= maxRetries) {
      const errorMessage = `Task exceeded max retries (${maxRetries})`;
      await this._updateTaskSync(taskId, (t) => {
        t.status = "failed";
        t.progress.error = errorMessage;
        return true;
      });
      console.error(
        `Task ${taskId} (${task.taskName}) exceeded max retries (${maxRetries})`
      );
      return;
    }
    let updated = false;
    if (task.status !== "running") {
      updated = await this._updateTaskSync(taskId, (t) => {
        t.status = "running";
        return true;
      });
      if (!updated) return;
    } else if (isRetry) {
      updated = await this._updateTaskSync(taskId, (t) => {
        t.retryCount = (t.retryCount ?? 0) + 1;
        return true;
      });
      if (!updated) return;
    }
    try {
      await Effect_exports.runPromise(handler(this, taskId, task.params));
    } catch (err) {
      console.error(`Task ${taskId} (${task.taskName}) threw:`, err);
      const errorMessage = err instanceof Error ? err.message : String(err);
      await this._updateTaskSync(taskId, (t) => {
        if (t.status === "running") {
          t.progress.lastError = errorMessage;
        }
        return true;
      });
    }
  }
  _updateTask(taskId, mutate7) {
    return Effect_exports.promise(
      () => this.storage.transaction(async (txn) => {
        const task = await txn.get(`task:${taskId}`);
        if (!task) return false;
        const changed = mutate7(task);
        if (changed) {
          await txn.put(`task:${taskId}`, task);
        }
        return changed;
      })
    );
  }
  async _updateTaskSync(taskId, mutate7) {
    return await this.storage.transaction(async (txn) => {
      const task = await txn.get(`task:${taskId}`);
      if (!task) return false;
      const changed = mutate7(task);
      if (changed) {
        await txn.put(`task:${taskId}`, task);
      }
      return changed;
    });
  }
  async _rebuildQueueSync(txn) {
    const storage = txn || this.storage;
    const list = await storage.list({ prefix: "task:" });
    const taskIds = Array.from(list.keys()).map(
      (k) => k.substring(5)
    );
    const activeTaskIds = [];
    for (const id of taskIds) {
      const t = await storage.get(`task:${id}`);
      if (t && t.status !== "completed" && t.status !== "failed" && t.status !== "paused" && (t.status === "pending" || t.status === "running" && t.safetyAlarmAt && !t.progress.completed)) {
        activeTaskIds.push(id);
      }
    }
    const tasksWithTime = [];
    for (const id of activeTaskIds) {
      const t = await storage.get(`task:${id}`);
      if (t) {
        const time = t.safetyAlarmAt ?? t.scheduledAt;
        tasksWithTime.push({ id, time });
      }
    }
    const sorted = tasksWithTime.sort((a, b) => a.time - b.time).map((o) => o.id);
    await storage.put("queue", sorted);
  }
  _rebuildQueue(txn) {
    return Effect_exports.promise(() => this._rebuildQueueSync(txn));
  }
  _getQueue() {
    return Effect_exports.promise(() => this._getQueueSync(this.storage));
  }
  _getDueTaskIds(now) {
    return Effect_exports.gen(this, function* () {
      const queue = yield* this._getQueue();
      const due = [];
      for (const taskId of queue) {
        const taskResult = yield* Effect_exports.promise(
          () => this.storage.get(`task:${taskId}`)
        );
        const task = taskResult;
        if (!task) continue;
        const dueTime = task.safetyAlarmAt ?? task.scheduledAt;
        if (dueTime <= now && !task.progress.completed) {
          due.push(taskId);
        } else {
          break;
        }
      }
      return due;
    });
  }
  async _updateAlarmSync(txn) {
    const storage = txn || this.storage;
    const queue = await this._getQueueSync(storage);
    if (queue.length === 0) {
      await storage.deleteAlarm();
      return;
    }
    const nextId = queue[0];
    const nextTask = await storage.get(`task:${nextId}`);
    if (!nextTask) return;
    const nextTime = nextTask.safetyAlarmAt ?? nextTask.scheduledAt;
    if (nextTime > Date.now()) {
      await storage.setAlarm(nextTime);
    }
  }
  async _getQueueSync(storage) {
    let queue = await storage.get("queue");
    if (!queue || queue.length === 0) {
      await this._rebuildQueueSync(storage);
      queue = await storage.get("queue");
    }
    return queue ?? [];
  }
  _updateAlarm(txn) {
    return Effect_exports.promise(() => this._updateAlarmSync(txn));
  }
  /**
   * Execute a multi-step task with automatic progress tracking, pause/resume support, checkpointing, and optional auto-completion.
   */
  async runSteps(taskId, steps, options = {}) {
    return Effect_exports.runPromise(this._runSteps(taskId, steps, options));
  }
  /**
   * Helper for sub-step execution within a step. Handles pause checks and progress tracking automatically.
   */
  async runSubSteps(taskId, stepName, stepIndex, totalSteps, subStepCount, subStepDuration, onSubStep) {
    return Effect_exports.runPromise(
      this._runSubSteps(
        taskId,
        stepName,
        stepIndex,
        totalSteps,
        subStepCount,
        subStepDuration,
        onSubStep
      )
    );
  }
  _runSubSteps(taskId, stepName, stepIndex, totalSteps, subStepCount, subStepDuration, onSubStep) {
    return Effect_exports.gen(this, function* () {
      for (let j = 0; j < subStepCount; j++) {
        const task = yield* this._getTask(taskId);
        if (!task || task.status === "paused") {
          return;
        }
        if (onSubStep) {
          const subStepResult = onSubStep(j);
          if (subStepResult instanceof Promise) {
            yield* Effect_exports.promise(() => subStepResult);
          } else {
            yield* subStepResult;
          }
        } else {
          yield* Effect_exports.promise(
            () => new Promise((r) => setTimeout(r, subStepDuration))
          );
        }
        if (subStepCount > 1) {
          yield* this._checkpoint(
            taskId,
            "step",
            `${stepName} (${j + 1}/${subStepCount})`
          );
          yield* this._checkpoint(
            taskId,
            "progress",
            `${Math.round(
              (stepIndex + (j + 1) / subStepCount) / totalSteps * 100
            )}%`
          );
        }
      }
    });
  }
  /**
   * Generate a unique task ID. Default prefix is 'task'.
   */
  static generateTaskId(prefix = "task") {
    return `${prefix}-${Date.now()}`;
  }
  /**
   * Format a task object for UI consumption with standardized fields.
   */
  formatTaskForUI(task) {
    return {
      taskId: task.taskId,
      taskName: task.taskName,
      status: task.status,
      progress: task.progress,
      startedAt: task.startedAt ?? task.scheduledAt,
      completedAt: task.status === "completed" ? Date.now() : void 0,
      pausedAt: task.pausedAt,
      totalPausedMs: task.totalPausedMs ?? 0
    };
  }
  _runSteps(taskId, steps, options) {
    return Effect_exports.gen(this, function* () {
      const totalSteps = steps.length;
      const stepDuration = options.stepDuration ?? 1e3;
      let stepHistory = (yield* this._getCheckpoint(taskId, "stepHistory")) || [];
      const completedSteps = (yield* this._getCheckpoint(taskId, "completedSteps")) || [];
      let currentStepIndex = completedSteps.length;
      while (currentStepIndex < totalSteps) {
        const task = yield* this._getTask(taskId);
        if (!task || task.status === "paused") {
          return;
        }
        const stepName = steps[currentStepIndex] || `step-${currentStepIndex + 1}`;
        const checkpointKey = `${stepName}_done`;
        const isDone9 = yield* this._getCheckpoint(taskId, checkpointKey);
        if (isDone9) {
          currentStepIndex++;
          continue;
        }
        const stepStartTime = (/* @__PURE__ */ new Date()).toISOString();
        stepHistory.push({
          step: stepName,
          index: currentStepIndex + 1,
          total: totalSteps,
          startedAt: stepStartTime,
          status: "running"
        });
        yield* this._checkpoint(taskId, "step", stepName);
        yield* this._checkpoint(taskId, "currentStepIndex", currentStepIndex);
        yield* this._checkpoint(taskId, "totalSteps", totalSteps);
        yield* this._checkpoint(
          taskId,
          "progress",
          `${Math.round(currentStepIndex / totalSteps * 100)}%`
        );
        yield* this._checkpoint(taskId, "stepHistory", stepHistory);
        if (options.onStep) {
          const stepResult = options.onStep(stepName, currentStepIndex);
          if (stepResult instanceof Promise) {
            yield* Effect_exports.promise(() => stepResult);
          } else {
            yield* stepResult;
          }
        } else {
          yield* Effect_exports.promise(
            () => new Promise((r) => setTimeout(r, stepDuration))
          );
        }
        const taskAfterStep = yield* this._getTask(taskId);
        if (!taskAfterStep || taskAfterStep.status === "paused") {
          return;
        }
        yield* this._checkpoint(taskId, checkpointKey, true);
        completedSteps.push(stepName);
        currentStepIndex++;
        const stepEntry = stepHistory[stepHistory.length - 1];
        if (stepEntry) {
          stepEntry.status = "completed";
          stepEntry.completedAt = (/* @__PURE__ */ new Date()).toISOString();
        }
        yield* this._checkpoint(taskId, "currentStepIndex", currentStepIndex);
        yield* this._checkpoint(taskId, "completedSteps", completedSteps);
        yield* this._checkpoint(taskId, "stepHistory", stepHistory);
        yield* this._checkpoint(
          taskId,
          "progress",
          `${Math.round(currentStepIndex / totalSteps * 100)}%`
        );
      }
      const finalTask = yield* this._getTask(taskId);
      if (!finalTask || finalTask.status === "paused") {
        return;
      }
      yield* this._checkpoint(taskId, "currentStepIndex", totalSteps);
      yield* this._checkpoint(taskId, "step", "done");
      yield* this._checkpoint(taskId, "progress", "100%");
      if (options.autoComplete !== false) {
        if (options.result) {
          yield* this._checkpoint(taskId, "result", options.result);
        }
        yield* this._completeTask(taskId);
      }
    });
  }
};

// node_modules/effect/dist/esm/Function.js
var isFunction3 = /* @__PURE__ */ __name((input) => typeof input === "function", "isFunction");
var dual2 = /* @__PURE__ */ __name(function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args3 = arguments;
        return function(self) {
          return body(self, ...args3);
        };
      };
  }
}, "dual");
var identity2 = /* @__PURE__ */ __name((a) => a, "identity");
var constant2 = /* @__PURE__ */ __name((value) => () => value, "constant");
var constTrue2 = /* @__PURE__ */ constant2(true);
var constFalse2 = /* @__PURE__ */ constant2(false);
var constUndefined2 = /* @__PURE__ */ constant2(void 0);
var constVoid2 = constUndefined2;
function pipe2(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
__name(pipe2, "pipe");

// node_modules/effect/dist/esm/Equivalence.js
var make39 = /* @__PURE__ */ __name((isEquivalent) => (self, that) => self === that || isEquivalent(self, that), "make");
var mapInput3 = /* @__PURE__ */ dual2(2, (self, f) => make39((x, y) => self(f(x), f(y))));
var array4 = /* @__PURE__ */ __name((item) => make39((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
}), "array");

// node_modules/effect/dist/esm/internal/doNotation.js
var let_4 = /* @__PURE__ */ __name((map23) => dual2(3, (self, name, f) => map23(self, (a) => ({
  ...a,
  [name]: f(a)
}))), "let_");
var bindTo4 = /* @__PURE__ */ __name((map23) => dual2(2, (self, name) => map23(self, (a) => ({
  [name]: a
}))), "bindTo");
var bind4 = /* @__PURE__ */ __name((map23, flatMap19) => dual2(3, (self, name, f) => flatMap19(self, (a) => map23(f(a), (b) => ({
  ...a,
  [name]: b
})))), "bind");

// node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId2 = `effect/GlobalValue`;
var globalStore2;
var globalValue2 = /* @__PURE__ */ __name((id, compute) => {
  if (!globalStore2) {
    globalThis[globalStoreId2] ??= /* @__PURE__ */ new Map();
    globalStore2 = globalThis[globalStoreId2];
  }
  if (!globalStore2.has(id)) {
    globalStore2.set(id, compute());
  }
  return globalStore2.get(id);
}, "globalValue");

// node_modules/effect/dist/esm/Predicate.js
var isString2 = /* @__PURE__ */ __name((input) => typeof input === "string", "isString");
var isNumber2 = /* @__PURE__ */ __name((input) => typeof input === "number", "isNumber");
var isBigInt2 = /* @__PURE__ */ __name((input) => typeof input === "bigint", "isBigInt");
var isFunction4 = isFunction3;
var isRecordOrArray2 = /* @__PURE__ */ __name((input) => typeof input === "object" && input !== null, "isRecordOrArray");
var isObject2 = /* @__PURE__ */ __name((input) => isRecordOrArray2(input) || isFunction4(input), "isObject");
var hasProperty2 = /* @__PURE__ */ dual2(2, (self, property) => isObject2(self) && property in self);
var isTagged2 = /* @__PURE__ */ dual2(2, (self, tag) => hasProperty2(self, "_tag") && self["_tag"] === tag);
var isNullable2 = /* @__PURE__ */ __name((input) => input === null || input === void 0, "isNullable");
var isIterable2 = /* @__PURE__ */ __name((input) => typeof input === "string" || hasProperty2(input, Symbol.iterator), "isIterable");
var isPromiseLike2 = /* @__PURE__ */ __name((input) => hasProperty2(input, "then") && isFunction4(input.then), "isPromiseLike");

// node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage2 = /* @__PURE__ */ __name((message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`, "getBugErrorMessage");

// node_modules/effect/dist/esm/Utils.js
var GenKindTypeId2 = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var GenKindImpl2 = class {
  static {
    __name(this, "GenKindImpl");
  }
  value;
  constructor(value) {
    this.value = value;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity2;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId2] = GenKindTypeId2;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen3(this);
  }
};
var SingleShotGen3 = class _SingleShotGen {
  static {
    __name(this, "SingleShotGen");
  }
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var defaultIncHi2 = 335903614;
var defaultIncLo2 = 4150755663;
var MUL_HI2 = 1481765933 >>> 0;
var MUL_LO2 = 1284865837 >>> 0;
var BIT_532 = 9007199254740992;
var BIT_272 = 134217728;
var PCGRandom2 = class {
  static {
    __name(this, "PCGRandom");
  }
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable2(seedLo) && isNullable2(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable2(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable2(incLo) && isNullable2(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo2;
      incHi = this._state ? this._state[2] : defaultIncHi2;
    } else if (isNullable2(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add642(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max9) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max9;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_272 + lo) / BIT_532;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul642(this._state, oldHi, oldLo, MUL_HI2, MUL_LO2);
    add642(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul642(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
__name(mul642, "mul64");
function add642(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
__name(add642, "add64");
var YieldWrapTypeId2 = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap2 = class {
  static {
    __name(this, "YieldWrap");
  }
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId2]() {
    return this.#value;
  }
};
function yieldWrapGet2(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId2 in self) {
    return self[YieldWrapTypeId2]();
  }
  throw new Error(getBugErrorMessage2("yieldWrapGet"));
}
__name(yieldWrapGet2, "yieldWrapGet");
var structuralRegionState2 = /* @__PURE__ */ globalValue2("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard2 = {
  effect_internal_function: /* @__PURE__ */ __name((body) => {
    return body();
  }, "effect_internal_function")
};
var forced2 = {
  effect_internal_function: /* @__PURE__ */ __name((body) => {
    try {
      return body();
    } finally {
    }
  }, "effect_internal_function")
};
var isNotOptimizedAway2 = /* @__PURE__ */ standard2.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall2 = isNotOptimizedAway2 ? standard2.effect_internal_function : forced2.effect_internal_function;
var genConstructor2 = function* () {
}.constructor;
var isGeneratorFunction2 = /* @__PURE__ */ __name((u) => isObject2(u) && u.constructor === genConstructor2, "isGeneratorFunction");

// node_modules/effect/dist/esm/Hash.js
var randomHashCache2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol3 = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash2 = /* @__PURE__ */ __name((self) => {
  if (structuralRegionState2.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number3(self);
    case "bigint":
      return string2(self.toString(10));
    case "boolean":
      return string2(String(self));
    case "symbol":
      return string2(String(self));
    case "string":
      return string2(self);
    case "undefined":
      return string2("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string2("null");
      } else if (self instanceof Date) {
        if (Number.isNaN(self.getTime())) {
          return string2("Invalid Date");
        }
        return hash2(self.toISOString());
      } else if (self instanceof URL) {
        return hash2(self.href);
      } else if (isHash2(self)) {
        return self[symbol3]();
      } else {
        return random4(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
}, "hash");
var random4 = /* @__PURE__ */ __name((self) => {
  if (!randomHashCache2.has(self)) {
    randomHashCache2.set(self, number3(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache2.get(self);
}, "random");
var combine9 = /* @__PURE__ */ __name((b) => (self) => self * 53 ^ b, "combine");
var optimize2 = /* @__PURE__ */ __name((n) => n & 3221225471 | n >>> 1 & 1073741824, "optimize");
var isHash2 = /* @__PURE__ */ __name((u) => hasProperty2(u, symbol3), "isHash");
var number3 = /* @__PURE__ */ __name((n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize2(h);
}, "number");
var string2 = /* @__PURE__ */ __name((str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize2(h);
}, "string");
var structureKeys2 = /* @__PURE__ */ __name((o, keys9) => {
  let h = 12289;
  for (let i = 0; i < keys9.length; i++) {
    h ^= pipe2(string2(keys9[i]), combine9(hash2(o[keys9[i]])));
  }
  return optimize2(h);
}, "structureKeys");
var structure2 = /* @__PURE__ */ __name((o) => structureKeys2(o, Object.keys(o)), "structure");
var array5 = /* @__PURE__ */ __name((arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe2(h, combine9(hash2(arr[i])));
  }
  return optimize2(h);
}, "array");
var cached4 = /* @__PURE__ */ __name(function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash4) {
      Object.defineProperty(self2, symbol3, {
        value() {
          return hash4;
        },
        enumerable: false
      });
      return hash4;
    };
  }
  const self = arguments[0];
  const hash3 = arguments[1];
  Object.defineProperty(self, symbol3, {
    value() {
      return hash3;
    },
    enumerable: false
  });
  return hash3;
}, "cached");

// node_modules/effect/dist/esm/Equal.js
var symbol4 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals3() {
  if (arguments.length === 1) {
    return (self) => compareBoth2(self, arguments[0]);
  }
  return compareBoth2(arguments[0], arguments[1]);
}
__name(equals3, "equals");
function compareBoth2(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual2(self) && isEqual2(that)) {
        if (hash2(self) === hash2(that) && self[symbol4](that)) {
          return true;
        } else {
          return structuralRegionState2.enabled && structuralRegionState2.tester ? structuralRegionState2.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        const t1 = self.getTime();
        const t2 = that.getTime();
        return t1 === t2 || Number.isNaN(t1) && Number.isNaN(t2);
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState2.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth2(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth2(self[key], that[key]))) {
              return structuralRegionState2.tester ? structuralRegionState2.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState2.tester ? structuralRegionState2.tester(self, that) : false;
    }
  }
  return structuralRegionState2.enabled && structuralRegionState2.tester ? structuralRegionState2.tester(self, that) : false;
}
__name(compareBoth2, "compareBoth");
var isEqual2 = /* @__PURE__ */ __name((u) => hasProperty2(u, symbol4), "isEqual");
var equivalence2 = /* @__PURE__ */ __name(() => equals3, "equivalence");

// node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol2 = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON2 = /* @__PURE__ */ __name((x) => {
  try {
    if (hasProperty2(x, "toJSON") && isFunction4(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON2);
    }
  } catch {
    return {};
  }
  return redact2(x);
}, "toJSON");
var format4 = /* @__PURE__ */ __name((x) => JSON.stringify(x, null, 2), "format");
var BaseProto2 = {
  toJSON() {
    return toJSON2(this);
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  toString() {
    return format4(this.toJSON());
  }
};
var Class5 = class {
  static {
    __name(this, "Class");
  }
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format4(this.toJSON());
  }
};
var toStringUnknown2 = /* @__PURE__ */ __name((u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular2(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
}, "toStringUnknown");
var stringifyCircular2 = /* @__PURE__ */ __name((obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? void 0 : cache.push(value) && (redactableState2.fiberRefs !== void 0 && isRedactable2(value) ? value[symbolRedactable2](redactableState2.fiberRefs) : value) : value, whitespace);
  cache = void 0;
  return retVal;
}, "stringifyCircular");
var symbolRedactable2 = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable2 = /* @__PURE__ */ __name((u) => typeof u === "object" && u !== null && symbolRedactable2 in u, "isRedactable");
var redactableState2 = /* @__PURE__ */ globalValue2("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext2 = /* @__PURE__ */ __name((context7, f) => {
  const prev = redactableState2.fiberRefs;
  redactableState2.fiberRefs = context7;
  try {
    return f();
  } finally {
    redactableState2.fiberRefs = prev;
  }
}, "withRedactableContext");
var redact2 = /* @__PURE__ */ __name((u) => {
  if (isRedactable2(u) && redactableState2.fiberRefs !== void 0) {
    return u[symbolRedactable2](redactableState2.fiberRefs);
  }
  return u;
}, "redact");

// node_modules/effect/dist/esm/Pipeable.js
var pipeArguments2 = /* @__PURE__ */ __name((self, args3) => {
  switch (args3.length) {
    case 0:
      return self;
    case 1:
      return args3[0](self);
    case 2:
      return args3[1](args3[0](self));
    case 3:
      return args3[2](args3[1](args3[0](self)));
    case 4:
      return args3[3](args3[2](args3[1](args3[0](self))));
    case 5:
      return args3[4](args3[3](args3[2](args3[1](args3[0](self)))));
    case 6:
      return args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self))))));
    case 7:
      return args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self)))))));
    case 8:
      return args3[7](args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self))))))));
    case 9:
      return args3[8](args3[7](args3[6](args3[5](args3[4](args3[3](args3[2](args3[1](args3[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args3.length; i < len; i++) {
        ret = args3[i](ret);
      }
      return ret;
    }
  }
}, "pipeArguments");

// node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC2 = "Async";
var OP_COMMIT2 = "Commit";
var OP_FAILURE2 = "Failure";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE2 = "OnSuccessAndFailure";
var OP_SUCCESS2 = "Success";
var OP_SYNC2 = "Sync";
var OP_TAG2 = "Tag";
var OP_UPDATE_RUNTIME_FLAGS2 = "UpdateRuntimeFlags";
var OP_WHILE2 = "While";
var OP_ITERATOR2 = "Iterator";
var OP_WITH_RUNTIME2 = "WithRuntime";
var OP_YIELD2 = "Yield";
var OP_REVERT_FLAGS2 = "RevertFlags";

// node_modules/effect/dist/esm/internal/version.js
var moduleVersion2 = "3.19.13";
var getCurrentVersion2 = /* @__PURE__ */ __name(() => moduleVersion2, "getCurrentVersion");

// node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId4 = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId2 = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance2 = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  _V: /* @__PURE__ */ getCurrentVersion2()
};
var sinkVariance2 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _L: /* @__PURE__ */ __name((_) => _, "_L"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var channelVariance2 = {
  /* c8 ignore next */
  _Env: /* @__PURE__ */ __name((_) => _, "_Env"),
  /* c8 ignore next */
  _InErr: /* @__PURE__ */ __name((_) => _, "_InErr"),
  /* c8 ignore next */
  _InElem: /* @__PURE__ */ __name((_) => _, "_InElem"),
  /* c8 ignore next */
  _InDone: /* @__PURE__ */ __name((_) => _, "_InDone"),
  /* c8 ignore next */
  _OutErr: /* @__PURE__ */ __name((_) => _, "_OutErr"),
  /* c8 ignore next */
  _OutElem: /* @__PURE__ */ __name((_) => _, "_OutElem"),
  /* c8 ignore next */
  _OutDone: /* @__PURE__ */ __name((_) => _, "_OutDone")
};
var EffectPrototype3 = {
  [EffectTypeId4]: effectVariance2,
  [StreamTypeId2]: effectVariance2,
  [SinkTypeId2]: sinkVariance2,
  [ChannelTypeId2]: channelVariance2,
  [symbol4](that) {
    return this === that;
  },
  [symbol3]() {
    return cached4(this, random4(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen3(new YieldWrap2(this));
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var StructuralPrototype2 = {
  [symbol3]() {
    return cached4(this, structure2(this));
  },
  [symbol4](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals3(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype3 = {
  ...EffectPrototype3,
  _op: OP_COMMIT2
};
var StructuralCommitPrototype2 = {
  ...CommitPrototype3,
  ...StructuralPrototype2
};
var Base3 = /* @__PURE__ */ (function() {
  function Base5() {
  }
  __name(Base5, "Base");
  Base5.prototype = CommitPrototype3;
  return Base5;
})();

// node_modules/effect/dist/esm/internal/option.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto3 = {
  ...EffectPrototype3,
  [TypeId16]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  toString() {
    return format4(this.toJSON());
  }
};
var SomeProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto3), {
  _tag: "Some",
  _op: "Some",
  [symbol4](that) {
    return isOption2(that) && isSome3(that) && equals3(this.value, that.value);
  },
  [symbol3]() {
    return cached4(this, combine9(hash2(this._tag))(hash2(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON2(this.value)
    };
  }
});
var NoneHash2 = /* @__PURE__ */ hash2("None");
var NoneProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto3), {
  _tag: "None",
  _op: "None",
  [symbol4](that) {
    return isOption2(that) && isNone4(that);
  },
  [symbol3]() {
    return NoneHash2;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption2 = /* @__PURE__ */ __name((input) => hasProperty2(input, TypeId16), "isOption");
var isNone4 = /* @__PURE__ */ __name((fa) => fa._tag === "None", "isNone");
var isSome3 = /* @__PURE__ */ __name((fa) => fa._tag === "Some", "isSome");
var none10 = /* @__PURE__ */ Object.create(NoneProto2);
var some5 = /* @__PURE__ */ __name((value) => {
  const a = Object.create(SomeProto2);
  a.value = value;
  return a;
}, "some");

// node_modules/effect/dist/esm/internal/either.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto4 = {
  ...EffectPrototype3,
  [TypeId17]: {
    _R: /* @__PURE__ */ __name((_) => _, "_R")
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  toString() {
    return format4(this.toJSON());
  }
};
var RightProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto4), {
  _tag: "Right",
  _op: "Right",
  [symbol4](that) {
    return isEither2(that) && isRight3(that) && equals3(this.right, that.right);
  },
  [symbol3]() {
    return combine9(hash2(this._tag))(hash2(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON2(this.right)
    };
  }
});
var LeftProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto4), {
  _tag: "Left",
  _op: "Left",
  [symbol4](that) {
    return isEither2(that) && isLeft3(that) && equals3(this.left, that.left);
  },
  [symbol3]() {
    return combine9(hash2(this._tag))(hash2(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON2(this.left)
    };
  }
});
var isEither2 = /* @__PURE__ */ __name((input) => hasProperty2(input, TypeId17), "isEither");
var isLeft3 = /* @__PURE__ */ __name((ma) => ma._tag === "Left", "isLeft");
var isRight3 = /* @__PURE__ */ __name((ma) => ma._tag === "Right", "isRight");
var left3 = /* @__PURE__ */ __name((left5) => {
  const a = Object.create(LeftProto2);
  a.left = left5;
  return a;
}, "left");
var right3 = /* @__PURE__ */ __name((right5) => {
  const a = Object.create(RightProto2);
  a.right = right5;
  return a;
}, "right");

// node_modules/effect/dist/esm/Either.js
var right4 = right3;
var left4 = left3;
var isLeft4 = isLeft3;
var isRight4 = isRight3;
var match10 = /* @__PURE__ */ dual2(2, (self, {
  onLeft,
  onRight
}) => isLeft4(self) ? onLeft(self.left) : onRight(self.right));
var merge7 = /* @__PURE__ */ match10({
  onLeft: identity2,
  onRight: identity2
});

// node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray3 = /* @__PURE__ */ __name((self) => self.length > 0, "isNonEmptyArray");

// node_modules/effect/dist/esm/Order.js
var make40 = /* @__PURE__ */ __name((compare) => (self, that) => self === that ? 0 : compare(self, that), "make");
var number4 = /* @__PURE__ */ make40((self, that) => self < that ? -1 : 1);
var mapInput4 = /* @__PURE__ */ dual2(2, (self, f) => make40((b1, b2) => self(f(b1), f(b2))));
var greaterThan3 = /* @__PURE__ */ __name((O) => dual2(2, (self, that) => O(self, that) === 1), "greaterThan");

// node_modules/effect/dist/esm/Option.js
var none11 = /* @__PURE__ */ __name(() => none10, "none");
var some6 = some5;
var isNone5 = isNone4;
var isSome4 = isSome3;
var match11 = /* @__PURE__ */ dual2(2, (self, {
  onNone,
  onSome
}) => isNone5(self) ? onNone() : onSome(self.value));
var getOrElse5 = /* @__PURE__ */ dual2(2, (self, onNone) => isNone5(self) ? onNone() : self.value);
var orElseSome2 = /* @__PURE__ */ dual2(2, (self, onNone) => isNone5(self) ? some6(onNone()) : self);
var fromNullable4 = /* @__PURE__ */ __name((nullableValue) => nullableValue == null ? none11() : some6(nullableValue), "fromNullable");
var getOrUndefined2 = /* @__PURE__ */ getOrElse5(constUndefined2);
var getOrThrowWith2 = /* @__PURE__ */ dual2(2, (self, onNone) => {
  if (isSome4(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map12 = /* @__PURE__ */ dual2(2, (self, f) => isNone5(self) ? none11() : some6(f(self.value)));
var flatMap10 = /* @__PURE__ */ dual2(2, (self, f) => isNone5(self) ? none11() : f(self.value));
var containsWith3 = /* @__PURE__ */ __name((isEquivalent) => dual2(2, (self, a) => isNone5(self) ? false : isEquivalent(self.value, a)), "containsWith");
var _equivalence5 = /* @__PURE__ */ equivalence2();
var contains3 = /* @__PURE__ */ containsWith3(_equivalence5);
var mergeWith2 = /* @__PURE__ */ __name((f) => (o1, o2) => {
  if (isNone5(o1)) {
    return o2;
  } else if (isNone5(o2)) {
    return o1;
  }
  return some6(f(o1.value, o2.value));
}, "mergeWith");

// node_modules/effect/dist/esm/Tuple.js
var make41 = /* @__PURE__ */ __name((...elements) => elements, "make");

// node_modules/effect/dist/esm/Array.js
var allocate2 = /* @__PURE__ */ __name((n) => new Array(n), "allocate");
var makeBy2 = /* @__PURE__ */ dual2(2, (n, f) => {
  const max9 = Math.max(1, Math.floor(n));
  const out = new Array(max9);
  for (let i = 0; i < max9; i++) {
    out[i] = f(i);
  }
  return out;
});
var fromIterable11 = /* @__PURE__ */ __name((collection) => Array.isArray(collection) ? collection : Array.from(collection), "fromIterable");
var ensure2 = /* @__PURE__ */ __name((self) => Array.isArray(self) ? self : [self], "ensure");
var prepend4 = /* @__PURE__ */ dual2(2, (self, head9) => [head9, ...self]);
var append4 = /* @__PURE__ */ dual2(2, (self, last5) => [...self, last5]);
var appendAll4 = /* @__PURE__ */ dual2(2, (self, that) => fromIterable11(self).concat(fromIterable11(that)));
var isArray2 = Array.isArray;
var isEmptyArray2 = /* @__PURE__ */ __name((self) => self.length === 0, "isEmptyArray");
var isEmptyReadonlyArray2 = isEmptyArray2;
var isNonEmptyArray4 = isNonEmptyArray3;
var isNonEmptyReadonlyArray2 = isNonEmptyArray3;
var isOutOfBounds2 = /* @__PURE__ */ __name((i, as7) => i < 0 || i >= as7.length, "isOutOfBounds");
var clamp3 = /* @__PURE__ */ __name((i, as7) => Math.floor(Math.min(Math.max(0, i), as7.length)), "clamp");
var get13 = /* @__PURE__ */ dual2(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds2(i, self) ? none11() : some6(self[i]);
});
var unsafeGet6 = /* @__PURE__ */ dual2(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds2(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head5 = /* @__PURE__ */ get13(0);
var headNonEmpty3 = /* @__PURE__ */ unsafeGet6(0);
var last3 = /* @__PURE__ */ __name((self) => isNonEmptyReadonlyArray2(self) ? some6(lastNonEmpty2(self)) : none11(), "last");
var lastNonEmpty2 = /* @__PURE__ */ __name((self) => self[self.length - 1], "lastNonEmpty");
var tailNonEmpty3 = /* @__PURE__ */ __name((self) => self.slice(1), "tailNonEmpty");
var spanIndex2 = /* @__PURE__ */ __name((self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
}, "spanIndex");
var span2 = /* @__PURE__ */ dual2(2, (self, predicate) => splitAt2(self, spanIndex2(self, predicate)));
var drop3 = /* @__PURE__ */ dual2(2, (self, n) => {
  const input = fromIterable11(self);
  return input.slice(clamp3(n, input), input.length);
});
var reverse4 = /* @__PURE__ */ __name((self) => Array.from(self).reverse(), "reverse");
var sort2 = /* @__PURE__ */ dual2(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var zip5 = /* @__PURE__ */ dual2(2, (self, that) => zipWith4(self, that, make41));
var zipWith4 = /* @__PURE__ */ dual2(3, (self, that, f) => {
  const as7 = fromIterable11(self);
  const bs = fromIterable11(that);
  if (isNonEmptyReadonlyArray2(as7) && isNonEmptyReadonlyArray2(bs)) {
    const out = [f(headNonEmpty3(as7), headNonEmpty3(bs))];
    const len = Math.min(as7.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as7[i], bs[i]);
    }
    return out;
  }
  return [];
});
var _equivalence6 = /* @__PURE__ */ equivalence2();
var splitAt2 = /* @__PURE__ */ dual2(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray2(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt2(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt2 = /* @__PURE__ */ dual2(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy3(self), []] : [prepend4(self.slice(1, _n), headNonEmpty3(self)), self.slice(_n)];
});
var copy3 = /* @__PURE__ */ __name((self) => self.slice(), "copy");
var unionWith2 = /* @__PURE__ */ dual2(3, (self, that, isEquivalent) => {
  const a = fromIterable11(self);
  const b = fromIterable11(that);
  if (isNonEmptyReadonlyArray2(a)) {
    if (isNonEmptyReadonlyArray2(b)) {
      const dedupe3 = dedupeWith2(isEquivalent);
      return dedupe3(appendAll4(a, b));
    }
    return a;
  }
  return b;
});
var union8 = /* @__PURE__ */ dual2(2, (self, that) => unionWith2(self, that, _equivalence6));
var empty29 = /* @__PURE__ */ __name(() => [], "empty");
var of5 = /* @__PURE__ */ __name((a) => [a], "of");
var map13 = /* @__PURE__ */ dual2(2, (self, f) => self.map(f));
var flatMap11 = /* @__PURE__ */ dual2(2, (self, f) => {
  if (isEmptyReadonlyArray2(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten7 = /* @__PURE__ */ flatMap11(identity2);
var filterMap5 = /* @__PURE__ */ dual2(2, (self, f) => {
  const as7 = fromIterable11(self);
  const out = [];
  for (let i = 0; i < as7.length; i++) {
    const o = f(as7[i], i);
    if (isSome4(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var partitionMap3 = /* @__PURE__ */ dual2(2, (self, f) => {
  const left5 = [];
  const right5 = [];
  const as7 = fromIterable11(self);
  for (let i = 0; i < as7.length; i++) {
    const e = f(as7[i], i);
    if (isLeft4(e)) {
      left5.push(e.left);
    } else {
      right5.push(e.right);
    }
  }
  return [left5, right5];
});
var getSomes2 = /* @__PURE__ */ filterMap5(identity2);
var reduce11 = /* @__PURE__ */ dual2(3, (self, b, f) => fromIterable11(self).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight4 = /* @__PURE__ */ dual2(3, (self, b, f) => fromIterable11(self).reduceRight((b2, a, i) => f(b2, a, i), b));
var unfold3 = /* @__PURE__ */ __name((b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome4(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
}, "unfold");
var getEquivalence4 = array4;
var dedupeWith2 = /* @__PURE__ */ dual2(2, (self, isEquivalent) => {
  const input = fromIterable11(self);
  if (isNonEmptyReadonlyArray2(input)) {
    const out = [headNonEmpty3(input)];
    const rest = tailNonEmpty3(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe2 = /* @__PURE__ */ __name((self) => dedupeWith2(self, equivalence2()), "dedupe");
var join3 = /* @__PURE__ */ dual2(2, (self, sep) => fromIterable11(self).join(sep));

// node_modules/effect/dist/esm/Number.js
var Order3 = number4;

// node_modules/effect/dist/esm/RegExp.js
var escape2 = /* @__PURE__ */ __name((string3) => string3.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&"), "escape");

// node_modules/effect/dist/esm/Boolean.js
var not2 = /* @__PURE__ */ __name((self) => !self, "not");

// node_modules/effect/dist/esm/internal/context.js
var TagTypeId2 = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId2 = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var TagProto2 = {
  ...EffectPrototype3,
  _op: "Tag",
  [STMTypeId2]: effectVariance2,
  [TagTypeId2]: {
    _Service: /* @__PURE__ */ __name((_) => _, "_Service"),
    _Identifier: /* @__PURE__ */ __name((_) => _, "_Identifier")
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make42(this, self);
  }
};
var ReferenceProto2 = {
  ...TagProto2,
  [ReferenceTypeId2]: ReferenceTypeId2
};
var makeGenericTag2 = /* @__PURE__ */ __name((key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto2);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
}, "makeGenericTag");
var Reference3 = /* @__PURE__ */ __name(() => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  __name(ReferenceClass, "ReferenceClass");
  Object.setPrototypeOf(ReferenceClass, ReferenceProto2);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
}, "Reference");
var TypeId18 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto2 = {
  [TypeId18]: {
    _Services: /* @__PURE__ */ __name((_) => _, "_Services")
  },
  [symbol4](that) {
    if (isContext3(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals3(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol3]() {
    return cached4(this, number3(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments2(this, arguments);
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
};
var makeContext2 = /* @__PURE__ */ __name((unsafeMap) => {
  const context7 = Object.create(ContextProto2);
  context7.unsafeMap = unsafeMap;
  return context7;
}, "makeContext");
var serviceNotFoundError2 = /* @__PURE__ */ __name((tag) => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split("\n");
    lines.splice(1, 3);
    error.stack = lines.join("\n");
  }
  return error;
}, "serviceNotFoundError");
var isContext3 = /* @__PURE__ */ __name((u) => hasProperty2(u, TypeId18), "isContext");
var isTag3 = /* @__PURE__ */ __name((u) => hasProperty2(u, TagTypeId2), "isTag");
var isReference2 = /* @__PURE__ */ __name((u) => hasProperty2(u, ReferenceTypeId2), "isReference");
var _empty8 = /* @__PURE__ */ makeContext2(/* @__PURE__ */ new Map());
var empty30 = /* @__PURE__ */ __name(() => _empty8, "empty");
var make42 = /* @__PURE__ */ __name((tag, service) => makeContext2(/* @__PURE__ */ new Map([[tag.key, service]])), "make");
var add6 = /* @__PURE__ */ dual2(3, (self, tag, service) => {
  const map23 = new Map(self.unsafeMap);
  map23.set(tag.key, service);
  return makeContext2(map23);
});
var defaultValueCache2 = /* @__PURE__ */ globalValue2("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue2 = /* @__PURE__ */ __name((tag) => {
  if (defaultValueCache2.has(tag.key)) {
    return defaultValueCache2.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache2.set(tag.key, value);
  return value;
}, "getDefaultValue");
var unsafeGetReference2 = /* @__PURE__ */ __name((self, tag) => {
  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue2(tag);
}, "unsafeGetReference");
var unsafeGet7 = /* @__PURE__ */ dual2(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId2 in tag) return getDefaultValue2(tag);
    throw serviceNotFoundError2(tag);
  }
  return self.unsafeMap.get(tag.key);
});
var get14 = unsafeGet7;
var getOption3 = /* @__PURE__ */ dual2(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    return isReference2(tag) ? some5(getDefaultValue2(tag)) : none10;
  }
  return some5(self.unsafeMap.get(tag.key));
});
var merge8 = /* @__PURE__ */ dual2(2, (self, that) => {
  const map23 = new Map(self.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map23.set(tag, s);
  }
  return makeContext2(map23);
});
var mergeAll6 = /* @__PURE__ */ __name((...ctxs) => {
  const map23 = /* @__PURE__ */ new Map();
  for (let i = 0; i < ctxs.length; i++) {
    ctxs[i].unsafeMap.forEach((value, key) => {
      map23.set(key, value);
    });
  }
  return makeContext2(map23);
}, "mergeAll");

// node_modules/effect/dist/esm/Context.js
var GenericTag2 = makeGenericTag2;
var isContext4 = isContext3;
var isTag4 = isTag3;
var empty31 = empty30;
var make43 = make42;
var add7 = add6;
var get15 = get14;
var unsafeGet8 = unsafeGet7;
var getOption4 = getOption3;
var merge9 = merge8;
var mergeAll7 = mergeAll6;
var Reference4 = Reference3;

// node_modules/effect/dist/esm/Chunk.js
var TypeId19 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy4(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
__name(copy4, "copy");
var emptyArray2 = [];
var getEquivalence5 = /* @__PURE__ */ __name((isEquivalent) => make39((self, that) => self.length === that.length && toReadonlyArray2(self).every((value, i) => isEquivalent(value, unsafeGet9(that, i)))), "getEquivalence");
var _equivalence7 = /* @__PURE__ */ getEquivalence5(equals3);
var ChunkProto2 = {
  [TypeId19]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray2(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  [symbol4](that) {
    return isChunk2(that) && _equivalence7(this, that);
  },
  [symbol3]() {
    return cached4(this, array5(toReadonlyArray2(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray2[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray2(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var makeChunk2 = /* @__PURE__ */ __name((backing) => {
  const chunk3 = Object.create(ChunkProto2);
  chunk3.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk3.length = 0;
      chunk3.depth = 0;
      chunk3.left = chunk3;
      chunk3.right = chunk3;
      break;
    }
    case "IConcat": {
      chunk3.length = backing.left.length + backing.right.length;
      chunk3.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk3.left = backing.left;
      chunk3.right = backing.right;
      break;
    }
    case "IArray": {
      chunk3.length = backing.array.length;
      chunk3.depth = 0;
      chunk3.left = _empty9;
      chunk3.right = _empty9;
      break;
    }
    case "ISingleton": {
      chunk3.length = 1;
      chunk3.depth = 0;
      chunk3.left = _empty9;
      chunk3.right = _empty9;
      break;
    }
    case "ISlice": {
      chunk3.length = backing.length;
      chunk3.depth = backing.chunk.depth + 1;
      chunk3.left = _empty9;
      chunk3.right = _empty9;
      break;
    }
  }
  return chunk3;
}, "makeChunk");
var isChunk2 = /* @__PURE__ */ __name((u) => hasProperty2(u, TypeId19), "isChunk");
var _empty9 = /* @__PURE__ */ makeChunk2({
  _tag: "IEmpty"
});
var empty32 = /* @__PURE__ */ __name(() => _empty9, "empty");
var make44 = /* @__PURE__ */ __name((...as7) => unsafeFromNonEmptyArray2(as7), "make");
var of6 = /* @__PURE__ */ __name((a) => makeChunk2({
  _tag: "ISingleton",
  a
}), "of");
var fromIterable12 = /* @__PURE__ */ __name((self) => isChunk2(self) ? self : unsafeFromArray2(fromIterable11(self)), "fromIterable");
var copyToArray2 = /* @__PURE__ */ __name((self, array6, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy4(self.backing.array, 0, array6, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray2(self.left, array6, initial);
      copyToArray2(self.right, array6, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array6[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array6[j] = unsafeGet9(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
}, "copyToArray");
var toReadonlyArray_2 = /* @__PURE__ */ __name((self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray2;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray2(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty9;
      self.right = _empty9;
      self.depth = 0;
      return arr;
    }
  }
}, "toReadonlyArray_");
var toReadonlyArray2 = toReadonlyArray_2;
var reverseChunk2 = /* @__PURE__ */ __name((self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk2({
        _tag: "IArray",
        array: reverse4(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk2({
        _tag: "IConcat",
        left: reverse5(self.backing.right),
        right: reverse5(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray2(reverse4(toReadonlyArray2(self)));
  }
}, "reverseChunk");
var reverse5 = reverseChunk2;
var get16 = /* @__PURE__ */ dual2(2, (self, index) => index < 0 || index >= self.length ? none11() : some6(unsafeGet9(self, index)));
var unsafeFromArray2 = /* @__PURE__ */ __name((self) => self.length === 0 ? empty32() : self.length === 1 ? of6(self[0]) : makeChunk2({
  _tag: "IArray",
  array: self
}), "unsafeFromArray");
var unsafeFromNonEmptyArray2 = /* @__PURE__ */ __name((self) => unsafeFromArray2(self), "unsafeFromNonEmptyArray");
var unsafeGet9 = /* @__PURE__ */ dual2(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet9(self.left, index) : unsafeGet9(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet9(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append5 = /* @__PURE__ */ dual2(2, (self, a) => appendAll5(self, of6(a)));
var prepend5 = /* @__PURE__ */ dual2(2, (self, elem) => appendAll5(of6(elem), self));
var drop4 = /* @__PURE__ */ dual2(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty9;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk2({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop4(self.right, n - self.left.length);
        }
        return makeChunk2({
          _tag: "IConcat",
          left: drop4(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk2({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var appendAll5 = /* @__PURE__ */ dual2(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff15 = that.depth - self.depth;
  if (Math.abs(diff15) <= 1) {
    return makeChunk2({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff15 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll5(self.right, that);
      return makeChunk2({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll5(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk2({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk2({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk2({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk2({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll5(self, that.left);
      return makeChunk2({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll5(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk2({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk2({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk2({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk2({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var isEmpty9 = /* @__PURE__ */ __name((self) => self.length === 0, "isEmpty");
var isNonEmpty5 = /* @__PURE__ */ __name((self) => self.length > 0, "isNonEmpty");
var head6 = /* @__PURE__ */ get16(0);
var unsafeHead3 = /* @__PURE__ */ __name((self) => unsafeGet9(self, 0), "unsafeHead");
var headNonEmpty4 = unsafeHead3;
var tailNonEmpty4 = /* @__PURE__ */ __name((self) => drop4(self, 1), "tailNonEmpty");

// node_modules/effect/dist/esm/Duration.js
var TypeId20 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint04 = /* @__PURE__ */ BigInt(0);
var bigint242 = /* @__PURE__ */ BigInt(24);
var bigint602 = /* @__PURE__ */ BigInt(60);
var bigint1e32 = /* @__PURE__ */ BigInt(1e3);
var bigint1e62 = /* @__PURE__ */ BigInt(1e6);
var bigint1e92 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX2 = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode2 = /* @__PURE__ */ __name((input) => {
  if (isDuration2(input)) {
    return input;
  } else if (isNumber2(input)) {
    return millis2(input);
  } else if (isBigInt2(input)) {
    return nanos2(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber2)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero2;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity2;
    }
    return nanos2(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString2(input)) {
    const match20 = DURATION_REGEX2.exec(input);
    if (match20) {
      const [_, valueStr, unit] = match20;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos2(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros2(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis2(value);
        case "second":
        case "seconds":
          return seconds2(value);
        case "minute":
        case "minutes":
          return minutes2(value);
        case "hour":
        case "hours":
          return hours2(value);
        case "day":
        case "days":
          return days2(value);
        case "week":
        case "weeks":
          return weeks2(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
}, "decode");
var zeroValue2 = {
  _tag: "Millis",
  millis: 0
};
var infinityValue2 = {
  _tag: "Infinity"
};
var DurationProto2 = {
  [TypeId20]: TypeId20,
  [symbol3]() {
    return cached4(this, structure2(this.value));
  },
  [symbol4](that) {
    return isDuration2(that) && equals4(this, that);
  },
  toString() {
    return `Duration(${format5(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime2(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var make45 = /* @__PURE__ */ __name((input) => {
  const duration = Object.create(DurationProto2);
  if (isNumber2(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue2;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue2;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint04) {
    duration.value = zeroValue2;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
}, "make");
var isDuration2 = /* @__PURE__ */ __name((u) => hasProperty2(u, TypeId20), "isDuration");
var isZero2 = /* @__PURE__ */ __name((self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint04;
    }
    case "Infinity": {
      return false;
    }
  }
}, "isZero");
var zero2 = /* @__PURE__ */ make45(0);
var infinity2 = /* @__PURE__ */ make45(Infinity);
var nanos2 = /* @__PURE__ */ __name((nanos3) => make45(nanos3), "nanos");
var micros2 = /* @__PURE__ */ __name((micros3) => make45(micros3 * bigint1e32), "micros");
var millis2 = /* @__PURE__ */ __name((millis3) => make45(millis3), "millis");
var seconds2 = /* @__PURE__ */ __name((seconds3) => make45(seconds3 * 1e3), "seconds");
var minutes2 = /* @__PURE__ */ __name((minutes3) => make45(minutes3 * 6e4), "minutes");
var hours2 = /* @__PURE__ */ __name((hours3) => make45(hours3 * 36e5), "hours");
var days2 = /* @__PURE__ */ __name((days3) => make45(days3 * 864e5), "days");
var weeks2 = /* @__PURE__ */ __name((weeks3) => make45(weeks3 * 6048e5), "weeks");
var toMillis2 = /* @__PURE__ */ __name((self) => match12(self, {
  onMillis: /* @__PURE__ */ __name((millis3) => millis3, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos3) => Number(nanos3) / 1e6, "onNanos")
}), "toMillis");
var unsafeToNanos2 = /* @__PURE__ */ __name((self) => {
  const _self = decode2(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
}, "unsafeToNanos");
var toHrTime2 = /* @__PURE__ */ __name((self) => {
  const _self = decode2(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e92), Number(_self.value.nanos % bigint1e92)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
}, "toHrTime");
var match12 = /* @__PURE__ */ dual2(2, (self, options) => {
  const _self = decode2(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith2 = /* @__PURE__ */ dual2(3, (self, that, options) => {
  const _self = decode2(self);
  const _that = decode2(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis2(_self), toMillis2(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Equivalence2 = /* @__PURE__ */ __name((self, that) => matchWith2(self, that, {
  onMillis: /* @__PURE__ */ __name((self2, that2) => self2 === that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self2, that2) => self2 === that2, "onNanos")
}), "Equivalence");
var lessThanOrEqualTo4 = /* @__PURE__ */ dual2(2, (self, that) => matchWith2(self, that, {
  onMillis: /* @__PURE__ */ __name((self2, that2) => self2 <= that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self2, that2) => self2 <= that2, "onNanos")
}));
var greaterThanOrEqualTo4 = /* @__PURE__ */ dual2(2, (self, that) => matchWith2(self, that, {
  onMillis: /* @__PURE__ */ __name((self2, that2) => self2 >= that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self2, that2) => self2 >= that2, "onNanos")
}));
var equals4 = /* @__PURE__ */ dual2(2, (self, that) => Equivalence2(decode2(self), decode2(that)));
var parts2 = /* @__PURE__ */ __name((self) => {
  const duration = decode2(self);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos3 = unsafeToNanos2(duration);
  const ms = nanos3 / bigint1e62;
  const sec = ms / bigint1e32;
  const min5 = sec / bigint602;
  const hr = min5 / bigint602;
  const days3 = hr / bigint242;
  return {
    days: Number(days3),
    hours: Number(hr % bigint242),
    minutes: Number(min5 % bigint602),
    seconds: Number(sec % bigint602),
    millis: Number(ms % bigint1e32),
    nanos: Number(nanos3 % bigint1e62)
  };
}, "parts");
var format5 = /* @__PURE__ */ __name((self) => {
  const duration = decode2(self);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero2(duration)) {
    return "0";
  }
  const fragments = parts2(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
}, "format");

// node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE2 = 5;
var BUCKET_SIZE2 = /* @__PURE__ */ Math.pow(2, SIZE2);
var MASK2 = BUCKET_SIZE2 - 1;
var MAX_INDEX_NODE2 = BUCKET_SIZE2 / 2;
var MIN_ARRAY_NODE2 = BUCKET_SIZE2 / 4;

// node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount2(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
__name(popcount2, "popcount");
function hashFragment2(shift3, h) {
  return h >>> shift3 & MASK2;
}
__name(hashFragment2, "hashFragment");
function toBitmap2(x) {
  return 1 << x;
}
__name(toBitmap2, "toBitmap");
function fromBitmap2(bitmap, bit) {
  return popcount2(bitmap & bit - 1);
}
__name(fromBitmap2, "fromBitmap");

// node_modules/effect/dist/esm/internal/stack.js
var make46 = /* @__PURE__ */ __name((value, previous) => ({
  value,
  previous
}), "make");

// node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate2(mutate7, at, v, arr) {
  let out = arr;
  if (!mutate7) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
__name(arrayUpdate2, "arrayUpdate");
function arraySpliceOut2(mutate7, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate7) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate7) {
    out.length = newLen;
  }
  return out;
}
__name(arraySpliceOut2, "arraySpliceOut");
function arraySpliceIn2(mutate7, at, v, arr) {
  const len = arr.length;
  if (mutate7) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}
__name(arraySpliceIn2, "arraySpliceIn");

// node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode2 = class _EmptyNode {
  static {
    __name(this, "EmptyNode");
  }
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash3, key, size17) {
    const v = f(none11());
    if (isNone5(v)) return new _EmptyNode();
    ++size17.value;
    return new LeafNode2(edit, hash3, key, v);
  }
};
function isEmptyNode2(a) {
  return isTagged2(a, "EmptyNode");
}
__name(isEmptyNode2, "isEmptyNode");
function isLeafNode2(node) {
  return isEmptyNode2(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
__name(isLeafNode2, "isLeafNode");
function canEditNode2(node, edit) {
  return isEmptyNode2(node) ? false : edit === node.edit;
}
__name(canEditNode2, "canEditNode");
var LeafNode2 = class _LeafNode {
  static {
    __name(this, "LeafNode");
  }
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash3, key, value) {
    this.edit = edit;
    this.hash = hash3;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift3, f, hash3, key, size17) {
    if (equals3(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone5(v2)) {
        --size17.value;
        return new EmptyNode2();
      }
      if (canEditNode2(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash3, key, v2);
    }
    const v = f(none11());
    if (isNone5(v)) return this;
    ++size17.value;
    return mergeLeaves2(edit, shift3, this.hash, this, hash3, new _LeafNode(edit, hash3, key, v));
  }
};
var CollisionNode2 = class _CollisionNode {
  static {
    __name(this, "CollisionNode");
  }
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash3, children) {
    this.edit = edit;
    this.hash = hash3;
    this.children = children;
  }
  modify(edit, shift3, f, hash3, key, size17) {
    if (hash3 === this.hash) {
      const canEdit = canEditNode2(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size17);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none11());
    if (isNone5(v)) return this;
    ++size17.value;
    return mergeLeaves2(edit, shift3, this.hash, this, hash3, new LeafNode2(edit, hash3, key, v));
  }
  updateCollisionList(mutate7, edit, hash3, list, f, key, size17) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals3(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value) return list;
        if (isNone5(newValue2)) {
          --size17.value;
          return arraySpliceOut2(mutate7, i, list);
        }
        return arrayUpdate2(mutate7, i, new LeafNode2(edit, hash3, key, newValue2), list);
      }
    }
    const newValue = f(none11());
    if (isNone5(newValue)) return list;
    ++size17.value;
    return arrayUpdate2(mutate7, len, new LeafNode2(edit, hash3, key, newValue), list);
  }
};
var IndexedNode2 = class _IndexedNode {
  static {
    __name(this, "IndexedNode");
  }
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift3, f, hash3, key, size17) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment2(shift3, hash3);
    const bit = toBitmap2(frag);
    const indx = fromBitmap2(mask, bit);
    const exists5 = mask & bit;
    const canEdit = canEditNode2(this, edit);
    if (!exists5) {
      const _newChild = new EmptyNode2().modify(edit, shift3 + SIZE2, f, hash3, key, size17);
      if (!_newChild) return this;
      return children.length >= MAX_INDEX_NODE2 ? expand2(edit, frag, _newChild, mask, children) : new _IndexedNode(edit, mask | bit, arraySpliceIn2(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift3 + SIZE2, f, hash3, key, size17);
    if (current === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode2(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode2();
      if (children.length <= 2 && isLeafNode2(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut2(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate2(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode2 = class _ArrayNode {
  static {
    __name(this, "ArrayNode");
  }
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size17, children) {
    this.edit = edit;
    this.size = size17;
    this.children = children;
  }
  modify(edit, shift3, f, hash3, key, size17) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment2(shift3, hash3);
    const child = children[frag];
    const newChild = (child || new EmptyNode2()).modify(edit, shift3 + SIZE2, f, hash3, key, size17);
    if (child === newChild) return this;
    const canEdit = canEditNode2(this, edit);
    let newChildren;
    if (isEmptyNode2(child) && !isEmptyNode2(newChild)) {
      ++count;
      newChildren = arrayUpdate2(canEdit, frag, newChild, children);
    } else if (!isEmptyNode2(child) && isEmptyNode2(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE2) {
        return pack2(edit, count, frag, children);
      }
      newChildren = arrayUpdate2(canEdit, frag, new EmptyNode2(), children);
    } else {
      newChildren = arrayUpdate2(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count, newChildren);
  }
};
function pack2(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode2(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode2(edit, bitmap, children);
}
__name(pack2, "pack");
function expand2(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode2(edit, count + 1, arr);
}
__name(expand2, "expand");
function mergeLeavesInner2(edit, shift3, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode2(edit, h1, [n2, n1]);
  const subH1 = hashFragment2(shift3, h1);
  const subH2 = hashFragment2(shift3, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode2(edit, toBitmap2(subH1) | toBitmap2(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode2(edit, toBitmap2(subH1) | toBitmap2(subH2), children);
  }
}
__name(mergeLeavesInner2, "mergeLeavesInner");
function mergeLeaves2(edit, shift3, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift3;
  while (true) {
    const res = mergeLeavesInner2(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make46(res, stack);
      currentShift = currentShift + SIZE2;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}
__name(mergeLeaves2, "mergeLeaves");

// node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey2 = "effect/HashMap";
var HashMapTypeId2 = /* @__PURE__ */ Symbol.for(HashMapSymbolKey2);
var HashMapProto2 = {
  [HashMapTypeId2]: HashMapTypeId2,
  [Symbol.iterator]() {
    return new HashMapIterator2(this, (k, v) => [k, v]);
  },
  [symbol3]() {
    let hash3 = hash2(HashMapSymbolKey2);
    for (const item of this) {
      hash3 ^= pipe2(hash2(item[0]), combine9(hash2(item[1])));
    }
    return cached4(this, hash3);
  },
  [symbol4](that) {
    if (isHashMap2(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe2(that, getHash2(item[0], hash2(item[0])));
        if (isNone5(elem)) {
          return false;
        } else {
          if (!equals3(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var makeImpl4 = /* @__PURE__ */ __name((editable, edit, root, size17) => {
  const map23 = Object.create(HashMapProto2);
  map23._editable = editable;
  map23._edit = edit;
  map23._root = root;
  map23._size = size17;
  return map23;
}, "makeImpl");
var HashMapIterator2 = class _HashMapIterator {
  static {
    __name(this, "HashMapIterator");
  }
  map;
  f;
  v;
  constructor(map23, f) {
    this.map = map23;
    this.f = f;
    this.v = visitLazy2(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone5(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont2(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont2 = /* @__PURE__ */ __name((cont) => cont ? visitLazyChildren2(cont[0], cont[1], cont[2], cont[3], cont[4]) : none11(), "applyCont");
var visitLazy2 = /* @__PURE__ */ __name((node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome4(node.value)) {
        return some6({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont2(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren2(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont2(cont);
    }
  }
}, "visitLazy");
var visitLazyChildren2 = /* @__PURE__ */ __name((len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode2(child)) {
      return visitLazy2(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont2(cont);
}, "visitLazyChildren");
var _empty10 = /* @__PURE__ */ makeImpl4(false, 0, /* @__PURE__ */ new EmptyNode2(), 0);
var empty33 = /* @__PURE__ */ __name(() => _empty10, "empty");
var fromIterable13 = /* @__PURE__ */ __name((entries3) => {
  const map23 = beginMutation3(empty33());
  for (const entry of entries3) {
    set6(map23, entry[0], entry[1]);
  }
  return endMutation3(map23);
}, "fromIterable");
var isHashMap2 = /* @__PURE__ */ __name((u) => hasProperty2(u, HashMapTypeId2), "isHashMap");
var isEmpty10 = /* @__PURE__ */ __name((self) => self && isEmptyNode2(self._root), "isEmpty");
var get17 = /* @__PURE__ */ dual2(2, (self, key) => getHash2(self, key, hash2(key)));
var getHash2 = /* @__PURE__ */ dual2(3, (self, key, hash3) => {
  let node = self._root;
  let shift3 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals3(key, node.key) ? node.value : none11();
      }
      case "CollisionNode": {
        if (hash3 === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length; i < len; ++i) {
            const child = children[i];
            if ("key" in child && equals3(key, child.key)) {
              return child.value;
            }
          }
        }
        return none11();
      }
      case "IndexedNode": {
        const frag = hashFragment2(shift3, hash3);
        const bit = toBitmap2(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap2(node.mask, bit)];
          shift3 += SIZE2;
          break;
        }
        return none11();
      }
      case "ArrayNode": {
        node = node.children[hashFragment2(shift3, hash3)];
        if (node) {
          shift3 += SIZE2;
          break;
        }
        return none11();
      }
      default:
        return none11();
    }
  }
});
var has7 = /* @__PURE__ */ dual2(2, (self, key) => isSome4(getHash2(self, key, hash2(key))));
var set6 = /* @__PURE__ */ dual2(3, (self, key, value) => modifyAt3(self, key, () => some6(value)));
var setTree2 = /* @__PURE__ */ dual2(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl4(self._editable, self._edit, newRoot, newSize);
});
var keys5 = /* @__PURE__ */ __name((self) => new HashMapIterator2(self, (key) => key), "keys");
var size9 = /* @__PURE__ */ __name((self) => self._size, "size");
var beginMutation3 = /* @__PURE__ */ __name((self) => makeImpl4(true, self._edit + 1, self._root, self._size), "beginMutation");
var endMutation3 = /* @__PURE__ */ __name((self) => {
  ;
  self._editable = false;
  return self;
}, "endMutation");
var mutate4 = /* @__PURE__ */ dual2(2, (self, f) => {
  const transient = beginMutation3(self);
  f(transient);
  return endMutation3(transient);
});
var modifyAt3 = /* @__PURE__ */ dual2(3, (self, key, f) => modifyHash2(self, key, hash2(key), f));
var modifyHash2 = /* @__PURE__ */ dual2(4, (self, key, hash3, f) => {
  const size17 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash3, key, size17);
  return pipe2(self, setTree2(newRoot, size17.value));
});
var remove9 = /* @__PURE__ */ dual2(2, (self, key) => modifyAt3(self, key, none11));
var map14 = /* @__PURE__ */ dual2(2, (self, f) => reduce12(self, empty33(), (map23, value, key) => set6(map23, key, f(value, key))));
var forEach9 = /* @__PURE__ */ dual2(2, (self, f) => reduce12(self, void 0, (_, value, key) => f(value, key)));
var reduce12 = /* @__PURE__ */ dual2(3, (self, zero3, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome4(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length; i < len; ) {
      const child = children[i++];
      if (child && !isEmptyNode2(child)) {
        if (child._tag === "LeafNode") {
          if (isSome4(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});

// node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey2 = "effect/HashSet";
var HashSetTypeId2 = /* @__PURE__ */ Symbol.for(HashSetSymbolKey2);
var HashSetProto2 = {
  [HashSetTypeId2]: HashSetTypeId2,
  [Symbol.iterator]() {
    return keys5(this._keyMap);
  },
  [symbol3]() {
    return cached4(this, combine9(hash2(this._keyMap))(hash2(HashSetSymbolKey2)));
  },
  [symbol4](that) {
    if (isHashSet2(that)) {
      return size9(this._keyMap) === size9(that._keyMap) && equals3(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var makeImpl5 = /* @__PURE__ */ __name((keyMap) => {
  const set11 = Object.create(HashSetProto2);
  set11._keyMap = keyMap;
  return set11;
}, "makeImpl");
var isHashSet2 = /* @__PURE__ */ __name((u) => hasProperty2(u, HashSetTypeId2), "isHashSet");
var _empty11 = /* @__PURE__ */ makeImpl5(/* @__PURE__ */ empty33());
var empty34 = /* @__PURE__ */ __name(() => _empty11, "empty");
var fromIterable14 = /* @__PURE__ */ __name((elements) => {
  const set11 = beginMutation4(empty34());
  for (const value of elements) {
    add8(set11, value);
  }
  return endMutation4(set11);
}, "fromIterable");
var make47 = /* @__PURE__ */ __name((...elements) => {
  const set11 = beginMutation4(empty34());
  for (const value of elements) {
    add8(set11, value);
  }
  return endMutation4(set11);
}, "make");
var has8 = /* @__PURE__ */ dual2(2, (self, value) => has7(self._keyMap, value));
var size10 = /* @__PURE__ */ __name((self) => size9(self._keyMap), "size");
var beginMutation4 = /* @__PURE__ */ __name((self) => makeImpl5(beginMutation3(self._keyMap)), "beginMutation");
var endMutation4 = /* @__PURE__ */ __name((self) => {
  ;
  self._keyMap._editable = false;
  return self;
}, "endMutation");
var mutate5 = /* @__PURE__ */ dual2(2, (self, f) => {
  const transient = beginMutation4(self);
  f(transient);
  return endMutation4(transient);
});
var add8 = /* @__PURE__ */ dual2(2, (self, value) => self._keyMap._editable ? (set6(value, true)(self._keyMap), self) : makeImpl5(set6(value, true)(self._keyMap)));
var remove10 = /* @__PURE__ */ dual2(2, (self, value) => self._keyMap._editable ? (remove9(value)(self._keyMap), self) : makeImpl5(remove9(value)(self._keyMap)));
var difference5 = /* @__PURE__ */ dual2(2, (self, that) => mutate5(self, (set11) => {
  for (const value of that) {
    remove10(set11, value);
  }
}));
var union9 = /* @__PURE__ */ dual2(2, (self, that) => mutate5(empty34(), (set11) => {
  forEach10(self, (value) => add8(set11, value));
  for (const value of that) {
    add8(set11, value);
  }
}));
var forEach10 = /* @__PURE__ */ dual2(2, (self, f) => forEach9(self._keyMap, (_, k) => f(k)));
var reduce13 = /* @__PURE__ */ dual2(3, (self, zero3, f) => reduce12(self._keyMap, zero3, (z, _, a) => f(z, a)));

// node_modules/effect/dist/esm/HashSet.js
var empty35 = empty34;
var fromIterable15 = fromIterable14;
var make48 = make47;
var has9 = has8;
var size11 = size10;
var add9 = add8;
var remove11 = remove10;
var difference6 = difference5;
var union10 = union9;
var reduce14 = reduce13;

// node_modules/effect/dist/esm/MutableRef.js
var TypeId21 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto2 = {
  [TypeId21]: TypeId21,
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON2(this.current)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var make49 = /* @__PURE__ */ __name((value) => {
  const ref = Object.create(MutableRefProto2);
  ref.current = value;
  return ref;
}, "make");
var compareAndSet2 = /* @__PURE__ */ dual2(3, (self, oldValue, newValue) => {
  if (equals3(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var get18 = /* @__PURE__ */ __name((self) => self.current, "get");
var set7 = /* @__PURE__ */ dual2(2, (self, value) => {
  self.current = value;
  return self;
});

// node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey2 = "effect/FiberId";
var FiberIdTypeId2 = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey2);
var OP_NONE2 = "None";
var OP_RUNTIME2 = "Runtime";
var OP_COMPOSITE2 = "Composite";
var emptyHash2 = /* @__PURE__ */ string2(`${FiberIdSymbolKey2}-${OP_NONE2}`);
var None4 = class {
  static {
    __name(this, "None");
  }
  [FiberIdTypeId2] = FiberIdTypeId2;
  _tag = OP_NONE2;
  id = -1;
  startTimeMillis = -1;
  [symbol3]() {
    return emptyHash2;
  }
  [symbol4](that) {
    return isFiberId2(that) && that._tag === OP_NONE2;
  }
  toString() {
    return format4(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
};
var Runtime2 = class {
  static {
    __name(this, "Runtime");
  }
  id;
  startTimeMillis;
  [FiberIdTypeId2] = FiberIdTypeId2;
  _tag = OP_RUNTIME2;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol3]() {
    return cached4(this, string2(`${FiberIdSymbolKey2}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol4](that) {
    return isFiberId2(that) && that._tag === OP_RUNTIME2 && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format4(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
};
var Composite2 = class {
  static {
    __name(this, "Composite");
  }
  left;
  right;
  [FiberIdTypeId2] = FiberIdTypeId2;
  _tag = OP_COMPOSITE2;
  constructor(left5, right5) {
    this.left = left5;
    this.right = right5;
  }
  _hash;
  [symbol3]() {
    return pipe2(string2(`${FiberIdSymbolKey2}-${this._tag}`), combine9(hash2(this.left)), combine9(hash2(this.right)), cached4(this));
  }
  [symbol4](that) {
    return isFiberId2(that) && that._tag === OP_COMPOSITE2 && equals3(this.left, that.left) && equals3(this.right, that.right);
  }
  toString() {
    return format4(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON2(this.left),
      right: toJSON2(this.right)
    };
  }
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
};
var none12 = /* @__PURE__ */ new None4();
var isFiberId2 = /* @__PURE__ */ __name((self) => hasProperty2(self, FiberIdTypeId2), "isFiberId");
var combine10 = /* @__PURE__ */ dual2(2, (self, that) => {
  if (self._tag === OP_NONE2) {
    return that;
  }
  if (that._tag === OP_NONE2) {
    return self;
  }
  return new Composite2(self, that);
});
var ids3 = /* @__PURE__ */ __name((self) => {
  switch (self._tag) {
    case OP_NONE2: {
      return empty35();
    }
    case OP_RUNTIME2: {
      return make48(self.id);
    }
    case OP_COMPOSITE2: {
      return pipe2(ids3(self.left), union10(ids3(self.right)));
    }
  }
}, "ids");
var _fiberCounter2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make49(0));
var threadName3 = /* @__PURE__ */ __name((self) => {
  const identifiers = Array.from(ids3(self)).map((n) => `#${n}`).join(",");
  return identifiers;
}, "threadName");
var unsafeMake8 = /* @__PURE__ */ __name(() => {
  const id = get18(_fiberCounter2);
  pipe2(_fiberCounter2, set7(id + 1));
  return new Runtime2(id, Date.now());
}, "unsafeMake");

// node_modules/effect/dist/esm/FiberId.js
var none13 = none12;
var combine11 = combine10;
var threadName4 = threadName3;
var unsafeMake9 = unsafeMake8;

// node_modules/effect/dist/esm/HashMap.js
var empty36 = empty33;
var fromIterable16 = fromIterable13;
var isEmpty11 = isEmpty10;
var get19 = get17;
var set8 = set6;
var keys6 = keys5;
var mutate6 = mutate4;
var modifyAt4 = modifyAt3;
var map16 = map14;
var forEach11 = forEach9;
var reduce15 = reduce12;

// node_modules/effect/dist/esm/List.js
var TypeId22 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray4 = /* @__PURE__ */ __name((self) => fromIterable11(self), "toArray");
var getEquivalence6 = /* @__PURE__ */ __name((isEquivalent) => mapInput3(getEquivalence4(isEquivalent), toArray4), "getEquivalence");
var _equivalence8 = /* @__PURE__ */ getEquivalence6(equals3);
var ConsProto2 = {
  [TypeId22]: TypeId22,
  _tag: "Cons",
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray4(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  [symbol4](that) {
    return isList2(that) && this._tag === that._tag && _equivalence8(this, that);
  },
  [symbol3]() {
    return cached4(this, array5(toArray4(this)));
  },
  [Symbol.iterator]() {
    let done13 = false;
    let self = this;
    return {
      next() {
        if (done13) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done13 = true;
          return this.return();
        }
        const value = self.head;
        self = self.tail;
        return {
          done: done13,
          value
        };
      },
      return(value) {
        if (!done13) {
          done13 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var makeCons2 = /* @__PURE__ */ __name((head9, tail) => {
  const cons3 = Object.create(ConsProto2);
  cons3.head = head9;
  cons3.tail = tail;
  return cons3;
}, "makeCons");
var NilHash2 = /* @__PURE__ */ string2("Nil");
var NilProto2 = {
  [TypeId22]: TypeId22,
  _tag: "Nil",
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  [symbol3]() {
    return NilHash2;
  },
  [symbol4](that) {
    return isList2(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var _Nil2 = /* @__PURE__ */ Object.create(NilProto2);
var isList2 = /* @__PURE__ */ __name((u) => hasProperty2(u, TypeId22), "isList");
var isNil2 = /* @__PURE__ */ __name((self) => self._tag === "Nil", "isNil");
var isCons2 = /* @__PURE__ */ __name((self) => self._tag === "Cons", "isCons");
var nil2 = /* @__PURE__ */ __name(() => _Nil2, "nil");
var cons2 = /* @__PURE__ */ __name((head9, tail) => makeCons2(head9, tail), "cons");
var empty37 = nil2;
var of7 = /* @__PURE__ */ __name((value) => makeCons2(value, _Nil2), "of");
var appendAll6 = /* @__PURE__ */ dual2(2, (self, that) => prependAll2(that, self));
var prepend6 = /* @__PURE__ */ dual2(2, (self, element) => cons2(element, self));
var prependAll2 = /* @__PURE__ */ dual2(2, (self, prefix) => {
  if (isNil2(self)) {
    return prefix;
  } else if (isNil2(prefix)) {
    return self;
  } else {
    const result = makeCons2(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil2(that)) {
      const temp = makeCons2(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce16 = /* @__PURE__ */ dual2(3, (self, zero3, f) => {
  let acc = zero3;
  let these = self;
  while (!isNil2(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse6 = /* @__PURE__ */ __name((self) => {
  let result = empty37();
  let these = self;
  while (!isNil2(these)) {
    result = prepend6(result, these.head);
    these = these.tail;
  }
  return result;
}, "reverse");

// node_modules/effect/dist/esm/internal/data.js
var ArrayProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol3]() {
    return cached4(this, array5(this));
  },
  [symbol4](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals3(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural3 = /* @__PURE__ */ (function() {
  function Structural4(args3) {
    if (args3) {
      Object.assign(this, args3);
    }
  }
  __name(Structural4, "Structural");
  Structural4.prototype = StructuralPrototype2;
  return Structural4;
})();
var struct3 = /* @__PURE__ */ __name((as7) => Object.assign(Object.create(StructuralPrototype2), as7), "struct");

// node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId2 = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance5(a) {
  return a;
}
__name(variance5, "variance");
var PatchProto4 = {
  ...Structural3.prototype,
  [ContextPatchTypeId2]: {
    _Value: variance5,
    _Patch: variance5
  }
};
var EmptyProto4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty12 = /* @__PURE__ */ Object.create(EmptyProto4);
var empty38 = /* @__PURE__ */ __name(() => _empty12, "empty");
var AndThenProto4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen4 = /* @__PURE__ */ __name((first3, second) => {
  const o = Object.create(AndThenProto4);
  o.first = first3;
  o.second = second;
  return o;
}, "makeAndThen");
var AddServiceProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "AddService"
});
var makeAddService2 = /* @__PURE__ */ __name((key, service) => {
  const o = Object.create(AddServiceProto2);
  o.key = key;
  o.service = service;
  return o;
}, "makeAddService");
var RemoveServiceProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "RemoveService"
});
var makeRemoveService2 = /* @__PURE__ */ __name((key) => {
  const o = Object.create(RemoveServiceProto2);
  o.key = key;
  return o;
}, "makeRemoveService");
var UpdateServiceProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "UpdateService"
});
var makeUpdateService2 = /* @__PURE__ */ __name((key, update9) => {
  const o = Object.create(UpdateServiceProto2);
  o.key = key;
  o.update = update9;
  return o;
}, "makeUpdateService");
var diff8 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch17 = empty38();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals3(old, newService)) {
        patch17 = combine12(makeUpdateService2(tag, () => newService))(patch17);
      }
    } else {
      missingServices.delete(tag);
      patch17 = combine12(makeAddService2(tag, newService))(patch17);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch17 = combine12(makeRemoveService2(tag))(patch17);
  }
  return patch17;
}, "diff");
var combine12 = /* @__PURE__ */ dual2(2, (self, that) => makeAndThen4(self, that));
var patch9 = /* @__PURE__ */ dual2(2, (self, context7) => {
  if (self._tag === "Empty") {
    return context7;
  }
  let wasServiceUpdated = false;
  let patches = of6(self);
  const updatedContext = new Map(context7.unsafeMap);
  while (isNonEmpty5(patches)) {
    const head9 = headNonEmpty4(patches);
    const tail = tailNonEmpty4(patches);
    switch (head9._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head9.key, head9.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend5(prepend5(tail, head9.second), head9.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head9.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head9.key, head9.update(updatedContext.get(head9.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext2(updatedContext);
  }
  const map23 = /* @__PURE__ */ new Map();
  for (const [tag] of context7.unsafeMap) {
    if (updatedContext.has(tag)) {
      map23.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s] of updatedContext) {
    map23.set(tag, s);
  }
  return makeContext2(map23);
});

// node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId2 = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance6(a) {
  return a;
}
__name(variance6, "variance");
var PatchProto5 = {
  ...Structural3.prototype,
  [HashSetPatchTypeId2]: {
    _Value: variance6,
    _Key: variance6,
    _Patch: variance6
  }
};
var EmptyProto5 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto5), {
  _tag: "Empty"
});
var _empty13 = /* @__PURE__ */ Object.create(EmptyProto5);
var empty39 = /* @__PURE__ */ __name(() => _empty13, "empty");
var AndThenProto5 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto5), {
  _tag: "AndThen"
});
var makeAndThen5 = /* @__PURE__ */ __name((first3, second) => {
  const o = Object.create(AndThenProto5);
  o.first = first3;
  o.second = second;
  return o;
}, "makeAndThen");
var AddProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto5), {
  _tag: "Add"
});
var makeAdd2 = /* @__PURE__ */ __name((value) => {
  const o = Object.create(AddProto2);
  o.value = value;
  return o;
}, "makeAdd");
var RemoveProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto5), {
  _tag: "Remove"
});
var makeRemove2 = /* @__PURE__ */ __name((value) => {
  const o = Object.create(RemoveProto2);
  o.value = value;
  return o;
}, "makeRemove");
var diff9 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const [removed, patch17] = reduce14([oldValue, empty39()], ([set11, patch18], value) => {
    if (has9(value)(set11)) {
      return [remove11(value)(set11), patch18];
    }
    return [set11, combine13(makeAdd2(value))(patch18)];
  })(newValue);
  return reduce14(patch17, (patch18, value) => combine13(makeRemove2(value))(patch18))(removed);
}, "diff");
var combine13 = /* @__PURE__ */ dual2(2, (self, that) => makeAndThen5(self, that));
var patch10 = /* @__PURE__ */ dual2(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set11 = oldValue;
  let patches = of6(self);
  while (isNonEmpty5(patches)) {
    const head9 = headNonEmpty4(patches);
    const tail = tailNonEmpty4(patches);
    switch (head9._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend5(head9.first)(prepend5(head9.second)(tail));
        break;
      }
      case "Add": {
        set11 = add9(head9.value)(set11);
        patches = tail;
        break;
      }
      case "Remove": {
        set11 = remove11(head9.value)(set11);
        patches = tail;
      }
    }
  }
  return set11;
});

// node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId2 = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance7(a) {
  return a;
}
__name(variance7, "variance");
var PatchProto6 = {
  ...Structural3.prototype,
  [ReadonlyArrayPatchTypeId2]: {
    _Value: variance7,
    _Patch: variance7
  }
};
var EmptyProto6 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty14 = /* @__PURE__ */ Object.create(EmptyProto6);
var empty40 = /* @__PURE__ */ __name(() => _empty14, "empty");
var AndThenProto6 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen6 = /* @__PURE__ */ __name((first3, second) => {
  const o = Object.create(AndThenProto6);
  o.first = first3;
  o.second = second;
  return o;
}, "makeAndThen");
var AppendProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend2 = /* @__PURE__ */ __name((values5) => {
  const o = Object.create(AppendProto2);
  o.values = values5;
  return o;
}, "makeAppend");
var SliceProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice2 = /* @__PURE__ */ __name((from, until) => {
  const o = Object.create(SliceProto2);
  o.from = from;
  o.until = until;
  return o;
}, "makeSlice");
var UpdateProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate2 = /* @__PURE__ */ __name((index, patch17) => {
  const o = Object.create(UpdateProto2);
  o.index = index;
  o.patch = patch17;
  return o;
}, "makeUpdate");
var diff10 = /* @__PURE__ */ __name((options) => {
  let i = 0;
  let patch17 = empty40();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals3(valuePatch, options.differ.empty)) {
      patch17 = combine14(patch17, makeUpdate2(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch17 = combine14(patch17, makeSlice2(0, i));
  }
  if (i < options.newValue.length) {
    patch17 = combine14(patch17, makeAppend2(drop3(i)(options.newValue)));
  }
  return patch17;
}, "diff");
var combine14 = /* @__PURE__ */ dual2(2, (self, that) => makeAndThen6(self, that));
var patch11 = /* @__PURE__ */ dual2(3, (self, oldValue, differ5) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray3 = oldValue.slice();
  let patches = of5(self);
  while (isNonEmptyArray4(patches)) {
    const head9 = headNonEmpty3(patches);
    const tail = tailNonEmpty3(patches);
    switch (head9._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head9.first, head9.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value of head9.values) {
          readonlyArray3.push(value);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray3 = readonlyArray3.slice(head9.from, head9.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray3[head9.index] = differ5.patch(head9.patch, readonlyArray3[head9.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray3;
});

// node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId2 = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto2 = {
  [DifferTypeId2]: {
    _P: identity2,
    _V: identity2
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var make52 = /* @__PURE__ */ __name((params) => {
  const differ5 = Object.create(DifferProto2);
  differ5.empty = params.empty;
  differ5.diff = params.diff;
  differ5.combine = params.combine;
  differ5.patch = params.patch;
  return differ5;
}, "make");
var environment2 = /* @__PURE__ */ __name(() => make52({
  empty: empty38(),
  combine: /* @__PURE__ */ __name((first3, second) => combine12(second)(first3), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff8(oldValue, newValue), "diff"),
  patch: /* @__PURE__ */ __name((patch17, oldValue) => patch9(oldValue)(patch17), "patch")
}), "environment");
var hashSet2 = /* @__PURE__ */ __name(() => make52({
  empty: empty39(),
  combine: /* @__PURE__ */ __name((first3, second) => combine13(second)(first3), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff9(oldValue, newValue), "diff"),
  patch: /* @__PURE__ */ __name((patch17, oldValue) => patch10(oldValue)(patch17), "patch")
}), "hashSet");
var readonlyArray2 = /* @__PURE__ */ __name((differ5) => make52({
  empty: empty40(),
  combine: /* @__PURE__ */ __name((first3, second) => combine14(first3, second), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff10({
    oldValue,
    newValue,
    differ: differ5
  }), "diff"),
  patch: /* @__PURE__ */ __name((patch17, oldValue) => patch11(patch17, oldValue, differ5), "patch")
}), "readonlyArray");
var update5 = /* @__PURE__ */ __name(() => updateWith2((_, a) => a), "update");
var updateWith2 = /* @__PURE__ */ __name((f) => make52({
  empty: identity2,
  combine: /* @__PURE__ */ __name((first3, second) => {
    if (first3 === identity2) {
      return second;
    }
    if (second === identity2) {
      return first3;
    }
    return (a) => second(first3(a));
  }, "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => {
    if (equals3(oldValue, newValue)) {
      return identity2;
    }
    return constant2(newValue);
  }, "diff"),
  patch: /* @__PURE__ */ __name((patch17, oldValue) => f(oldValue, patch17(oldValue)), "patch")
}), "updateWith");

// node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK2 = 255;
var BIT_SHIFT2 = 8;
var active2 = /* @__PURE__ */ __name((patch17) => patch17 & BIT_MASK2, "active");
var enabled2 = /* @__PURE__ */ __name((patch17) => patch17 >> BIT_SHIFT2 & BIT_MASK2, "enabled");
var make53 = /* @__PURE__ */ __name((active3, enabled3) => (active3 & BIT_MASK2) + ((enabled3 & active3 & BIT_MASK2) << BIT_SHIFT2), "make");
var empty41 = /* @__PURE__ */ make53(0, 0);
var enable4 = /* @__PURE__ */ __name((flag) => make53(flag, flag), "enable");
var disable4 = /* @__PURE__ */ __name((flag) => make53(flag, 0), "disable");
var exclude3 = /* @__PURE__ */ dual2(2, (self, flag) => make53(active2(self) & ~flag, enabled2(self)));
var andThen4 = /* @__PURE__ */ dual2(2, (self, that) => self | that);
var invert2 = /* @__PURE__ */ __name((n) => ~n >>> 0 & BIT_MASK2, "invert");

// node_modules/effect/dist/esm/internal/runtimeFlags.js
var None5 = 0;
var Interruption2 = 1 << 0;
var OpSupervision2 = 1 << 1;
var RuntimeMetrics2 = 1 << 2;
var WindDown2 = 1 << 4;
var CooperativeYielding2 = 1 << 5;
var cooperativeYielding2 = /* @__PURE__ */ __name((self) => isEnabled3(self, CooperativeYielding2), "cooperativeYielding");
var disable5 = /* @__PURE__ */ dual2(2, (self, flag) => self & ~flag);
var enable5 = /* @__PURE__ */ dual2(2, (self, flag) => self | flag);
var interruptible5 = /* @__PURE__ */ __name((self) => interruption2(self) && !windDown2(self), "interruptible");
var interruption2 = /* @__PURE__ */ __name((self) => isEnabled3(self, Interruption2), "interruption");
var isEnabled3 = /* @__PURE__ */ dual2(2, (self, flag) => (self & flag) !== 0);
var make54 = /* @__PURE__ */ __name((...flags) => flags.reduce((a, b) => a | b, 0), "make");
var none14 = /* @__PURE__ */ make54(None5);
var runtimeMetrics2 = /* @__PURE__ */ __name((self) => isEnabled3(self, RuntimeMetrics2), "runtimeMetrics");
var windDown2 = /* @__PURE__ */ __name((self) => isEnabled3(self, WindDown2), "windDown");
var diff11 = /* @__PURE__ */ dual2(2, (self, that) => make53(self ^ that, that));
var patch12 = /* @__PURE__ */ dual2(2, (self, patch17) => self & (invert2(active2(patch17)) | enabled2(patch17)) | active2(patch17) & enabled2(patch17));
var differ3 = /* @__PURE__ */ make52({
  empty: empty41,
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff11(oldValue, newValue), "diff"),
  combine: /* @__PURE__ */ __name((first3, second) => andThen4(second)(first3), "combine"),
  patch: /* @__PURE__ */ __name((_patch, oldValue) => patch12(oldValue, _patch), "patch")
});

// node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty42 = empty41;
var enable6 = enable4;
var disable6 = disable4;
var exclude4 = exclude3;

// node_modules/effect/dist/esm/internal/blockedRequests.js
var empty43 = {
  _tag: "Empty"
};
var par2 = /* @__PURE__ */ __name((self, that) => ({
  _tag: "Par",
  left: self,
  right: that
}), "par");
var seq2 = /* @__PURE__ */ __name((self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
}), "seq");
var single2 = /* @__PURE__ */ __name((dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
}), "single");
var flatten8 = /* @__PURE__ */ __name((self) => {
  let current = of7(self);
  let updated = empty37();
  while (1) {
    const [parallel7, sequential7] = reduce16(current, [parallelCollectionEmpty2(), empty37()], ([parallel8, sequential8], blockedRequest) => {
      const [par3, seq3] = step4(blockedRequest);
      return [parallelCollectionCombine2(parallel8, par3), appendAll6(sequential8, seq3)];
    });
    updated = merge10(updated, parallel7);
    if (isNil2(sequential7)) {
      return reverse6(updated);
    }
    current = sequential7;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "flatten");
var step4 = /* @__PURE__ */ __name((requests) => {
  let current = requests;
  let parallel7 = parallelCollectionEmpty2();
  let stack = empty37();
  let sequential7 = empty37();
  while (1) {
    switch (current._tag) {
      case "Empty": {
        if (isNil2(stack)) {
          return [parallel7, sequential7];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons2(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left5 = current.left;
        const right5 = current.right;
        switch (left5._tag) {
          case "Empty": {
            current = right5;
            break;
          }
          case "Par": {
            const l = left5.left;
            const r = left5.right;
            current = par2(seq2(l, right5), seq2(r, right5));
            break;
          }
          case "Seq": {
            const l = left5.left;
            const r = left5.right;
            current = seq2(l, seq2(r, right5));
            break;
          }
          case "Single": {
            current = left5;
            sequential7 = cons2(right5, sequential7);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel7 = parallelCollectionAdd2(parallel7, current);
        if (isNil2(stack)) {
          return [parallel7, sequential7];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "step");
var merge10 = /* @__PURE__ */ __name((sequential7, parallel7) => {
  if (isNil2(sequential7)) {
    return of7(parallelCollectionToSequentialCollection2(parallel7));
  }
  if (parallelCollectionIsEmpty2(parallel7)) {
    return sequential7;
  }
  const seqHeadKeys = sequentialCollectionKeys2(sequential7.head);
  const parKeys = parallelCollectionKeys2(parallel7);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals3(seqHeadKeys[0], parKeys[0])) {
    return cons2(sequentialCollectionCombine2(sequential7.head, parallelCollectionToSequentialCollection2(parallel7)), sequential7.tail);
  }
  return cons2(parallelCollectionToSequentialCollection2(parallel7), sequential7);
}, "merge");
var EntryTypeId2 = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
var EntryImpl2 = class {
  static {
    __name(this, "EntryImpl");
  }
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId2] = blockedRequestVariance2;
  constructor(request3, result, listeners, ownerId, state) {
    this.request = request3;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
var blockedRequestVariance2 = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var makeEntry2 = /* @__PURE__ */ __name((options) => new EntryImpl2(options.request, options.result, options.listeners, options.ownerId, options.state), "makeEntry");
var RequestBlockParallelTypeId2 = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance2 = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var ParallelImpl2 = class {
  static {
    __name(this, "ParallelImpl");
  }
  map;
  [RequestBlockParallelTypeId2] = parallelVariance2;
  constructor(map23) {
    this.map = map23;
  }
};
var parallelCollectionEmpty2 = /* @__PURE__ */ __name(() => new ParallelImpl2(empty36()), "parallelCollectionEmpty");
var parallelCollectionAdd2 = /* @__PURE__ */ __name((self, blockedRequest) => new ParallelImpl2(modifyAt4(self.map, blockedRequest.dataSource, (_) => orElseSome2(map12(_, append5(blockedRequest.blockedRequest)), () => of6(blockedRequest.blockedRequest)))), "parallelCollectionAdd");
var parallelCollectionCombine2 = /* @__PURE__ */ __name((self, that) => new ParallelImpl2(reduce15(self.map, that.map, (map23, value, key) => set8(map23, key, match11(get19(map23, key), {
  onNone: /* @__PURE__ */ __name(() => value, "onNone"),
  onSome: /* @__PURE__ */ __name((other) => appendAll5(value, other), "onSome")
})))), "parallelCollectionCombine");
var parallelCollectionIsEmpty2 = /* @__PURE__ */ __name((self) => isEmpty11(self.map), "parallelCollectionIsEmpty");
var parallelCollectionKeys2 = /* @__PURE__ */ __name((self) => Array.from(keys6(self.map)), "parallelCollectionKeys");
var parallelCollectionToSequentialCollection2 = /* @__PURE__ */ __name((self) => sequentialCollectionMake2(map16(self.map, (x) => of6(x))), "parallelCollectionToSequentialCollection");
var SequentialCollectionTypeId2 = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance2 = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var SequentialImpl2 = class {
  static {
    __name(this, "SequentialImpl");
  }
  map;
  [SequentialCollectionTypeId2] = sequentialVariance2;
  constructor(map23) {
    this.map = map23;
  }
};
var sequentialCollectionMake2 = /* @__PURE__ */ __name((map23) => new SequentialImpl2(map23), "sequentialCollectionMake");
var sequentialCollectionCombine2 = /* @__PURE__ */ __name((self, that) => new SequentialImpl2(reduce15(that.map, self.map, (map23, value, key) => set8(map23, key, match11(get19(map23, key), {
  onNone: /* @__PURE__ */ __name(() => empty32(), "onNone"),
  onSome: /* @__PURE__ */ __name((a) => appendAll5(a, value), "onSome")
})))), "sequentialCollectionCombine");
var sequentialCollectionKeys2 = /* @__PURE__ */ __name((self) => Array.from(keys6(self.map)), "sequentialCollectionKeys");
var sequentialCollectionToChunk2 = /* @__PURE__ */ __name((self) => Array.from(self.map), "sequentialCollectionToChunk");

// node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE2 = "Die";
var OP_EMPTY4 = "Empty";
var OP_FAIL3 = "Fail";
var OP_INTERRUPT2 = "Interrupt";
var OP_PARALLEL3 = "Parallel";
var OP_SEQUENTIAL3 = "Sequential";

// node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey2 = "effect/Cause";
var CauseTypeId2 = /* @__PURE__ */ Symbol.for(CauseSymbolKey2);
var variance8 = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E")
};
var proto4 = {
  [CauseTypeId2]: variance8,
  [symbol3]() {
    return pipe2(hash2(CauseSymbolKey2), combine9(hash2(flattenCause2(this))), cached4(this));
  },
  [symbol4](that) {
    return isCause2(that) && causeEquals2(this, that);
  },
  pipe() {
    return pipeArguments2(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON2(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON2(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON2(this.left),
          right: toJSON2(this.right)
        };
    }
  },
  toString() {
    return pretty2(this);
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
};
var empty44 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto4);
  o._tag = OP_EMPTY4;
  return o;
})();
var fail5 = /* @__PURE__ */ __name((error) => {
  const o = Object.create(proto4);
  o._tag = OP_FAIL3;
  o.error = error;
  return o;
}, "fail");
var die4 = /* @__PURE__ */ __name((defect) => {
  const o = Object.create(proto4);
  o._tag = OP_DIE2;
  o.defect = defect;
  return o;
}, "die");
var interrupt5 = /* @__PURE__ */ __name((fiberId5) => {
  const o = Object.create(proto4);
  o._tag = OP_INTERRUPT2;
  o.fiberId = fiberId5;
  return o;
}, "interrupt");
var parallel4 = /* @__PURE__ */ __name((left5, right5) => {
  const o = Object.create(proto4);
  o._tag = OP_PARALLEL3;
  o.left = left5;
  o.right = right5;
  return o;
}, "parallel");
var sequential4 = /* @__PURE__ */ __name((left5, right5) => {
  const o = Object.create(proto4);
  o._tag = OP_SEQUENTIAL3;
  o.left = left5;
  o.right = right5;
  return o;
}, "sequential");
var isCause2 = /* @__PURE__ */ __name((u) => hasProperty2(u, CauseTypeId2), "isCause");
var isEmptyType2 = /* @__PURE__ */ __name((self) => self._tag === OP_EMPTY4, "isEmptyType");
var isDieType2 = /* @__PURE__ */ __name((self) => self._tag === OP_DIE2, "isDieType");
var isEmpty13 = /* @__PURE__ */ __name((self) => {
  if (self._tag === OP_EMPTY4) {
    return true;
  }
  return reduce17(self, true, (acc, cause5) => {
    switch (cause5._tag) {
      case OP_EMPTY4: {
        return some6(acc);
      }
      case OP_DIE2:
      case OP_FAIL3:
      case OP_INTERRUPT2: {
        return some6(false);
      }
      default: {
        return none11();
      }
    }
  });
}, "isEmpty");
var isInterrupted2 = /* @__PURE__ */ __name((self) => isSome4(interruptOption2(self)), "isInterrupted");
var isInterruptedOnly2 = /* @__PURE__ */ __name((self) => reduceWithContext2(void 0, IsInterruptedOnlyCauseReducer2)(self), "isInterruptedOnly");
var failures2 = /* @__PURE__ */ __name((self) => reverse5(reduce17(self, empty32(), (list, cause5) => cause5._tag === OP_FAIL3 ? some6(pipe2(list, prepend5(cause5.error))) : none11())), "failures");
var defects2 = /* @__PURE__ */ __name((self) => reverse5(reduce17(self, empty32(), (list, cause5) => cause5._tag === OP_DIE2 ? some6(pipe2(list, prepend5(cause5.defect))) : none11())), "defects");
var interruptors2 = /* @__PURE__ */ __name((self) => reduce17(self, empty35(), (set11, cause5) => cause5._tag === OP_INTERRUPT2 ? some6(pipe2(set11, add9(cause5.fiberId))) : none11()), "interruptors");
var failureOption2 = /* @__PURE__ */ __name((self) => find2(self, (cause5) => cause5._tag === OP_FAIL3 ? some6(cause5.error) : none11()), "failureOption");
var failureOrCause2 = /* @__PURE__ */ __name((self) => {
  const option5 = failureOption2(self);
  switch (option5._tag) {
    case "None": {
      return right4(self);
    }
    case "Some": {
      return left4(option5.value);
    }
  }
}, "failureOrCause");
var interruptOption2 = /* @__PURE__ */ __name((self) => find2(self, (cause5) => cause5._tag === OP_INTERRUPT2 ? some6(cause5.fiberId) : none11()), "interruptOption");
var keepDefects2 = /* @__PURE__ */ __name((self) => match13(self, {
  onEmpty: none11(),
  onFail: /* @__PURE__ */ __name(() => none11(), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => some6(die4(defect)), "onDie"),
  onInterrupt: /* @__PURE__ */ __name(() => none11(), "onInterrupt"),
  onSequential: mergeWith2(sequential4),
  onParallel: mergeWith2(parallel4)
}), "keepDefects");
var keepDefectsAndElectFailures2 = /* @__PURE__ */ __name((self) => match13(self, {
  onEmpty: none11(),
  onFail: /* @__PURE__ */ __name((failure) => some6(die4(failure)), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => some6(die4(defect)), "onDie"),
  onInterrupt: /* @__PURE__ */ __name(() => none11(), "onInterrupt"),
  onSequential: mergeWith2(sequential4),
  onParallel: mergeWith2(parallel4)
}), "keepDefectsAndElectFailures");
var stripFailures2 = /* @__PURE__ */ __name((self) => match13(self, {
  onEmpty: empty44,
  onFail: /* @__PURE__ */ __name(() => empty44, "onFail"),
  onDie: die4,
  onInterrupt: interrupt5,
  onSequential: sequential4,
  onParallel: parallel4
}), "stripFailures");
var electFailures2 = /* @__PURE__ */ __name((self) => match13(self, {
  onEmpty: empty44,
  onFail: die4,
  onDie: die4,
  onInterrupt: interrupt5,
  onSequential: sequential4,
  onParallel: parallel4
}), "electFailures");
var flatMap15 = /* @__PURE__ */ dual2(2, (self, f) => match13(self, {
  onEmpty: empty44,
  onFail: /* @__PURE__ */ __name((error) => f(error), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => die4(defect), "onDie"),
  onInterrupt: /* @__PURE__ */ __name((fiberId5) => interrupt5(fiberId5), "onInterrupt"),
  onSequential: /* @__PURE__ */ __name((left5, right5) => sequential4(left5, right5), "onSequential"),
  onParallel: /* @__PURE__ */ __name((left5, right5) => parallel4(left5, right5), "onParallel")
}));
var flatten9 = /* @__PURE__ */ __name((self) => flatMap15(self, identity2), "flatten");
var causeEquals2 = /* @__PURE__ */ __name((left5, right5) => {
  let leftStack = of6(left5);
  let rightStack = of6(right5);
  while (isNonEmpty5(leftStack) && isNonEmpty5(rightStack)) {
    const [leftParallel, leftSequential] = pipe2(headNonEmpty4(leftStack), reduce17([empty35(), empty32()], ([parallel7, sequential7], cause5) => {
      const [par3, seq3] = evaluateCause2(cause5);
      return some6([pipe2(parallel7, union10(par3)), pipe2(sequential7, appendAll5(seq3))]);
    }));
    const [rightParallel, rightSequential] = pipe2(headNonEmpty4(rightStack), reduce17([empty35(), empty32()], ([parallel7, sequential7], cause5) => {
      const [par3, seq3] = evaluateCause2(cause5);
      return some6([pipe2(parallel7, union10(par3)), pipe2(sequential7, appendAll5(seq3))]);
    }));
    if (!equals3(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
}, "causeEquals");
var flattenCause2 = /* @__PURE__ */ __name((cause5) => {
  return flattenCauseLoop2(of6(cause5), empty32());
}, "flattenCause");
var flattenCauseLoop2 = /* @__PURE__ */ __name((causes, flattened) => {
  while (1) {
    const [parallel7, sequential7] = pipe2(causes, reduce11([empty35(), empty32()], ([parallel8, sequential8], cause5) => {
      const [par3, seq3] = evaluateCause2(cause5);
      return [pipe2(parallel8, union10(par3)), pipe2(sequential8, appendAll5(seq3))];
    }));
    const updated = size11(parallel7) > 0 ? pipe2(flattened, prepend5(parallel7)) : flattened;
    if (isEmpty9(sequential7)) {
      return reverse5(updated);
    }
    causes = sequential7;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage2("Cause.flattenCauseLoop"));
}, "flattenCauseLoop");
var find2 = /* @__PURE__ */ dual2(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option5 = pf(item);
    switch (option5._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL3:
          case OP_PARALLEL3: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option5;
      }
    }
  }
  return none11();
});
var evaluateCause2 = /* @__PURE__ */ __name((self) => {
  let cause5 = self;
  const stack = [];
  let _parallel = empty35();
  let _sequential = empty32();
  while (cause5 !== void 0) {
    switch (cause5._tag) {
      case OP_EMPTY4: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause5 = stack.pop();
        break;
      }
      case OP_FAIL3: {
        _parallel = add9(_parallel, make44(cause5._tag, cause5.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause5 = stack.pop();
        break;
      }
      case OP_DIE2: {
        _parallel = add9(_parallel, make44(cause5._tag, cause5.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause5 = stack.pop();
        break;
      }
      case OP_INTERRUPT2: {
        _parallel = add9(_parallel, make44(cause5._tag, cause5.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause5 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL3: {
        switch (cause5.left._tag) {
          case OP_EMPTY4: {
            cause5 = cause5.right;
            break;
          }
          case OP_SEQUENTIAL3: {
            cause5 = sequential4(cause5.left.left, sequential4(cause5.left.right, cause5.right));
            break;
          }
          case OP_PARALLEL3: {
            cause5 = parallel4(sequential4(cause5.left.left, cause5.right), sequential4(cause5.left.right, cause5.right));
            break;
          }
          default: {
            _sequential = prepend5(_sequential, cause5.right);
            cause5 = cause5.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL3: {
        stack.push(cause5.right);
        cause5 = cause5.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage2("Cause.evaluateCauseLoop"));
}, "evaluateCause");
var IsInterruptedOnlyCauseReducer2 = {
  emptyCase: constTrue2,
  failCase: constFalse2,
  dieCase: constFalse2,
  interruptCase: constTrue2,
  sequentialCase: /* @__PURE__ */ __name((_, left5, right5) => left5 && right5, "sequentialCase"),
  parallelCase: /* @__PURE__ */ __name((_, left5, right5) => left5 && right5, "parallelCase")
};
var OP_SEQUENTIAL_CASE2 = "SequentialCase";
var OP_PARALLEL_CASE2 = "ParallelCase";
var match13 = /* @__PURE__ */ dual2(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt5,
  onParallel,
  onSequential
}) => {
  return reduceWithContext2(self, void 0, {
    emptyCase: /* @__PURE__ */ __name(() => onEmpty, "emptyCase"),
    failCase: /* @__PURE__ */ __name((_, error) => onFail(error), "failCase"),
    dieCase: /* @__PURE__ */ __name((_, defect) => onDie(defect), "dieCase"),
    interruptCase: /* @__PURE__ */ __name((_, fiberId5) => onInterrupt5(fiberId5), "interruptCase"),
    sequentialCase: /* @__PURE__ */ __name((_, left5, right5) => onSequential(left5, right5), "sequentialCase"),
    parallelCase: /* @__PURE__ */ __name((_, left5, right5) => onParallel(left5, right5), "parallelCase")
  });
});
var reduce17 = /* @__PURE__ */ dual2(3, (self, zero3, pf) => {
  let accumulator = zero3;
  let cause5 = self;
  const causes = [];
  while (cause5 !== void 0) {
    const option5 = pf(accumulator, cause5);
    accumulator = isSome4(option5) ? option5.value : accumulator;
    switch (cause5._tag) {
      case OP_SEQUENTIAL3: {
        causes.push(cause5.right);
        cause5 = cause5.left;
        break;
      }
      case OP_PARALLEL3: {
        causes.push(cause5.right);
        cause5 = cause5.left;
        break;
      }
      default: {
        cause5 = void 0;
        break;
      }
    }
    if (cause5 === void 0 && causes.length > 0) {
      cause5 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext2 = /* @__PURE__ */ dual2(3, (self, context7, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause5 = input.pop();
    switch (cause5._tag) {
      case OP_EMPTY4: {
        output.push(right4(reducer.emptyCase(context7)));
        break;
      }
      case OP_FAIL3: {
        output.push(right4(reducer.failCase(context7, cause5.error)));
        break;
      }
      case OP_DIE2: {
        output.push(right4(reducer.dieCase(context7, cause5.defect)));
        break;
      }
      case OP_INTERRUPT2: {
        output.push(right4(reducer.interruptCase(context7, cause5.fiberId)));
        break;
      }
      case OP_SEQUENTIAL3: {
        input.push(cause5.right);
        input.push(cause5.left);
        output.push(left4({
          _tag: OP_SEQUENTIAL_CASE2
        }));
        break;
      }
      case OP_PARALLEL3: {
        input.push(cause5.right);
        input.push(cause5.left);
        output.push(left4({
          _tag: OP_PARALLEL_CASE2
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either7 = output.pop();
    switch (either7._tag) {
      case "Left": {
        switch (either7.left._tag) {
          case OP_SEQUENTIAL_CASE2: {
            const left5 = accumulator.pop();
            const right5 = accumulator.pop();
            const value = reducer.sequentialCase(context7, left5, right5);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE2: {
            const left5 = accumulator.pop();
            const right5 = accumulator.pop();
            const value = reducer.parallelCase(context7, left5, right5);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either7.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty2 = /* @__PURE__ */ __name((cause5, options) => {
  if (isInterruptedOnly2(cause5)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors2(cause5).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause2(e.cause, "  ")}
}`;
  }).join("\n");
}, "pretty");
var renderErrorCause2 = /* @__PURE__ */ __name((cause5, prefix) => {
  const lines = cause5.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause5.cause) {
    stack += ` {
${renderErrorCause2(cause5.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
}, "renderErrorCause");
var PrettyError2 = class _PrettyError extends globalThis.Error {
  static {
    __name(this, "PrettyError");
  }
  span = void 0;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage2(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol2 in originalError) {
        this.span = originalError[spanSymbol2];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack2(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage2 = /* @__PURE__ */ __name((u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty2(u, "toString") && isFunction4(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular2(u);
}, "prettyErrorMessage");
var locationRegex2 = /\((.*)\)/g;
var spanToTrace2 = /* @__PURE__ */ globalValue2("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack2 = /* @__PURE__ */ __name((message, stack, span3) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span3) {
    let current = span3;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace2.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex2);
          let match20 = false;
          for (const [, location] of locationMatchAll) {
            match20 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match20) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined2(current.parent);
      i++;
    }
  }
  return out.join("\n");
}, "prettyErrorStack");
var spanSymbol2 = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors2 = /* @__PURE__ */ __name((cause5) => reduceWithContext2(cause5, void 0, {
  emptyCase: /* @__PURE__ */ __name(() => [], "emptyCase"),
  dieCase: /* @__PURE__ */ __name((_, unknownError) => {
    return [new PrettyError2(unknownError)];
  }, "dieCase"),
  failCase: /* @__PURE__ */ __name((_, error) => {
    return [new PrettyError2(error)];
  }, "failCase"),
  interruptCase: /* @__PURE__ */ __name(() => [], "interruptCase"),
  parallelCase: /* @__PURE__ */ __name((_, l, r) => [...l, ...r], "parallelCase"),
  sequentialCase: /* @__PURE__ */ __name((_, l, r) => [...l, ...r], "sequentialCase")
}), "prettyErrors");

// node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING2 = "Pending";
var OP_STATE_DONE2 = "Done";

// node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey2 = "effect/Deferred";
var DeferredTypeId2 = /* @__PURE__ */ Symbol.for(DeferredSymbolKey2);
var deferredVariance2 = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var pending3 = /* @__PURE__ */ __name((joiners) => {
  return {
    _tag: OP_STATE_PENDING2,
    joiners
  };
}, "pending");
var done7 = /* @__PURE__ */ __name((effect) => {
  return {
    _tag: OP_STATE_DONE2,
    effect
  };
}, "done");

// node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen4 = class _SingleShotGen {
  static {
    __name(this, "SingleShotGen");
  }
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// node_modules/effect/dist/esm/internal/core.js
var blocked3 = /* @__PURE__ */ __name((blockedRequests, _continue5) => {
  const effect = new EffectPrimitive2("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue5;
  return effect;
}, "blocked");
var runRequestBlock3 = /* @__PURE__ */ __name((blockedRequests) => {
  const effect = new EffectPrimitive2("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
}, "runRequestBlock");
var EffectTypeId5 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags2 = class {
  static {
    __name(this, "RevertFlags");
  }
  patch;
  op;
  _op = OP_REVERT_FLAGS2;
  constructor(patch17, op) {
    this.patch = patch17;
    this.op = op;
  }
};
var EffectPrimitive2 = class {
  static {
    __name(this, "EffectPrimitive");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId5] = effectVariance2;
  constructor(_op) {
    this._op = _op;
  }
  [symbol4](that) {
    return this === that;
  }
  [symbol3]() {
    return cached4(this, random4(this));
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON2(this.effect_instruction_i0),
      effect_instruction_i1: toJSON2(this.effect_instruction_i1),
      effect_instruction_i2: toJSON2(this.effect_instruction_i2)
    };
  }
  toString() {
    return format4(this.toJSON());
  }
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen4(new YieldWrap2(this));
  }
};
var EffectPrimitiveFailure2 = class {
  static {
    __name(this, "EffectPrimitiveFailure");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId5] = effectVariance2;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol4](that) {
    return exitIsExit2(that) && that._op === "Failure" && // @ts-expect-error
    equals3(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol3]() {
    return pipe2(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine9(hash2(this.effect_instruction_i0)),
      cached4(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format4(this.toJSON());
  }
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen4(new YieldWrap2(this));
  }
};
var EffectPrimitiveSuccess2 = class {
  static {
    __name(this, "EffectPrimitiveSuccess");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId5] = effectVariance2;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol4](that) {
    return exitIsExit2(that) && that._op === "Success" && // @ts-expect-error
    equals3(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol3]() {
    return pipe2(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine9(hash2(this.effect_instruction_i0)),
      cached4(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON2(this.value)
    };
  }
  toString() {
    return format4(this.toJSON());
  }
  [NodeInspectSymbol2]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen4(new YieldWrap2(this));
  }
};
var isEffect3 = /* @__PURE__ */ __name((u) => hasProperty2(u, EffectTypeId5), "isEffect");
var withFiberRuntime3 = /* @__PURE__ */ __name((withRuntime) => {
  const effect = new EffectPrimitive2(OP_WITH_RUNTIME2);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
}, "withFiberRuntime");
var acquireUseRelease3 = /* @__PURE__ */ dual2(3, (acquire, use, release) => uninterruptibleMask4((restore) => flatMap16(acquire, (a) => flatMap16(exit4(suspend5(() => restore(use(a)))), (exit7) => {
  return suspend5(() => release(a, exit7)).pipe(matchCauseEffect4({
    onFailure: /* @__PURE__ */ __name((cause5) => {
      switch (exit7._tag) {
        case OP_FAILURE2:
          return failCause5(sequential4(exit7.effect_instruction_i0, cause5));
        case OP_SUCCESS2:
          return failCause5(cause5);
      }
    }, "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => exit7, "onSuccess")
  }));
}))));
var as4 = /* @__PURE__ */ dual2(2, (self, value) => flatMap16(self, () => succeed7(value)));
var asVoid4 = /* @__PURE__ */ __name((self) => as4(self, void 0), "asVoid");
var custom3 = /* @__PURE__ */ __name(function() {
  const wrapper = new EffectPrimitive2(OP_COMMIT2);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage2("you're not supposed to end up here"));
    }
  }
  return wrapper;
}, "custom");
var unsafeAsync2 = /* @__PURE__ */ __name((register, blockingOn = none13) => {
  const effect = new EffectPrimitive2(OP_ASYNC2);
  let cancelerRef = void 0;
  effect.effect_instruction_i0 = (resume3) => {
    cancelerRef = register(resume3);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt3(effect, (_) => isEffect3(cancelerRef) ? cancelerRef : void_3);
}, "unsafeAsync");
var asyncInterrupt2 = /* @__PURE__ */ __name((register, blockingOn = none13) => suspend5(() => unsafeAsync2(register, blockingOn)), "asyncInterrupt");
var async_2 = /* @__PURE__ */ __name((resume3, blockingOn = none13) => {
  return custom3(resume3, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect2) {
      if (backingResume) {
        backingResume(effect2);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect2;
      }
    }
    __name(proxyResume, "proxyResume");
    const effect = new EffectPrimitive2(OP_ASYNC2);
    effect.effect_instruction_i0 = (resume4) => {
      backingResume = resume4;
      if (pendingEffect) {
        resume4(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall2(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall2(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt3(effect, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_3;
    }) : effect;
  });
}, "async_");
var catchAllCause3 = /* @__PURE__ */ dual2(2, (self, f) => {
  const effect = new EffectPrimitive2(OP_ON_FAILURE2);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
var catchAll3 = /* @__PURE__ */ dual2(2, (self, f) => matchEffect3(self, {
  onFailure: f,
  onSuccess: succeed7
}));
var catchIf3 = /* @__PURE__ */ dual2(3, (self, predicate, f) => catchAllCause3(self, (cause5) => {
  const either7 = failureOrCause2(cause5);
  switch (either7._tag) {
    case "Left":
      return predicate(either7.left) ? f(either7.left) : failCause5(cause5);
    case "Right":
      return failCause5(either7.right);
  }
}));
var catchSome3 = /* @__PURE__ */ dual2(2, (self, pf) => catchAllCause3(self, (cause5) => {
  const either7 = failureOrCause2(cause5);
  switch (either7._tag) {
    case "Left":
      return pipe2(pf(either7.left), getOrElse5(() => failCause5(cause5)));
    case "Right":
      return failCause5(either7.right);
  }
}));
var checkInterruptible3 = /* @__PURE__ */ __name((f) => withFiberRuntime3((_, status) => f(interruption2(status.runtimeFlags))), "checkInterruptible");
var originalSymbol2 = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture2 = /* @__PURE__ */ __name((obj, span3) => {
  if (isSome4(span3)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol2 || p === originalSymbol2 || p in target;
      },
      get(target, p) {
        if (p === spanSymbol2) {
          return span3.value;
        }
        if (p === originalSymbol2) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
}, "capture");
var die5 = /* @__PURE__ */ __name((defect) => isObject2(defect) && !(spanSymbol2 in defect) ? withFiberRuntime3((fiber) => failCause5(die4(capture2(defect, currentSpanFromFiber2(fiber))))) : failCause5(die4(defect)), "die");
var dieMessage3 = /* @__PURE__ */ __name((message) => failCauseSync3(() => die4(new RuntimeException2(message))), "dieMessage");
var dieSync3 = /* @__PURE__ */ __name((evaluate3) => flatMap16(sync5(evaluate3), die5), "dieSync");
var either5 = /* @__PURE__ */ __name((self) => matchEffect3(self, {
  onFailure: /* @__PURE__ */ __name((e) => succeed7(left4(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed7(right4(a)), "onSuccess")
}), "either");
var exit4 = /* @__PURE__ */ __name((self) => matchCause4(self, {
  onFailure: exitFailCause3,
  onSuccess: exitSucceed3
}), "exit");
var fail6 = /* @__PURE__ */ __name((error) => isObject2(error) && !(spanSymbol2 in error) ? withFiberRuntime3((fiber) => failCause5(fail5(capture2(error, currentSpanFromFiber2(fiber))))) : failCause5(fail5(error)), "fail");
var failSync3 = /* @__PURE__ */ __name((evaluate3) => flatMap16(sync5(evaluate3), fail6), "failSync");
var failCause5 = /* @__PURE__ */ __name((cause5) => {
  const effect = new EffectPrimitiveFailure2(OP_FAILURE2);
  effect.effect_instruction_i0 = cause5;
  return effect;
}, "failCause");
var failCauseSync3 = /* @__PURE__ */ __name((evaluate3) => flatMap16(sync5(evaluate3), failCause5), "failCauseSync");
var fiberId3 = /* @__PURE__ */ withFiberRuntime3((state) => succeed7(state.id()));
var fiberIdWith3 = /* @__PURE__ */ __name((f) => withFiberRuntime3((state) => f(state.id())), "fiberIdWith");
var flatMap16 = /* @__PURE__ */ dual2(2, (self, f) => {
  const effect = new EffectPrimitive2(OP_ON_SUCCESS2);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
var andThen5 = /* @__PURE__ */ dual2(2, (self, f) => flatMap16(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect3(b)) {
    return b;
  } else if (isPromiseLike2(b)) {
    return unsafeAsync2((resume3) => {
      b.then((a2) => resume3(succeed7(a2)), (e) => resume3(fail6(new UnknownException2(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed7(b);
}));
var step5 = /* @__PURE__ */ __name((self) => {
  const effect = new EffectPrimitive2("OnStep");
  effect.effect_instruction_i0 = self;
  return effect;
}, "step");
var flatten10 = /* @__PURE__ */ __name((self) => flatMap16(self, identity2), "flatten");
var flip3 = /* @__PURE__ */ __name((self) => matchEffect3(self, {
  onFailure: succeed7,
  onSuccess: fail6
}), "flip");
var matchCause4 = /* @__PURE__ */ dual2(2, (self, options) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => succeed7(options.onFailure(cause5)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed7(options.onSuccess(a)), "onSuccess")
}));
var matchCauseEffect4 = /* @__PURE__ */ dual2(2, (self, options) => {
  const effect = new EffectPrimitive2(OP_ON_SUCCESS_AND_FAILURE2);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
var matchEffect3 = /* @__PURE__ */ dual2(2, (self, options) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const defects3 = defects2(cause5);
    if (defects3.length > 0) {
      return failCause5(electFailures2(cause5));
    }
    const failures3 = failures2(cause5);
    if (failures3.length > 0) {
      return options.onFailure(unsafeHead3(failures3));
    }
    return failCause5(cause5);
  }, "onFailure"),
  onSuccess: options.onSuccess
}));
var forEachSequential2 = /* @__PURE__ */ dual2(2, (self, f) => suspend5(() => {
  const arr = fromIterable11(self);
  const ret = allocate2(arr.length);
  let i = 0;
  return as4(whileLoop4({
    while: /* @__PURE__ */ __name(() => i < arr.length, "while"),
    body: /* @__PURE__ */ __name(() => f(arr[i], i), "body"),
    step: /* @__PURE__ */ __name((b) => {
      ret[i++] = b;
    }, "step")
  }), ret);
}));
var forEachSequentialDiscard2 = /* @__PURE__ */ dual2(2, (self, f) => suspend5(() => {
  const arr = fromIterable11(self);
  let i = 0;
  return whileLoop4({
    while: /* @__PURE__ */ __name(() => i < arr.length, "while"),
    body: /* @__PURE__ */ __name(() => f(arr[i], i), "body"),
    step: /* @__PURE__ */ __name(() => {
      i++;
    }, "step")
  });
}));
var if_3 = /* @__PURE__ */ dual2((args3) => typeof args3[0] === "boolean" || isEffect3(args3[0]), (self, options) => isEffect3(self) ? flatMap16(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
var interrupt6 = /* @__PURE__ */ flatMap16(fiberId3, (fiberId5) => interruptWith3(fiberId5));
var interruptWith3 = /* @__PURE__ */ __name((fiberId5) => failCause5(interrupt5(fiberId5)), "interruptWith");
var interruptible6 = /* @__PURE__ */ __name((self) => {
  const effect = new EffectPrimitive2(OP_UPDATE_RUNTIME_FLAGS2);
  effect.effect_instruction_i0 = enable6(Interruption2);
  effect.effect_instruction_i1 = () => self;
  return effect;
}, "interruptible");
var interruptibleMask3 = /* @__PURE__ */ __name((f) => custom3(f, function() {
  const effect = new EffectPrimitive2(OP_UPDATE_RUNTIME_FLAGS2);
  effect.effect_instruction_i0 = enable6(Interruption2);
  effect.effect_instruction_i1 = (oldFlags) => interruption2(oldFlags) ? internalCall2(() => this.effect_instruction_i0(interruptible6)) : internalCall2(() => this.effect_instruction_i0(uninterruptible3));
  return effect;
}), "interruptibleMask");
var intoDeferred3 = /* @__PURE__ */ dual2(2, (self, deferred) => uninterruptibleMask4((restore) => flatMap16(exit4(restore(self)), (exit7) => deferredDone2(deferred, exit7))));
var map19 = /* @__PURE__ */ dual2(2, (self, f) => flatMap16(self, (a) => sync5(() => f(a))));
var mapBoth3 = /* @__PURE__ */ dual2(2, (self, options) => matchEffect3(self, {
  onFailure: /* @__PURE__ */ __name((e) => failSync3(() => options.onFailure(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => sync5(() => options.onSuccess(a)), "onSuccess")
}));
var mapError3 = /* @__PURE__ */ dual2(2, (self, f) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const either7 = failureOrCause2(cause5);
    switch (either7._tag) {
      case "Left": {
        return failSync3(() => f(either7.left));
      }
      case "Right": {
        return failCause5(either7.right);
      }
    }
  }, "onFailure"),
  onSuccess: succeed7
}));
var onError3 = /* @__PURE__ */ dual2(2, (self, cleanup) => onExit4(self, (exit7) => exitIsSuccess2(exit7) ? void_3 : cleanup(exit7.effect_instruction_i0)));
var onExit4 = /* @__PURE__ */ dual2(2, (self, cleanup) => uninterruptibleMask4((restore) => matchCauseEffect4(restore(self), {
  onFailure: /* @__PURE__ */ __name((cause1) => {
    const result = exitFailCause3(cause1);
    return matchCauseEffect4(cleanup(result), {
      onFailure: /* @__PURE__ */ __name((cause22) => exitFailCause3(sequential4(cause1, cause22)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => result, "onSuccess")
    });
  }, "onFailure"),
  onSuccess: /* @__PURE__ */ __name((success) => {
    const result = exitSucceed3(success);
    return zipRight3(cleanup(result), result);
  }, "onSuccess")
})));
var onInterrupt3 = /* @__PURE__ */ dual2(2, (self, cleanup) => onExit4(self, exitMatch2({
  onFailure: /* @__PURE__ */ __name((cause5) => isInterruptedOnly2(cause5) ? asVoid4(cleanup(interruptors2(cause5))) : void_3, "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => void_3, "onSuccess")
})));
var orElse3 = /* @__PURE__ */ dual2(2, (self, that) => attemptOrElse2(self, that, succeed7));
var orDie3 = /* @__PURE__ */ __name((self) => orDieWith3(self, identity2), "orDie");
var orDieWith3 = /* @__PURE__ */ dual2(2, (self, f) => matchEffect3(self, {
  onFailure: /* @__PURE__ */ __name((e) => die5(f(e)), "onFailure"),
  onSuccess: succeed7
}));
var partitionMap4 = partitionMap3;
var runtimeFlags2 = /* @__PURE__ */ withFiberRuntime3((_, status) => succeed7(status.runtimeFlags));
var succeed7 = /* @__PURE__ */ __name((value) => {
  const effect = new EffectPrimitiveSuccess2(OP_SUCCESS2);
  effect.effect_instruction_i0 = value;
  return effect;
}, "succeed");
var suspend5 = /* @__PURE__ */ __name((evaluate3) => {
  const effect = new EffectPrimitive2(OP_COMMIT2);
  effect.commit = evaluate3;
  return effect;
}, "suspend");
var sync5 = /* @__PURE__ */ __name((thunk) => {
  const effect = new EffectPrimitive2(OP_SYNC2);
  effect.effect_instruction_i0 = thunk;
  return effect;
}, "sync");
var tap3 = /* @__PURE__ */ dual2((args3) => args3.length === 3 || args3.length === 2 && !(isObject2(args3[1]) && "onlyEffect" in args3[1]), (self, f) => flatMap16(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect3(b)) {
    return as4(b, a);
  } else if (isPromiseLike2(b)) {
    return unsafeAsync2((resume3) => {
      b.then((_) => resume3(succeed7(a)), (e) => resume3(fail6(new UnknownException2(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed7(a);
}));
var transplant3 = /* @__PURE__ */ __name((f) => withFiberRuntime3((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride2);
  const scope5 = pipe2(scopeOverride, getOrElse5(() => state.scope()));
  return f(fiberRefLocally2(currentForkScopeOverride2, some6(scope5)));
}), "transplant");
var attemptOrElse2 = /* @__PURE__ */ dual2(3, (self, that, onSuccess) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const defects3 = defects2(cause5);
    if (defects3.length > 0) {
      return failCause5(getOrThrow2(keepDefectsAndElectFailures2(cause5)));
    }
    return that();
  }, "onFailure"),
  onSuccess
}));
var uninterruptible3 = /* @__PURE__ */ __name((self) => {
  const effect = new EffectPrimitive2(OP_UPDATE_RUNTIME_FLAGS2);
  effect.effect_instruction_i0 = disable6(Interruption2);
  effect.effect_instruction_i1 = () => self;
  return effect;
}, "uninterruptible");
var uninterruptibleMask4 = /* @__PURE__ */ __name((f) => custom3(f, function() {
  const effect = new EffectPrimitive2(OP_UPDATE_RUNTIME_FLAGS2);
  effect.effect_instruction_i0 = disable6(Interruption2);
  effect.effect_instruction_i1 = (oldFlags) => interruption2(oldFlags) ? internalCall2(() => this.effect_instruction_i0(interruptible6)) : internalCall2(() => this.effect_instruction_i0(uninterruptible3));
  return effect;
}), "uninterruptibleMask");
var void_3 = /* @__PURE__ */ succeed7(void 0);
var updateRuntimeFlags2 = /* @__PURE__ */ __name((patch17) => {
  const effect = new EffectPrimitive2(OP_UPDATE_RUNTIME_FLAGS2);
  effect.effect_instruction_i0 = patch17;
  effect.effect_instruction_i1 = void 0;
  return effect;
}, "updateRuntimeFlags");
var whenEffect3 = /* @__PURE__ */ dual2(2, (self, condition) => flatMap16(condition, (b) => {
  if (b) {
    return pipe2(self, map19(some6));
  }
  return succeed7(none11());
}));
var whileLoop4 = /* @__PURE__ */ __name((options) => {
  const effect = new EffectPrimitive2(OP_WHILE2);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
}, "whileLoop");
var fromIterator2 = /* @__PURE__ */ __name((iterator) => suspend5(() => {
  const effect = new EffectPrimitive2(OP_ITERATOR2);
  effect.effect_instruction_i0 = iterator();
  return effect;
}), "fromIterator");
var gen3 = /* @__PURE__ */ __name(function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator2(() => f(pipe2));
}, "gen");
var fnUntraced3 = /* @__PURE__ */ __name((body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args3) {
  return fromIterator2(() => body.apply(this, args3));
} : function(...args3) {
  let effect = fromIterator2(() => body.apply(this, args3));
  for (const x of pipeables) {
    effect = x(effect, ...args3);
  }
  return effect;
}, "length", {
  value: body.length,
  configurable: true
}), "fnUntraced");
var withConcurrency3 = /* @__PURE__ */ dual2(2, (self, concurrency) => fiberRefLocally2(self, currentConcurrency2, concurrency));
var withRequestBatching3 = /* @__PURE__ */ dual2(2, (self, requestBatching) => fiberRefLocally2(self, currentRequestBatching2, requestBatching));
var withRuntimeFlags2 = /* @__PURE__ */ dual2(2, (self, update9) => {
  const effect = new EffectPrimitive2(OP_UPDATE_RUNTIME_FLAGS2);
  effect.effect_instruction_i0 = update9;
  effect.effect_instruction_i1 = () => self;
  return effect;
});
var withTracerEnabled3 = /* @__PURE__ */ dual2(2, (effect, enabled3) => fiberRefLocally2(effect, currentTracerEnabled2, enabled3));
var withTracerTiming3 = /* @__PURE__ */ dual2(2, (effect, enabled3) => fiberRefLocally2(effect, currentTracerTimingEnabled2, enabled3));
var yieldNow5 = /* @__PURE__ */ __name((options) => {
  const effect = new EffectPrimitive2(OP_YIELD2);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority3(effect, options.priority) : effect;
}, "yieldNow");
var zip6 = /* @__PURE__ */ dual2(2, (self, that) => flatMap16(self, (a) => map19(that, (b) => [a, b])));
var zipLeft3 = /* @__PURE__ */ dual2(2, (self, that) => flatMap16(self, (a) => as4(that, a)));
var zipRight3 = /* @__PURE__ */ dual2(2, (self, that) => flatMap16(self, () => that));
var zipWith5 = /* @__PURE__ */ dual2(3, (self, that, f) => flatMap16(self, (a) => map19(that, (b) => f(a, b))));
var never3 = /* @__PURE__ */ asyncInterrupt2(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync5(() => clearInterval(interval));
});
var interruptFiber2 = /* @__PURE__ */ __name((self) => flatMap16(fiberId3, (fiberId5) => pipe2(self, interruptAsFiber2(fiberId5))), "interruptFiber");
var interruptAsFiber2 = /* @__PURE__ */ dual2(2, (self, fiberId5) => flatMap16(self.interruptAsFork(fiberId5), () => self.await));
var logLevelAll2 = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var logLevelFatal2 = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var logLevelError2 = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var logLevelWarning2 = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var logLevelInfo2 = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var logLevelDebug2 = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var logLevelTrace2 = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var logLevelNone2 = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var FiberRefSymbolKey2 = "effect/FiberRef";
var FiberRefTypeId2 = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey2);
var fiberRefVariance2 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var fiberRefGet2 = /* @__PURE__ */ __name((self) => withFiberRuntime3((fiber) => exitSucceed3(fiber.getFiberRef(self))), "fiberRefGet");
var fiberRefGetWith2 = /* @__PURE__ */ dual2(2, (self, f) => flatMap16(fiberRefGet2(self), f));
var fiberRefSet2 = /* @__PURE__ */ dual2(2, (self, value) => fiberRefModify2(self, () => [void 0, value]));
var fiberRefModify2 = /* @__PURE__ */ dual2(2, (self, f) => withFiberRuntime3((state) => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed7(b);
}));
var RequestResolverSymbolKey2 = "effect/RequestResolver";
var RequestResolverTypeId2 = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey2);
var requestResolverVariance2 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var RequestResolverImpl2 = class _RequestResolverImpl {
  static {
    __name(this, "RequestResolverImpl");
  }
  runAll;
  target;
  [RequestResolverTypeId2] = requestResolverVariance2;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
  }
  [symbol3]() {
    return cached4(this, this.target ? hash2(this.target) : random4(this));
  }
  [symbol4](that) {
    return this.target ? isRequestResolver2(that) && equals3(this.target, that.target) : this === that;
  }
  identified(...ids5) {
    return new _RequestResolverImpl(this.runAll, fromIterable12(ids5));
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var isRequestResolver2 = /* @__PURE__ */ __name((u) => hasProperty2(u, RequestResolverTypeId2), "isRequestResolver");
var fiberRefLocally2 = /* @__PURE__ */ dual2(3, (use, self, value) => acquireUseRelease3(zipLeft3(fiberRefGet2(self), fiberRefSet2(self, value)), () => use, (oldValue) => fiberRefSet2(self, oldValue)));
var fiberRefLocallyWith2 = /* @__PURE__ */ dual2(3, (use, self, f) => fiberRefGetWith2(self, (a) => fiberRefLocally2(use, self, f(a))));
var fiberRefUnsafeMake2 = /* @__PURE__ */ __name((initial, options) => fiberRefUnsafeMakePatch2(initial, {
  differ: update5(),
  fork: options?.fork ?? identity2,
  join: options?.join
}), "fiberRefUnsafeMake");
var fiberRefUnsafeMakeHashSet2 = /* @__PURE__ */ __name((initial) => {
  const differ5 = hashSet2();
  return fiberRefUnsafeMakePatch2(initial, {
    differ: differ5,
    fork: differ5.empty
  });
}, "fiberRefUnsafeMakeHashSet");
var fiberRefUnsafeMakeReadonlyArray2 = /* @__PURE__ */ __name((initial) => {
  const differ5 = readonlyArray2(update5());
  return fiberRefUnsafeMakePatch2(initial, {
    differ: differ5,
    fork: differ5.empty
  });
}, "fiberRefUnsafeMakeReadonlyArray");
var fiberRefUnsafeMakeContext2 = /* @__PURE__ */ __name((initial) => {
  const differ5 = environment2();
  return fiberRefUnsafeMakePatch2(initial, {
    differ: differ5,
    fork: differ5.empty
  });
}, "fiberRefUnsafeMakeContext");
var fiberRefUnsafeMakePatch2 = /* @__PURE__ */ __name((initial, options) => {
  const _fiberRef = {
    ...CommitPrototype3,
    [FiberRefTypeId2]: fiberRefVariance2,
    initial,
    commit() {
      return fiberRefGet2(this);
    },
    diff: /* @__PURE__ */ __name((oldValue, newValue) => options.differ.diff(oldValue, newValue), "diff"),
    combine: /* @__PURE__ */ __name((first3, second) => options.differ.combine(first3, second), "combine"),
    patch: /* @__PURE__ */ __name((patch17) => (oldValue) => options.differ.patch(patch17, oldValue), "patch"),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
}, "fiberRefUnsafeMakePatch");
var fiberRefUnsafeMakeRuntimeFlags2 = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch2(initial, {
  differ: differ3,
  fork: differ3.empty
}), "fiberRefUnsafeMakeRuntimeFlags");
var currentContext2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext2(empty31()));
var currentSchedulingPriority2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake2(0));
var currentMaxOpsBeforeYield2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake2(2048));
var currentLogAnnotations2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake2(empty36()));
var currentLogLevel2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake2(logLevelInfo2));
var currentLogSpan2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake2(empty37()));
var withSchedulingPriority3 = /* @__PURE__ */ dual2(2, (self, scheduler) => fiberRefLocally2(self, currentSchedulingPriority2, scheduler));
var withMaxOpsBeforeYield3 = /* @__PURE__ */ dual2(2, (self, scheduler) => fiberRefLocally2(self, currentMaxOpsBeforeYield2, scheduler));
var currentConcurrency2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake2("unbounded"));
var currentRequestBatching2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake2(true));
var currentUnhandledErrorLogLevel2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake2(some6(logLevelDebug2)));
var currentVersionMismatchErrorLogLevel2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake2(some6(logLevelWarning2)));
var withUnhandledErrorLogLevel3 = /* @__PURE__ */ dual2(2, (self, level) => fiberRefLocally2(self, currentUnhandledErrorLogLevel2, level));
var currentMetricLabels2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray2(empty29()));
var metricLabels3 = /* @__PURE__ */ fiberRefGet2(currentMetricLabels2);
var currentForkScopeOverride2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake2(none11(), {
  fork: /* @__PURE__ */ __name(() => none11(), "fork"),
  join: /* @__PURE__ */ __name((parent, _) => parent, "join")
}));
var currentInterruptedCause2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake2(empty44, {
  fork: /* @__PURE__ */ __name(() => empty44, "fork"),
  join: /* @__PURE__ */ __name((parent, _) => parent, "join")
}));
var currentTracerEnabled2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake2(true));
var currentTracerTimingEnabled2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake2(true));
var currentTracerSpanAnnotations2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake2(empty36()));
var currentTracerSpanLinks2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake2(empty32()));
var ScopeTypeId2 = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId2 = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer2 = /* @__PURE__ */ __name((self, finalizer) => self.addFinalizer(() => asVoid4(finalizer)), "scopeAddFinalizer");
var scopeAddFinalizerExit2 = /* @__PURE__ */ __name((self, finalizer) => self.addFinalizer(finalizer), "scopeAddFinalizerExit");
var scopeClose2 = /* @__PURE__ */ __name((self, exit7) => self.close(exit7), "scopeClose");
var scopeFork2 = /* @__PURE__ */ __name((self, strategy) => self.fork(strategy), "scopeFork");
var YieldableError2 = /* @__PURE__ */ (function() {
  class YieldableError3 extends globalThis.Error {
    static {
      __name(this, "YieldableError");
    }
    commit() {
      return fail6(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol2]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty2(fail5(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError3.prototype, StructuralCommitPrototype2);
  return YieldableError3;
})();
var makeException2 = /* @__PURE__ */ __name((proto7, tag) => {
  class Base5 extends YieldableError2 {
    static {
      __name(this, "Base");
    }
    _tag = tag;
  }
  Object.assign(Base5.prototype, proto7);
  Base5.prototype.name = tag;
  return Base5;
}, "makeException");
var RuntimeExceptionTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException2 = /* @__PURE__ */ makeException2({
  [RuntimeExceptionTypeId2]: RuntimeExceptionTypeId2
}, "RuntimeException");
var InterruptedExceptionTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException2 = /* @__PURE__ */ makeException2({
  [InterruptedExceptionTypeId2]: InterruptedExceptionTypeId2
}, "InterruptedException");
var isInterruptedException2 = /* @__PURE__ */ __name((u) => hasProperty2(u, InterruptedExceptionTypeId2), "isInterruptedException");
var IllegalArgumentExceptionTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException2 = /* @__PURE__ */ makeException2({
  [IllegalArgumentExceptionTypeId2]: IllegalArgumentExceptionTypeId2
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException2 = /* @__PURE__ */ makeException2({
  [NoSuchElementExceptionTypeId2]: NoSuchElementExceptionTypeId2
}, "NoSuchElementException");
var isNoSuchElementException2 = /* @__PURE__ */ __name((u) => hasProperty2(u, NoSuchElementExceptionTypeId2), "isNoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException2 = /* @__PURE__ */ makeException2({
  [InvalidPubSubCapacityExceptionTypeId2]: InvalidPubSubCapacityExceptionTypeId2
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException2 = /* @__PURE__ */ makeException2({
  [ExceededCapacityExceptionTypeId2]: ExceededCapacityExceptionTypeId2
}, "ExceededCapacityException");
var TimeoutExceptionTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException2 = /* @__PURE__ */ makeException2({
  [TimeoutExceptionTypeId2]: TimeoutExceptionTypeId2
}, "TimeoutException");
var timeoutExceptionFromDuration2 = /* @__PURE__ */ __name((duration) => new TimeoutException2(`Operation timed out after '${format5(duration)}'`), "timeoutExceptionFromDuration");
var UnknownExceptionTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException2 = /* @__PURE__ */ (function() {
  class UnknownException3 extends YieldableError2 {
    static {
      __name(this, "UnknownException");
    }
    _tag = "UnknownException";
    error;
    constructor(cause5, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause5
      });
      this.error = cause5;
    }
  }
  Object.assign(UnknownException3.prototype, {
    [UnknownExceptionTypeId2]: UnknownExceptionTypeId2,
    name: "UnknownException"
  });
  return UnknownException3;
})();
var exitIsExit2 = /* @__PURE__ */ __name((u) => isEffect3(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure"), "exitIsExit");
var exitIsFailure2 = /* @__PURE__ */ __name((self) => self._tag === "Failure", "exitIsFailure");
var exitIsSuccess2 = /* @__PURE__ */ __name((self) => self._tag === "Success", "exitIsSuccess");
var exitAs2 = /* @__PURE__ */ dual2(2, (self, value) => {
  switch (self._tag) {
    case OP_FAILURE2: {
      return exitFailCause3(self.effect_instruction_i0);
    }
    case OP_SUCCESS2: {
      return exitSucceed3(value);
    }
  }
});
var exitAsVoid2 = /* @__PURE__ */ __name((self) => exitAs2(self, void 0), "exitAsVoid");
var exitCollectAll2 = /* @__PURE__ */ __name((exits, options) => exitCollectAllInternal2(exits, options?.parallel ? parallel4 : sequential4), "exitCollectAll");
var exitDie3 = /* @__PURE__ */ __name((defect) => exitFailCause3(die4(defect)), "exitDie");
var exitFail2 = /* @__PURE__ */ __name((error) => exitFailCause3(fail5(error)), "exitFail");
var exitFailCause3 = /* @__PURE__ */ __name((cause5) => {
  const effect = new EffectPrimitiveFailure2(OP_FAILURE2);
  effect.effect_instruction_i0 = cause5;
  return effect;
}, "exitFailCause");
var exitFlatMap2 = /* @__PURE__ */ dual2(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE2: {
      return exitFailCause3(self.effect_instruction_i0);
    }
    case OP_SUCCESS2: {
      return f(self.effect_instruction_i0);
    }
  }
});
var exitFlatten2 = /* @__PURE__ */ __name((self) => pipe2(self, exitFlatMap2(identity2)), "exitFlatten");
var exitInterrupt3 = /* @__PURE__ */ __name((fiberId5) => exitFailCause3(interrupt5(fiberId5)), "exitInterrupt");
var exitMap2 = /* @__PURE__ */ dual2(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE2:
      return exitFailCause3(self.effect_instruction_i0);
    case OP_SUCCESS2:
      return exitSucceed3(f(self.effect_instruction_i0));
  }
});
var exitMatch2 = /* @__PURE__ */ dual2(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE2:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS2:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect2 = /* @__PURE__ */ dual2(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE2:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS2:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed3 = /* @__PURE__ */ __name((value) => {
  const effect = new EffectPrimitiveSuccess2(OP_SUCCESS2);
  effect.effect_instruction_i0 = value;
  return effect;
}, "exitSucceed");
var exitVoid3 = /* @__PURE__ */ exitSucceed3(void 0);
var exitZipWith2 = /* @__PURE__ */ dual2(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE2: {
      switch (that._tag) {
        case OP_SUCCESS2:
          return exitFailCause3(self.effect_instruction_i0);
        case OP_FAILURE2: {
          return exitFailCause3(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS2: {
      switch (that._tag) {
        case OP_SUCCESS2:
          return exitSucceed3(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE2:
          return exitFailCause3(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal2 = /* @__PURE__ */ __name((exits, combineCauses) => {
  const list = fromIterable12(exits);
  if (!isNonEmpty5(list)) {
    return none11();
  }
  return pipe2(tailNonEmpty4(list), reduce11(pipe2(headNonEmpty4(list), exitMap2(of6)), (accumulator, current) => pipe2(accumulator, exitZipWith2(current, {
    onSuccess: /* @__PURE__ */ __name((list2, value) => pipe2(list2, prepend5(value)), "onSuccess"),
    onFailure: combineCauses
  }))), exitMap2(reverse5), exitMap2((chunk3) => toReadonlyArray2(chunk3)), some6);
}, "exitCollectAllInternal");
var deferredUnsafeMake2 = /* @__PURE__ */ __name((fiberId5) => {
  const _deferred = {
    ...CommitPrototype3,
    [DeferredTypeId2]: deferredVariance2,
    state: make49(pending3([])),
    commit() {
      return deferredAwait2(this);
    },
    blockingOn: fiberId5
  };
  return _deferred;
}, "deferredUnsafeMake");
var deferredMake2 = /* @__PURE__ */ __name(() => flatMap16(fiberId3, (id) => deferredMakeAs2(id)), "deferredMake");
var deferredMakeAs2 = /* @__PURE__ */ __name((fiberId5) => sync5(() => deferredUnsafeMake2(fiberId5)), "deferredMakeAs");
var deferredAwait2 = /* @__PURE__ */ __name((self) => asyncInterrupt2((resume3) => {
  const state = get18(self.state);
  switch (state._tag) {
    case OP_STATE_DONE2: {
      return resume3(state.effect);
    }
    case OP_STATE_PENDING2: {
      state.joiners.push(resume3);
      return deferredInterruptJoiner2(self, resume3);
    }
  }
}, self.blockingOn), "deferredAwait");
var deferredComplete2 = /* @__PURE__ */ dual2(2, (self, effect) => intoDeferred3(effect, self));
var deferredCompleteWith2 = /* @__PURE__ */ dual2(2, (self, effect) => sync5(() => {
  const state = get18(self.state);
  switch (state._tag) {
    case OP_STATE_DONE2: {
      return false;
    }
    case OP_STATE_PENDING2: {
      set7(self.state, done7(effect));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect);
      }
      return true;
    }
  }
}));
var deferredDone2 = /* @__PURE__ */ dual2(2, (self, exit7) => deferredCompleteWith2(self, exit7));
var deferredFailCause2 = /* @__PURE__ */ dual2(2, (self, cause5) => deferredCompleteWith2(self, failCause5(cause5)));
var deferredInterrupt2 = /* @__PURE__ */ __name((self) => flatMap16(fiberId3, (fiberId5) => deferredCompleteWith2(self, interruptWith3(fiberId5))), "deferredInterrupt");
var deferredSucceed2 = /* @__PURE__ */ dual2(2, (self, value) => deferredCompleteWith2(self, succeed7(value)));
var deferredUnsafeDone2 = /* @__PURE__ */ __name((self, effect) => {
  const state = get18(self.state);
  if (state._tag === OP_STATE_PENDING2) {
    set7(self.state, done7(effect));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect);
    }
  }
}, "deferredUnsafeDone");
var deferredInterruptJoiner2 = /* @__PURE__ */ __name((self, joiner) => sync5(() => {
  const state = get18(self.state);
  if (state._tag === OP_STATE_PENDING2) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
}), "deferredInterruptJoiner");
var constContext2 = /* @__PURE__ */ withFiberRuntime3((fiber) => exitSucceed3(fiber.currentContext));
var context4 = /* @__PURE__ */ __name(() => constContext2, "context");
var contextWithEffect3 = /* @__PURE__ */ __name((f) => flatMap16(context4(), f), "contextWithEffect");
var provideContext3 = /* @__PURE__ */ dual2(2, (self, context7) => fiberRefLocally2(currentContext2, context7)(self));
var provideSomeContext2 = /* @__PURE__ */ dual2(2, (self, context7) => fiberRefLocallyWith2(currentContext2, (parent) => merge9(parent, context7))(self));
var mapInputContext3 = /* @__PURE__ */ dual2(2, (self, f) => contextWithEffect3((context7) => provideContext3(self, f(context7))));
var filterEffectOrElse3 = /* @__PURE__ */ dual2(2, (self, options) => flatMap16(self, (a) => flatMap16(options.predicate(a), (pass) => pass ? succeed7(a) : options.orElse(a))));
var filterEffectOrFail3 = /* @__PURE__ */ dual2(2, (self, options) => filterEffectOrElse3(self, {
  predicate: options.predicate,
  orElse: /* @__PURE__ */ __name((a) => fail6(options.orFailWith(a)), "orElse")
}));
var currentSpanFromFiber2 = /* @__PURE__ */ __name((fiber) => {
  const span3 = fiber.currentSpan;
  return span3 !== void 0 && span3._tag === "Span" ? some6(span3) : none11();
}, "currentSpanFromFiber");
var NoopSpanProto2 = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid3
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan2 = /* @__PURE__ */ __name((options) => Object.assign(Object.create(NoopSpanProto2), options), "noopSpan");

// node_modules/effect/dist/esm/Deferred.js
var _await3 = deferredAwait2;
var done8 = deferredDone2;
var interrupt7 = deferredInterrupt2;
var unsafeMake10 = deferredUnsafeMake2;

// node_modules/effect/dist/esm/Exit.js
var flatten11 = exitFlatten2;
var succeed8 = exitSucceed3;

// node_modules/effect/dist/esm/MutableHashMap.js
var TypeId23 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto2 = {
  [TypeId23]: TypeId23,
  [Symbol.iterator]() {
    return new MutableHashMapIterator2(this);
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var MutableHashMapIterator2 = class _MutableHashMapIterator {
  static {
    __name(this, "MutableHashMapIterator");
  }
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator2(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator2 = class {
  static {
    __name(this, "BucketIterator");
  }
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty45 = /* @__PURE__ */ __name(() => {
  const self = Object.create(MutableHashMapProto2);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
}, "empty");
var get20 = /* @__PURE__ */ dual2(2, (self, key) => {
  if (isEqual2(key) === false) {
    return self.referential.has(key) ? some6(self.referential.get(key)) : none11();
  }
  const hash3 = key[symbol3]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    return none11();
  }
  return getFromBucket2(self, bucket, key);
});
var getFromBucket2 = /* @__PURE__ */ __name((self, bucket, key, remove15 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol4](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove15) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some6(value);
    }
  }
  return none11();
}, "getFromBucket");
var has10 = /* @__PURE__ */ dual2(2, (self, key) => isSome4(get20(self, key)));
var set9 = /* @__PURE__ */ dual2(3, (self, key, value) => {
  if (isEqual2(key) === false) {
    self.referential.set(key, value);
    return self;
  }
  const hash3 = key[symbol3]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    self.buckets.set(hash3, [[key, value]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket2(self, bucket, key);
  bucket.push([key, value]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket2 = /* @__PURE__ */ __name((self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol4](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
}, "removeFromBucket");
var remove12 = /* @__PURE__ */ dual2(2, (self, key) => {
  if (isEqual2(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash3 = key[symbol3]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    return self;
  }
  removeFromBucket2(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash3);
  }
  return self;
});
var size12 = /* @__PURE__ */ __name((self) => {
  return self.referential.size + self.bucketsSize;
}, "size");

// node_modules/effect/dist/esm/MutableList.js
var TypeId24 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto2 = {
  [TypeId24]: TypeId24,
  [Symbol.iterator]() {
    let done13 = false;
    let head9 = this.head;
    return {
      next() {
        if (done13) {
          return this.return();
        }
        if (head9 == null) {
          done13 = true;
          return this.return();
        }
        const value = head9.value;
        head9 = head9.next;
        return {
          done: done13,
          value
        };
      },
      return(value) {
        if (!done13) {
          done13 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var makeNode2 = /* @__PURE__ */ __name((value) => ({
  value,
  removed: false,
  prev: void 0,
  next: void 0
}), "makeNode");
var empty46 = /* @__PURE__ */ __name(() => {
  const list = Object.create(MutableListProto2);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
}, "empty");
var isEmpty14 = /* @__PURE__ */ __name((self) => length2(self) === 0, "isEmpty");
var length2 = /* @__PURE__ */ __name((self) => self._length, "length");
var append6 = /* @__PURE__ */ dual2(2, (self, value) => {
  const node = makeNode2(value);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var shift2 = /* @__PURE__ */ __name((self) => {
  const head9 = self.head;
  if (head9 !== void 0) {
    remove13(self, head9);
    return head9.value;
  }
  return void 0;
}, "shift");
var remove13 = /* @__PURE__ */ __name((self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
}, "remove");

// node_modules/effect/dist/esm/MutableQueue.js
var TypeId25 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue2 = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto2 = {
  [TypeId25]: TypeId25,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var make56 = /* @__PURE__ */ __name((capacity) => {
  const queue = Object.create(MutableQueueProto2);
  queue.queue = empty46();
  queue.capacity = capacity;
  return queue;
}, "make");
var unbounded2 = /* @__PURE__ */ __name(() => make56(void 0), "unbounded");
var offer2 = /* @__PURE__ */ dual2(2, (self, value) => {
  const queueLength = length2(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append6(value)(self.queue);
  return true;
});
var poll2 = /* @__PURE__ */ dual2(2, (self, def) => {
  if (isEmpty14(self.queue)) {
    return def;
  }
  return shift2(self.queue);
});

// node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey2 = "effect/Clock";
var ClockTypeId2 = /* @__PURE__ */ Symbol.for(ClockSymbolKey2);
var clockTag2 = /* @__PURE__ */ GenericTag2("effect/Clock");
var MAX_TIMER_MILLIS2 = 2 ** 31 - 1;
var globalClockScheduler2 = {
  unsafeSchedule(task, duration) {
    const millis3 = toMillis2(duration);
    if (millis3 > MAX_TIMER_MILLIS2) {
      return constFalse2;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis3);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos2 = /* @__PURE__ */ (function() {
  const bigint1e63 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined" || typeof performance.now !== "function") {
    return () => BigInt(Date.now()) * bigint1e63;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e63 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
})();
var processOrPerformanceNow2 = /* @__PURE__ */ (function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos2;
  }
  const origin = /* @__PURE__ */ performanceNowNanos2() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
})();
var ClockImpl2 = class {
  static {
    __name(this, "ClockImpl");
  }
  [ClockTypeId2] = ClockTypeId2;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow2();
  }
  currentTimeMillis = /* @__PURE__ */ sync5(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync5(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed7(globalClockScheduler2);
  }
  sleep(duration) {
    return async_2((resume3) => {
      const canceler = globalClockScheduler2.unsafeSchedule(() => resume3(void_3), duration);
      return asVoid4(sync5(canceler));
    });
  }
};
var make57 = /* @__PURE__ */ __name(() => new ClockImpl2(), "make");

// node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND2 = "And";
var OP_OR2 = "Or";
var OP_INVALID_DATA2 = "InvalidData";
var OP_MISSING_DATA2 = "MissingData";
var OP_SOURCE_UNAVAILABLE2 = "SourceUnavailable";
var OP_UNSUPPORTED2 = "Unsupported";

// node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey2 = "effect/ConfigError";
var ConfigErrorTypeId2 = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey2);
var proto5 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId2]: ConfigErrorTypeId2
};
var And2 = /* @__PURE__ */ __name((self, that) => {
  const error = Object.create(proto5);
  error._op = OP_AND2;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
}, "And");
var Or2 = /* @__PURE__ */ __name((self, that) => {
  const error = Object.create(proto5);
  error._op = OP_OR2;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
}, "Or");
var InvalidData2 = /* @__PURE__ */ __name((path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto5);
  error._op = OP_INVALID_DATA2;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe2(this.path, join3(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, "InvalidData");
var MissingData2 = /* @__PURE__ */ __name((path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto5);
  error._op = OP_MISSING_DATA2;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe2(this.path, join3(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, "MissingData");
var SourceUnavailable2 = /* @__PURE__ */ __name((path, message, cause5, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto5);
  error._op = OP_SOURCE_UNAVAILABLE2;
  error.path = path;
  error.message = message;
  error.cause = cause5;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe2(this.path, join3(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, "SourceUnavailable");
var Unsupported2 = /* @__PURE__ */ __name((path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto5);
  error._op = OP_UNSUPPORTED2;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe2(this.path, join3(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, "Unsupported");
var prefixed2 = /* @__PURE__ */ dual2(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND2: {
      return And2(prefixed2(self.left, prefix), prefixed2(self.right, prefix));
    }
    case OP_OR2: {
      return Or2(prefixed2(self.left, prefix), prefixed2(self.right, prefix));
    }
    case OP_INVALID_DATA2: {
      return InvalidData2([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA2: {
      return MissingData2([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE2: {
      return SourceUnavailable2([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED2: {
      return Unsupported2([...prefix, ...self.path], self.message);
    }
  }
});

// node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty47 = {
  _tag: "Empty"
};
var patch13 = /* @__PURE__ */ dual2(2, (path, patch17) => {
  let input = of7(patch17);
  let output = path;
  while (isCons2(input)) {
    const patch18 = input.head;
    switch (patch18._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons2(patch18.first, cons2(patch18.second, input.tail));
        break;
      }
      case "MapName": {
        output = map13(output, patch18.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend4(output, patch18.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe2(head5(output), contains3(patch18.name));
        if (containsName) {
          output = tailNonEmpty3(output);
          input = input.tail;
        } else {
          return left4(MissingData2(output, `Expected ${patch18.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right4(output);
});

// node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT2 = "Constant";
var OP_FAIL4 = "Fail";
var OP_FALLBACK2 = "Fallback";
var OP_DESCRIBED2 = "Described";
var OP_LAZY2 = "Lazy";
var OP_MAP_OR_FAIL2 = "MapOrFail";
var OP_NESTED2 = "Nested";
var OP_PRIMITIVE2 = "Primitive";
var OP_SEQUENCE2 = "Sequence";
var OP_HASHMAP2 = "HashMap";
var OP_ZIP_WITH3 = "ZipWith";

// node_modules/effect/dist/esm/internal/configProvider.js
var concat2 = /* @__PURE__ */ __name((l, r) => [...l, ...r], "concat");
var ConfigProviderSymbolKey2 = "effect/ConfigProvider";
var ConfigProviderTypeId2 = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey2);
var configProviderTag2 = /* @__PURE__ */ GenericTag2("effect/ConfigProvider");
var FlatConfigProviderSymbolKey2 = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId2 = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey2);
var make59 = /* @__PURE__ */ __name((options) => ({
  [ConfigProviderTypeId2]: ConfigProviderTypeId2,
  pipe() {
    return pipeArguments2(this, arguments);
  },
  ...options
}), "make");
var makeFlat2 = /* @__PURE__ */ __name((options) => ({
  [FlatConfigProviderTypeId2]: FlatConfigProviderTypeId2,
  patch: options.patch,
  load: /* @__PURE__ */ __name((path, config, split = true) => options.load(path, config, split), "load"),
  enumerateChildren: options.enumerateChildren
}), "makeFlat");
var fromFlat2 = /* @__PURE__ */ __name((flat) => make59({
  load: /* @__PURE__ */ __name((config) => flatMap16(fromFlatLoop2(flat, empty29(), config, false), (chunk3) => match11(head5(chunk3), {
    onNone: /* @__PURE__ */ __name(() => fail6(MissingData2(empty29(), `Expected a single value having structure: ${config}`)), "onNone"),
    onSome: succeed7
  })), "load"),
  flattened: flat
}), "fromFlat");
var fromEnv2 = /* @__PURE__ */ __name((options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = /* @__PURE__ */ __name((path) => pipe2(path, join3(pathDelim)), "makePathString");
  const unmakePathString = /* @__PURE__ */ __name((pathString) => pathString.split(pathDelim), "unmakePathString");
  const getEnv = /* @__PURE__ */ __name(() => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {}, "getEnv");
  const load = /* @__PURE__ */ __name((path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some6(current[pathString]) : none11();
    return pipe2(valueOpt, mapError3(() => MissingData2(path, `Expected ${pathString} to exist in the process context`)), flatMap16((value) => parsePrimitive2(value, path, primitive, seqDelim, split)));
  }, "load");
  const enumerateChildren = /* @__PURE__ */ __name((path) => sync5(() => {
    const current = getEnv();
    const keys9 = Object.keys(current);
    const keyPaths = keys9.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe2(path, unsafeGet6(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable15(filteredKeyPaths);
  }), "enumerateChildren");
  return fromFlat2(makeFlat2({
    load,
    enumerateChildren,
    patch: empty47
  }));
}, "fromEnv");
var extend2 = /* @__PURE__ */ __name((leftDef, rightDef, left5, right5) => {
  const leftPad = unfold3(left5.length, (index) => index >= right5.length ? none11() : some6([leftDef(index), index + 1]));
  const rightPad = unfold3(right5.length, (index) => index >= left5.length ? none11() : some6([rightDef(index), index + 1]));
  const leftExtension = concat2(left5, leftPad);
  const rightExtension = concat2(right5, rightPad);
  return [leftExtension, rightExtension];
}, "extend");
var appendConfigPath2 = /* @__PURE__ */ __name((path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
}, "appendConfigPath");
var fromFlatLoop2 = /* @__PURE__ */ __name((flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT2: {
      return succeed7(of5(op.value));
    }
    case OP_DESCRIBED2: {
      return suspend5(() => fromFlatLoop2(flat, prefix, op.config, split));
    }
    case OP_FAIL4: {
      return fail6(MissingData2(prefix, op.message));
    }
    case OP_FALLBACK2: {
      return pipe2(suspend5(() => fromFlatLoop2(flat, prefix, op.first, split)), catchAll3((error1) => {
        if (op.condition(error1)) {
          return pipe2(fromFlatLoop2(flat, prefix, op.second, split), catchAll3((error2) => fail6(Or2(error1, error2))));
        }
        return fail6(error1);
      }));
    }
    case OP_LAZY2: {
      return suspend5(() => fromFlatLoop2(flat, prefix, op.config(), split));
    }
    case OP_MAP_OR_FAIL2: {
      return suspend5(() => pipe2(fromFlatLoop2(flat, prefix, op.original, split), flatMap16(forEachSequential2((a) => pipe2(op.mapOrFail(a), mapError3(prefixed2(appendConfigPath2(prefix, op.original))))))));
    }
    case OP_NESTED2: {
      return suspend5(() => fromFlatLoop2(flat, concat2(prefix, of5(op.name)), op.config, split));
    }
    case OP_PRIMITIVE2: {
      return pipe2(patch13(prefix, flat.patch), flatMap16((prefix2) => pipe2(flat.load(prefix2, op, split), flatMap16((values5) => {
        if (values5.length === 0) {
          const name = pipe2(last3(prefix2), getOrElse5(() => "<n/a>"));
          return fail6(MissingData2([], `Expected ${op.description} with name ${name}`));
        }
        return succeed7(values5);
      }))));
    }
    case OP_SEQUENCE2: {
      return pipe2(patch13(prefix, flat.patch), flatMap16((patchedPrefix) => pipe2(flat.enumerateChildren(patchedPrefix), flatMap16(indicesFrom2), flatMap16((indices) => {
        if (indices.length === 0) {
          return suspend5(() => map19(fromFlatLoop2(flat, prefix, op.config, true), of5));
        }
        return pipe2(forEachSequential2(indices, (index) => fromFlatLoop2(flat, append4(prefix, `[${index}]`), op.config, true)), map19((chunkChunk) => {
          const flattened = flatten7(chunkChunk);
          if (flattened.length === 0) {
            return of5(empty29());
          }
          return of5(flattened);
        }));
      }))));
    }
    case OP_HASHMAP2: {
      return suspend5(() => pipe2(patch13(prefix, flat.patch), flatMap16((prefix2) => pipe2(flat.enumerateChildren(prefix2), flatMap16((keys9) => {
        return pipe2(keys9, forEachSequential2((key) => fromFlatLoop2(flat, concat2(prefix2, of5(key)), op.valueConfig, split)), map19((matrix) => {
          if (matrix.length === 0) {
            return of5(empty36());
          }
          return pipe2(transpose2(matrix), map13((values5) => fromIterable16(zip5(fromIterable11(keys9), values5))));
        }));
      })))));
    }
    case OP_ZIP_WITH3: {
      return suspend5(() => pipe2(fromFlatLoop2(flat, prefix, op.left, split), either5, flatMap16((left5) => pipe2(fromFlatLoop2(flat, prefix, op.right, split), either5, flatMap16((right5) => {
        if (isLeft4(left5) && isLeft4(right5)) {
          return fail6(And2(left5.left, right5.left));
        }
        if (isLeft4(left5) && isRight4(right5)) {
          return fail6(left5.left);
        }
        if (isRight4(left5) && isLeft4(right5)) {
          return fail6(right5.left);
        }
        if (isRight4(left5) && isRight4(right5)) {
          const path = pipe2(prefix, join3("."));
          const fail9 = fromFlatLoopFail2(prefix, path);
          const [lefts, rights] = extend2(fail9, fail9, pipe2(left5.right, map13(right4)), pipe2(right5.right, map13(right4)));
          return pipe2(lefts, zip5(rights), forEachSequential2(([left6, right6]) => pipe2(zip6(left6, right6), map19(([left7, right7]) => op.zip(left7, right7)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
}, "fromFlatLoop");
var fromFlatLoopFail2 = /* @__PURE__ */ __name((prefix, path) => (index) => left4(MissingData2(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`)), "fromFlatLoopFail");
var splitPathString2 = /* @__PURE__ */ __name((text, delim) => {
  const split = text.split(new RegExp(`\\s*${escape2(delim)}\\s*`));
  return split;
}, "splitPathString");
var parsePrimitive2 = /* @__PURE__ */ __name((text, path, primitive, delimiter, split) => {
  if (!split) {
    return pipe2(primitive.parse(text), mapBoth3({
      onFailure: prefixed2(path),
      onSuccess: of5
    }));
  }
  return pipe2(splitPathString2(text, delimiter), forEachSequential2((char) => primitive.parse(char.trim())), mapError3(prefixed2(path)));
}, "parsePrimitive");
var transpose2 = /* @__PURE__ */ __name((array6) => {
  return Object.keys(array6[0]).map((column) => array6.map((row) => row[column]));
}, "transpose");
var indicesFrom2 = /* @__PURE__ */ __name((quotedIndices) => pipe2(forEachSequential2(quotedIndices, parseQuotedIndex2), mapBoth3({
  onFailure: /* @__PURE__ */ __name(() => empty29(), "onFailure"),
  onSuccess: sort2(Order3)
}), either5, map19(merge7)), "indicesFrom");
var QUOTED_INDEX_REGEX2 = /^(\[(\d+)\])$/;
var parseQuotedIndex2 = /* @__PURE__ */ __name((str) => {
  const match20 = str.match(QUOTED_INDEX_REGEX2);
  if (match20 !== null) {
    const matchedIndex = match20[2];
    return pipe2(matchedIndex !== void 0 && matchedIndex.length > 0 ? some6(matchedIndex) : none11(), flatMap10(parseInteger2));
  }
  return none11();
}, "parseQuotedIndex");
var parseInteger2 = /* @__PURE__ */ __name((str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none11() : some6(parsedIndex);
}, "parseInteger");

// node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId26 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag2 = /* @__PURE__ */ GenericTag2("effect/Console");
var defaultConsole2 = {
  [TypeId26]: TypeId26,
  assert(condition, ...args3) {
    return sync5(() => {
      console.assert(condition, ...args3);
    });
  },
  clear: /* @__PURE__ */ sync5(() => {
    console.clear();
  }),
  count(label) {
    return sync5(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync5(() => {
      console.countReset(label);
    });
  },
  debug(...args3) {
    return sync5(() => {
      console.debug(...args3);
    });
  },
  dir(item, options) {
    return sync5(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args3) {
    return sync5(() => {
      console.dirxml(...args3);
    });
  },
  error(...args3) {
    return sync5(() => {
      console.error(...args3);
    });
  },
  group(options) {
    return options?.collapsed ? sync5(() => console.groupCollapsed(options?.label)) : sync5(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync5(() => {
    console.groupEnd();
  }),
  info(...args3) {
    return sync5(() => {
      console.info(...args3);
    });
  },
  log(...args3) {
    return sync5(() => {
      console.log(...args3);
    });
  },
  table(tabularData, properties) {
    return sync5(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync5(() => console.time(label));
  },
  timeEnd(label) {
    return sync5(() => console.timeEnd(label));
  },
  timeLog(label, ...args3) {
    return sync5(() => {
      console.timeLog(label, ...args3);
    });
  },
  trace(...args3) {
    return sync5(() => {
      console.trace(...args3);
    });
  },
  warn(...args3) {
    return sync5(() => {
      console.warn(...args3);
    });
  },
  unsafe: console
};

// node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey2 = "effect/Random";
var RandomTypeId2 = /* @__PURE__ */ Symbol.for(RandomSymbolKey2);
var randomTag2 = /* @__PURE__ */ GenericTag2("effect/Random");
var RandomImpl2 = class {
  static {
    __name(this, "RandomImpl");
  }
  seed;
  [RandomTypeId2] = RandomTypeId2;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom2(seed);
  }
  get next() {
    return sync5(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map19(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync5(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min5, max9) {
    return map19(this.next, (n) => (max9 - min5) * n + min5);
  }
  nextIntBetween(min5, max9) {
    return sync5(() => this.PRNG.integer(max9 - min5) + min5);
  }
  shuffle(elements) {
    return shuffleWith2(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith2 = /* @__PURE__ */ __name((elements, nextIntBounded) => {
  return suspend5(() => pipe2(sync5(() => Array.from(elements)), flatMap16((buffer) => {
    const numbers = [];
    for (let i = buffer.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe2(numbers, forEachSequentialDiscard2((n) => pipe2(nextIntBounded(n), map19((k) => swap3(buffer, n - 1, k)))), as4(fromIterable12(buffer)));
  })));
}, "shuffleWith");
var swap3 = /* @__PURE__ */ __name((buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
}, "swap");
var make60 = /* @__PURE__ */ __name((seed) => new RandomImpl2(hash2(seed)), "make");
var FixedRandomImpl2 = class {
  static {
    __name(this, "FixedRandomImpl");
  }
  values;
  [RandomTypeId2] = RandomTypeId2;
  index = 0;
  constructor(values5) {
    this.values = values5;
    if (values5.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value;
  }
  get next() {
    return sync5(() => {
      const value = this.getNextValue();
      if (typeof value === "number") {
        return Math.max(0, Math.min(1, value));
      }
      return hash2(value) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync5(() => {
      const value = this.getNextValue();
      if (typeof value === "boolean") {
        return value;
      }
      return hash2(value) % 2 === 0;
    });
  }
  get nextInt() {
    return sync5(() => {
      const value = this.getNextValue();
      if (typeof value === "number" && Number.isFinite(value)) {
        return Math.round(value);
      }
      return Math.abs(hash2(value));
    });
  }
  nextRange(min5, max9) {
    return map19(this.next, (n) => (max9 - min5) * n + min5);
  }
  nextIntBetween(min5, max9) {
    return sync5(() => {
      const value = this.getNextValue();
      if (typeof value === "number" && Number.isFinite(value)) {
        return Math.max(min5, Math.min(max9 - 1, Math.round(value)));
      }
      const hash3 = Math.abs(hash2(value));
      return min5 + hash3 % (max9 - min5);
    });
  }
  shuffle(elements) {
    return shuffleWith2(elements, (n) => this.nextIntBetween(0, n));
  }
};
var fixed3 = /* @__PURE__ */ __name((values5) => new FixedRandomImpl2(values5), "fixed");

// node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId2 = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make61 = /* @__PURE__ */ __name((options) => ({
  [TracerTypeId2]: TracerTypeId2,
  ...options
}), "make");
var tracerTag2 = /* @__PURE__ */ GenericTag2("effect/Tracer");
var spanTag2 = /* @__PURE__ */ GenericTag2("effect/ParentSpan");
var randomHexString2 = /* @__PURE__ */ (function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length3) {
    let result = "";
    for (let i = 0; i < length3; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
})();
var NativeSpan2 = class {
  static {
    __name(this, "NativeSpan");
  }
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context7, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context7;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString2(32);
    this.spanId = randomHexString2(16);
    this.links = Array.from(links);
  }
  end(endTime, exit7) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit7,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer2 = /* @__PURE__ */ make61({
  span: /* @__PURE__ */ __name((name, parent, context7, links, startTime, kind) => new NativeSpan2(name, parent, context7, links, startTime, kind), "span"),
  context: /* @__PURE__ */ __name((f) => f(), "context")
});
var addSpanStackTrace2 = /* @__PURE__ */ __name((options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options,
    captureStackTrace: /* @__PURE__ */ __name(() => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }, "captureStackTrace")
  };
}, "addSpanStackTrace");
var DisablePropagation2 = /* @__PURE__ */ Reference4()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse2
});

// node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices2 = /* @__PURE__ */ pipe2(/* @__PURE__ */ empty31(), /* @__PURE__ */ add7(clockTag2, /* @__PURE__ */ make57()), /* @__PURE__ */ add7(consoleTag2, defaultConsole2), /* @__PURE__ */ add7(randomTag2, /* @__PURE__ */ make60(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add7(configProviderTag2, /* @__PURE__ */ fromEnv2()), /* @__PURE__ */ add7(tracerTag2, nativeTracer2));
var currentServices2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext2(liveServices2));
var sleep5 = /* @__PURE__ */ __name((duration) => {
  const decodedDuration = decode2(duration);
  return clockWith5((clock5) => clock5.sleep(decodedDuration));
}, "sleep");
var defaultServicesWith2 = /* @__PURE__ */ __name((f) => withFiberRuntime3((fiber) => f(fiber.currentDefaultServices)), "defaultServicesWith");
var clockWith5 = /* @__PURE__ */ __name((f) => defaultServicesWith2((services) => f(services.unsafeMap.get(clockTag2.key))), "clockWith");
var currentTimeMillis3 = /* @__PURE__ */ clockWith5((clock5) => clock5.currentTimeMillis);
var currentTimeNanos3 = /* @__PURE__ */ clockWith5((clock5) => clock5.currentTimeNanos);
var withClock3 = /* @__PURE__ */ dual2(2, (effect, c) => fiberRefLocallyWith2(currentServices2, add7(clockTag2, c))(effect));
var withConfigProvider3 = /* @__PURE__ */ dual2(2, (self, provider) => fiberRefLocallyWith2(currentServices2, add7(configProviderTag2, provider))(self));
var configProviderWith3 = /* @__PURE__ */ __name((f) => defaultServicesWith2((services) => f(services.unsafeMap.get(configProviderTag2.key))), "configProviderWith");
var randomWith3 = /* @__PURE__ */ __name((f) => defaultServicesWith2((services) => f(services.unsafeMap.get(randomTag2.key))), "randomWith");
var withRandom3 = /* @__PURE__ */ dual2(2, (effect, value) => fiberRefLocallyWith2(currentServices2, add7(randomTag2, value))(effect));
var tracerWith5 = /* @__PURE__ */ __name((f) => defaultServicesWith2((services) => f(services.unsafeMap.get(tracerTag2.key))), "tracerWith");
var withTracer3 = /* @__PURE__ */ dual2(2, (effect, value) => fiberRefLocallyWith2(currentServices2, add7(tracerTag2, value))(effect));

// node_modules/effect/dist/esm/Clock.js
var sleep6 = sleep5;
var currentTimeMillis4 = currentTimeMillis3;
var currentTimeNanos4 = currentTimeNanos3;
var clockWith6 = clockWith5;
var Clock2 = clockTag2;

// node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake11(fiberRefLocals) {
  return new FiberRefsImpl2(fiberRefLocals);
}
__name(unsafeMake11, "unsafeMake");
function empty48() {
  return unsafeMake11(/* @__PURE__ */ new Map());
}
__name(empty48, "empty");
var FiberRefsSym2 = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var FiberRefsImpl2 = class {
  static {
    __name(this, "FiberRefsImpl");
  }
  locals;
  [FiberRefsSym2] = FiberRefsSym2;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var findAncestor2 = /* @__PURE__ */ __name((_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray2(parentStack) && isNonEmptyReadonlyArray2(childStack)) {
      const parentFiberId = headNonEmpty3(parentStack)[0];
      const parentAncestors = tailNonEmpty3(parentStack);
      const childFiberId = headNonEmpty3(childStack)[0];
      const childRefValue = headNonEmpty3(childStack)[1];
      const childAncestors = tailNonEmpty3(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
}, "findAncestor");
var joinAs3 = /* @__PURE__ */ dual2(3, (self, fiberId5, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol4](fiberId5)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals3(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId5, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor2(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch17 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch17)(oldValue));
        if (!equals3(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol4](fiberId5)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId5, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl2(parentFiberRefs);
});
var forkAs2 = /* @__PURE__ */ dual2(2, (self, childId) => {
  const map23 = /* @__PURE__ */ new Map();
  unsafeForkAs2(self, map23, childId);
  return new FiberRefsImpl2(map23);
});
var unsafeForkAs2 = /* @__PURE__ */ __name((self, map23, fiberId5) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals3(oldValue, newValue)) {
      map23.set(fiberRef, stack);
    } else {
      map23.set(fiberRef, [[fiberId5, newValue], ...stack]);
    }
  });
}, "unsafeForkAs");
var fiberRefs3 = /* @__PURE__ */ __name((self) => fromIterable15(self.locals.keys()), "fiberRefs");
var setAll3 = /* @__PURE__ */ __name((self) => forEachSequentialDiscard2(fiberRefs3(self), (fiberRef) => fiberRefSet2(fiberRef, getOrDefault3(self, fiberRef))), "setAll");
var delete_3 = /* @__PURE__ */ dual2(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl2(locals);
});
var get21 = /* @__PURE__ */ dual2(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none11();
  }
  return some6(headNonEmpty3(self.locals.get(fiberRef))[1]);
});
var getOrDefault3 = /* @__PURE__ */ dual2(2, (self, fiberRef) => pipe2(get21(self, fiberRef), getOrElse5(() => fiberRef.initial)));
var updateAs3 = /* @__PURE__ */ dual2(2, (self, {
  fiberId: fiberId5,
  fiberRef,
  value
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl2(/* @__PURE__ */ new Map([[fiberRef, [[fiberId5, value]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs2(locals, fiberId5, fiberRef, value);
  return new FiberRefsImpl2(locals);
});
var unsafeUpdateAs2 = /* @__PURE__ */ __name((locals, fiberId5, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray2(oldStack)) {
    const [currentId, currentValue] = headNonEmpty3(oldStack);
    if (currentId[symbol4](fiberId5)) {
      if (equals3(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId5, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId5, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId5, value]];
  }
  locals.set(fiberRef, newStack);
}, "unsafeUpdateAs");
var updateManyAs3 = /* @__PURE__ */ dual2(2, (self, {
  entries: entries3,
  forkAs: forkAs3
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl2(new Map(entries3));
  }
  const locals = new Map(self.locals);
  if (forkAs3 !== void 0) {
    unsafeForkAs2(self, locals, forkAs3);
  }
  entries3.forEach(([fiberRef, values5]) => {
    if (values5.length === 1) {
      unsafeUpdateAs2(locals, values5[0][0], fiberRef, values5[0][1]);
    } else {
      values5.forEach(([fiberId5, value]) => {
        unsafeUpdateAs2(locals, fiberId5, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl2(locals);
});

// node_modules/effect/dist/esm/FiberRefs.js
var get22 = get21;
var getOrDefault4 = getOrDefault3;
var joinAs4 = joinAs3;
var setAll4 = setAll3;
var updateManyAs4 = updateManyAs3;
var empty49 = empty48;

// node_modules/effect/dist/esm/LogLevel.js
var All2 = logLevelAll2;
var Fatal2 = logLevelFatal2;
var Error4 = logLevelError2;
var Warning2 = logLevelWarning2;
var Info2 = logLevelInfo2;
var Debug2 = logLevelDebug2;
var Trace2 = logLevelTrace2;
var None6 = logLevelNone2;
var Order4 = /* @__PURE__ */ pipe2(Order3, /* @__PURE__ */ mapInput4((level) => level.ordinal));
var greaterThan4 = /* @__PURE__ */ greaterThan3(Order4);
var fromLiteral2 = /* @__PURE__ */ __name((literal) => {
  switch (literal) {
    case "All":
      return All2;
    case "Debug":
      return Debug2;
    case "Error":
      return Error4;
    case "Fatal":
      return Fatal2;
    case "Info":
      return Info2;
    case "Trace":
      return Trace2;
    case "None":
      return None6;
    case "Warning":
      return Warning2;
  }
}, "fromLiteral");

// node_modules/effect/dist/esm/internal/logSpan.js
var make62 = /* @__PURE__ */ __name((label, startTime) => ({
  label,
  startTime
}), "make");
var formatLabel2 = /* @__PURE__ */ __name((key) => key.replace(/[\s="]/g, "_"), "formatLabel");
var render2 = /* @__PURE__ */ __name((now) => (self) => {
  const label = formatLabel2(self.label);
  return `${label}=${now - self.startTime}ms`;
}, "render");

// node_modules/effect/dist/esm/LogSpan.js
var make63 = make62;

// node_modules/effect/dist/esm/Effectable.js
var EffectPrototype4 = EffectPrototype3;
var CommitPrototype4 = CommitPrototype3;
var Base4 = Base3;
var Class6 = class extends Base4 {
  static {
    __name(this, "Class");
  }
};

// node_modules/effect/dist/esm/Readable.js
var TypeId27 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto2 = {
  [TypeId27]: TypeId27,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};

// node_modules/effect/dist/esm/internal/ref.js
var RefTypeId2 = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance2 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var RefImpl2 = class extends Class6 {
  static {
    __name(this, "RefImpl");
  }
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId2] = refVariance2;
  [TypeId27] = TypeId27;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync5(() => get18(this.ref));
  }
  get;
  modify(f) {
    return sync5(() => {
      const current = get18(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        set7(a)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake12 = /* @__PURE__ */ __name((value) => new RefImpl2(make49(value)), "unsafeMake");
var make64 = /* @__PURE__ */ __name((value) => sync5(() => unsafeMake12(value)), "make");
var get23 = /* @__PURE__ */ __name((self) => self.get, "get");
var set10 = /* @__PURE__ */ dual2(2, (self, value) => self.modify(() => [void 0, value]));
var getAndSet3 = /* @__PURE__ */ dual2(2, (self, value) => self.modify((a) => [a, value]));
var modify6 = /* @__PURE__ */ dual2(2, (self, f) => self.modify(f));
var update6 = /* @__PURE__ */ dual2(2, (self, f) => self.modify((a) => [void 0, f(a)]));

// node_modules/effect/dist/esm/Ref.js
var make65 = make64;
var get24 = get23;
var getAndSet4 = getAndSet3;
var update7 = update6;

// node_modules/effect/dist/esm/Tracer.js
var tracerWith6 = tracerWith5;

// node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY5 = "Empty";
var OP_ADD2 = "Add";
var OP_REMOVE2 = "Remove";
var OP_UPDATE2 = "Update";
var OP_AND_THEN3 = "AndThen";
var empty50 = {
  _tag: OP_EMPTY5
};
var diff12 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch17 = empty50;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty3(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty3(old)[1];
      if (!equals3(oldValue2, newValue2)) {
        patch17 = combine15({
          _tag: OP_UPDATE2,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch17);
      }
    } else {
      patch17 = combine15({
        _tag: OP_ADD2,
        fiberRef,
        value: newValue2
      })(patch17);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch17 = combine15({
      _tag: OP_REMOVE2,
      fiberRef
    })(patch17);
  }
  return patch17;
}, "diff");
var combine15 = /* @__PURE__ */ dual2(2, (self, that) => ({
  _tag: OP_AND_THEN3,
  first: self,
  second: that
}));
var patch14 = /* @__PURE__ */ dual2(3, (self, fiberId5, oldValue) => {
  let fiberRefs5 = oldValue;
  let patches = of5(self);
  while (isNonEmptyReadonlyArray2(patches)) {
    const head9 = headNonEmpty3(patches);
    const tail = tailNonEmpty3(patches);
    switch (head9._tag) {
      case OP_EMPTY5: {
        patches = tail;
        break;
      }
      case OP_ADD2: {
        fiberRefs5 = updateAs3(fiberRefs5, {
          fiberId: fiberId5,
          fiberRef: head9.fiberRef,
          value: head9.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE2: {
        fiberRefs5 = delete_3(fiberRefs5, head9.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE2: {
        const value = getOrDefault3(fiberRefs5, head9.fiberRef);
        fiberRefs5 = updateAs3(fiberRefs5, {
          fiberId: fiberId5,
          fiberRef: head9.fiberRef,
          value: head9.fiberRef.patch(head9.patch)(value)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN3: {
        patches = prepend4(head9.first)(prepend4(head9.second)(tail));
        break;
      }
    }
  }
  return fiberRefs5;
});

// node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey2 = "effect/MetricLabel";
var MetricLabelTypeId2 = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey2);
var MetricLabelImpl2 = class {
  static {
    __name(this, "MetricLabelImpl");
  }
  key;
  value;
  [MetricLabelTypeId2] = MetricLabelTypeId2;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string2(MetricLabelSymbolKey2 + this.key + this.value);
  }
  [symbol3]() {
    return this._hash;
  }
  [symbol4](that) {
    return isMetricLabel2(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var make66 = /* @__PURE__ */ __name((key, value) => {
  return new MetricLabelImpl2(key, value);
}, "make");
var isMetricLabel2 = /* @__PURE__ */ __name((u) => hasProperty2(u, MetricLabelTypeId2), "isMetricLabel");

// node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), function() {
  const args3 = arguments;
  return fiberRefLocallyWith2(args3[0], currentLogAnnotations2, typeof args3[1] === "string" ? set8(args3[1], args3[2]) : (annotations) => Object.entries(args3[1]).reduce((acc, [key, value]) => set8(acc, key, value), annotations));
});
var asSome3 = /* @__PURE__ */ __name((self) => map19(self, some6), "asSome");
var asSomeError3 = /* @__PURE__ */ __name((self) => mapError3(self, some6), "asSomeError");
var try_3 = /* @__PURE__ */ __name((arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return suspend5(() => {
    try {
      return succeed7(internalCall2(evaluate3));
    } catch (error) {
      return fail6(onFailure ? internalCall2(() => onFailure(error)) : new UnknownException2(error, "An unknown error occurred in Effect.try"));
    }
  });
}, "try_");
var _catch3 = /* @__PURE__ */ dual2(3, (self, tag, options) => catchAll3(self, (e) => {
  if (hasProperty2(e, tag) && e[tag] === options.failure) {
    return options.onFailure(e);
  }
  return fail6(e);
}));
var catchAllDefect3 = /* @__PURE__ */ dual2(2, (self, f) => catchAllCause3(self, (cause5) => {
  const option5 = find2(cause5, (_) => isDieType2(_) ? some6(_) : none11());
  switch (option5._tag) {
    case "None": {
      return failCause5(cause5);
    }
    case "Some": {
      return f(option5.value.defect);
    }
  }
}));
var catchSomeCause3 = /* @__PURE__ */ dual2(2, (self, f) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const option5 = f(cause5);
    switch (option5._tag) {
      case "None": {
        return failCause5(cause5);
      }
      case "Some": {
        return option5.value;
      }
    }
  }, "onFailure"),
  onSuccess: succeed7
}));
var catchSomeDefect3 = /* @__PURE__ */ dual2(2, (self, pf) => catchAllCause3(self, (cause5) => {
  const option5 = find2(cause5, (_) => isDieType2(_) ? some6(_) : none11());
  switch (option5._tag) {
    case "None": {
      return failCause5(cause5);
    }
    case "Some": {
      const optionEffect = pf(option5.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause5(cause5);
    }
  }
}));
var catchTag3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), (self, ...args3) => {
  const f = args3[args3.length - 1];
  let predicate;
  if (args3.length === 2) {
    predicate = isTagged2(args3[0]);
  } else {
    predicate = /* @__PURE__ */ __name((e) => {
      const tag = hasProperty2(e, "_tag") ? e["_tag"] : void 0;
      if (!tag) return false;
      for (let i = 0; i < args3.length - 1; i++) {
        if (args3[i] === tag) return true;
      }
      return false;
    }, "predicate");
  }
  return catchIf3(self, predicate, f);
});
var catchTags3 = /* @__PURE__ */ dual2(2, (self, cases) => {
  let keys9;
  return catchIf3(self, (e) => {
    keys9 ??= Object.keys(cases);
    return hasProperty2(e, "_tag") && isString2(e["_tag"]) && keys9.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause3 = /* @__PURE__ */ __name((self) => matchCause4(self, {
  onFailure: identity2,
  onSuccess: /* @__PURE__ */ __name(() => empty44, "onSuccess")
}), "cause");
var clockWith7 = clockWith6;
var clock3 = /* @__PURE__ */ clockWith7(succeed7);
var delay3 = /* @__PURE__ */ dual2(2, (self, duration) => zipRight3(sleep6(duration), self));
var descriptorWith3 = /* @__PURE__ */ __name((f) => withFiberRuntime3((state, status) => f({
  id: state.id(),
  status,
  interruptors: interruptors2(state.getFiberRef(currentInterruptedCause2))
})), "descriptorWith");
var allowInterrupt3 = /* @__PURE__ */ descriptorWith3((descriptor5) => size11(descriptor5.interruptors) > 0 ? interrupt6 : void_3);
var descriptor3 = /* @__PURE__ */ descriptorWith3(succeed7);
var diffFiberRefs3 = /* @__PURE__ */ __name((self) => summarized3(self, fiberRefs4, diff12), "diffFiberRefs");
var diffFiberRefsAndRuntimeFlags2 = /* @__PURE__ */ __name((self) => summarized3(self, zip6(fiberRefs4, runtimeFlags2), ([refs, flags], [refsNew, flagsNew]) => [diff12(refs, refsNew), diff11(flags, flagsNew)]), "diffFiberRefsAndRuntimeFlags");
var Do3 = /* @__PURE__ */ succeed7({});
var bind5 = /* @__PURE__ */ bind4(map19, flatMap16);
var bindTo5 = /* @__PURE__ */ bindTo4(map19);
var let_5 = /* @__PURE__ */ let_4(map19);
var dropUntil3 = /* @__PURE__ */ dual2(2, (elements, predicate) => suspend5(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed7(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap16(dropping, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed7(true);
      }
      return predicate(a, index);
    });
  }
  return map19(dropping, () => builder);
}));
var dropWhile3 = /* @__PURE__ */ dual2(2, (elements, predicate) => suspend5(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed7(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap16(dropping, (d) => map19(d ? predicate(a, index) : succeed7(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map19(dropping, () => builder);
}));
var contextWith3 = /* @__PURE__ */ __name((f) => map19(context4(), f), "contextWith");
var eventually3 = /* @__PURE__ */ __name((self) => orElse3(self, () => flatMap16(yieldNow5(), () => eventually3(self))), "eventually");
var filterMap7 = /* @__PURE__ */ dual2(2, (elements, pf) => map19(forEachSequential2(elements, identity2), filterMap5(pf)));
var filterOrDie3 = /* @__PURE__ */ dual2(3, (self, predicate, orDieWith5) => filterOrElse3(self, predicate, (a) => dieSync3(() => orDieWith5(a))));
var filterOrDieMessage3 = /* @__PURE__ */ dual2(3, (self, predicate, message) => filterOrElse3(self, predicate, () => dieMessage3(message)));
var filterOrElse3 = /* @__PURE__ */ dual2(3, (self, predicate, orElse5) => flatMap16(self, (a) => predicate(a) ? succeed7(a) : orElse5(a)));
var liftPredicate3 = /* @__PURE__ */ dual2(3, (self, predicate, orFailWith) => suspend5(() => predicate(self) ? succeed7(self) : fail6(orFailWith(self))));
var filterOrFail3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), (self, predicate, orFailWith) => filterOrElse3(self, predicate, (a) => orFailWith === void 0 ? fail6(new NoSuchElementException2()) : failSync3(() => orFailWith(a))));
var findFirst8 = /* @__PURE__ */ dual2(2, (elements, predicate) => suspend5(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop2(iterator, 0, predicate, next.value);
  }
  return succeed7(none11());
}));
var findLoop2 = /* @__PURE__ */ __name((iterator, index, f, value) => flatMap16(f(value, index), (result) => {
  if (result) {
    return succeed7(some6(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop2(iterator, index + 1, f, next.value);
  }
  return succeed7(none11());
}), "findLoop");
var firstSuccessOf3 = /* @__PURE__ */ __name((effects) => suspend5(() => {
  const list = fromIterable12(effects);
  if (!isNonEmpty5(list)) {
    return dieSync3(() => new IllegalArgumentException2(`Received an empty collection of effects`));
  }
  return pipe2(tailNonEmpty4(list), reduce11(headNonEmpty4(list), (left5, right5) => orElse3(left5, () => right5)));
}), "firstSuccessOf");
var flipWith3 = /* @__PURE__ */ dual2(2, (self, f) => flip3(f(flip3(self))));
var match15 = /* @__PURE__ */ dual2(2, (self, options) => matchEffect3(self, {
  onFailure: /* @__PURE__ */ __name((e) => succeed7(options.onFailure(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed7(options.onSuccess(a)), "onSuccess")
}));
var every9 = /* @__PURE__ */ dual2(2, (elements, predicate) => suspend5(() => forAllLoop2(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop2 = /* @__PURE__ */ __name((iterator, index, f) => {
  const next = iterator.next();
  return next.done ? succeed7(true) : flatMap16(f(next.value, index), (b) => b ? forAllLoop2(iterator, index + 1, f) : succeed7(b));
}, "forAllLoop");
var forever4 = /* @__PURE__ */ __name((self) => {
  const loop5 = flatMap16(flatMap16(self, () => yieldNow5()), () => loop5);
  return loop5;
}, "forever");
var fiberRefs4 = /* @__PURE__ */ withFiberRuntime3((state) => succeed7(state.getFiberRefs()));
var head7 = /* @__PURE__ */ __name((self) => flatMap16(self, (as7) => {
  const iterator = as7[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return fail6(new NoSuchElementException2());
  }
  return succeed7(next.value);
}), "head");
var ignore3 = /* @__PURE__ */ __name((self) => match15(self, {
  onFailure: constVoid2,
  onSuccess: constVoid2
}), "ignore");
var ignoreLogged3 = /* @__PURE__ */ __name((self) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => logDebug3(cause5, "An error was silently ignored because it is not anticipated to be useful"), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => void_3, "onSuccess")
}), "ignoreLogged");
var inheritFiberRefs3 = /* @__PURE__ */ __name((childFiberRefs) => updateFiberRefs3((parentFiberId, parentFiberRefs) => joinAs4(parentFiberRefs, parentFiberId, childFiberRefs)), "inheritFiberRefs");
var isFailure3 = /* @__PURE__ */ __name((self) => match15(self, {
  onFailure: constTrue2,
  onSuccess: constFalse2
}), "isFailure");
var isSuccess3 = /* @__PURE__ */ __name((self) => match15(self, {
  onFailure: constFalse2,
  onSuccess: constTrue2
}), "isSuccess");
var iterate3 = /* @__PURE__ */ __name((initial, options) => suspend5(() => {
  if (options.while(initial)) {
    return flatMap16(options.body(initial), (z2) => iterate3(z2, options));
  }
  return succeed7(initial);
}), "iterate");
var logWithLevel3 = /* @__PURE__ */ __name((level) => (...message) => {
  const levelOption = fromNullable4(level);
  let cause5 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause2(msg)) {
      if (cause5 !== void 0) {
        cause5 = sequential4(cause5, msg);
      } else {
        cause5 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause5 === void 0) {
    cause5 = empty44;
  }
  return withFiberRuntime3((fiberState) => {
    fiberState.log(message, cause5, levelOption);
    return void_3;
  });
}, "logWithLevel");
var log3 = /* @__PURE__ */ logWithLevel3();
var logTrace3 = /* @__PURE__ */ logWithLevel3(Trace2);
var logDebug3 = /* @__PURE__ */ logWithLevel3(Debug2);
var logInfo3 = /* @__PURE__ */ logWithLevel3(Info2);
var logWarning3 = /* @__PURE__ */ logWithLevel3(Warning2);
var logError3 = /* @__PURE__ */ logWithLevel3(Error4);
var logFatal3 = /* @__PURE__ */ logWithLevel3(Fatal2);
var withLogSpan3 = /* @__PURE__ */ dual2(2, (effect, label) => flatMap16(currentTimeMillis4, (now) => fiberRefLocallyWith2(effect, currentLogSpan2, prepend6(make63(label, now)))));
var logAnnotations3 = /* @__PURE__ */ fiberRefGet2(currentLogAnnotations2);
var loop3 = /* @__PURE__ */ __name((initial, options) => options.discard ? loopDiscard2(initial, options.while, options.step, options.body) : map19(loopInternal2(initial, options.while, options.step, options.body), fromIterable11), "loop");
var loopInternal2 = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend5(() => cont(initial) ? flatMap16(body(initial), (a) => map19(loopInternal2(inc(initial), cont, inc, body), prepend6(a))) : sync5(() => empty37())), "loopInternal");
var loopDiscard2 = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend5(() => cont(initial) ? flatMap16(body(initial), () => loopDiscard2(inc(initial), cont, inc, body)) : void_3), "loopDiscard");
var mapAccum5 = /* @__PURE__ */ dual2(3, (elements, initial, f) => suspend5(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed7(initial);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index = i++;
    const value = next.value;
    result = flatMap16(result, (state) => map19(f(state, value, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map19(result, (z) => [z, builder]);
}));
var mapErrorCause3 = /* @__PURE__ */ dual2(2, (self, f) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((c) => failCauseSync3(() => f(c)), "onFailure"),
  onSuccess: succeed7
}));
var memoize2 = /* @__PURE__ */ __name((self) => pipe2(deferredMake2(), flatMap16((deferred) => pipe2(diffFiberRefsAndRuntimeFlags2(self), intoDeferred3(deferred), once4, map19((complete5) => zipRight3(complete5, pipe2(deferredAwait2(deferred), flatMap16(([patch17, a]) => as4(zip6(patchFiberRefs3(patch17[0]), updateRuntimeFlags2(patch17[1])), a)))))))), "memoize");
var merge11 = /* @__PURE__ */ __name((self) => matchEffect3(self, {
  onFailure: /* @__PURE__ */ __name((e) => succeed7(e), "onFailure"),
  onSuccess: succeed7
}), "merge");
var negate3 = /* @__PURE__ */ __name((self) => map19(self, (b) => !b), "negate");
var none15 = /* @__PURE__ */ __name((self) => flatMap16(self, (option5) => {
  switch (option5._tag) {
    case "None":
      return void_3;
    case "Some":
      return fail6(new NoSuchElementException2());
  }
}), "none");
var once4 = /* @__PURE__ */ __name((self) => map19(make65(true), (ref) => asVoid4(whenEffect3(self, getAndSet4(ref, false)))), "once");
var option3 = /* @__PURE__ */ __name((self) => matchEffect3(self, {
  onFailure: /* @__PURE__ */ __name(() => succeed7(none11()), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed7(some6(a)), "onSuccess")
}), "option");
var orElseFail3 = /* @__PURE__ */ dual2(2, (self, evaluate3) => orElse3(self, () => failSync3(evaluate3)));
var orElseSucceed3 = /* @__PURE__ */ dual2(2, (self, evaluate3) => orElse3(self, () => sync5(evaluate3)));
var parallelErrors3 = /* @__PURE__ */ __name((self) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const errors = fromIterable11(failures2(cause5));
    return errors.length === 0 ? failCause5(cause5) : fail6(errors);
  }, "onFailure"),
  onSuccess: succeed7
}), "parallelErrors");
var patchFiberRefs3 = /* @__PURE__ */ __name((patch17) => updateFiberRefs3((fiberId5, fiberRefs5) => pipe2(patch17, patch14(fiberId5, fiberRefs5))), "patchFiberRefs");
var promise3 = /* @__PURE__ */ __name((evaluate3) => evaluate3.length >= 1 ? async_2((resolve, signal) => {
  try {
    evaluate3(signal).then((a) => resolve(succeed7(a)), (e) => resolve(die5(e)));
  } catch (e) {
    resolve(die5(e));
  }
}) : async_2((resolve) => {
  try {
    ;
    evaluate3().then((a) => resolve(succeed7(a)), (e) => resolve(die5(e)));
  } catch (e) {
    resolve(die5(e));
  }
}), "promise");
var provideService3 = /* @__PURE__ */ dual2(3, (self, tag, service) => contextWithEffect3((env) => provideContext3(self, add7(env, tag, service))));
var provideServiceEffect3 = /* @__PURE__ */ dual2(3, (self, tag, effect) => contextWithEffect3((env) => flatMap16(effect, (service) => provideContext3(self, pipe2(env, add7(tag, service))))));
var random5 = /* @__PURE__ */ randomWith3(succeed7);
var reduce18 = /* @__PURE__ */ dual2(3, (elements, zero3, f) => fromIterable11(elements).reduce((acc, el, i) => flatMap16(acc, (a) => f(a, el, i)), succeed7(zero3)));
var reduceRight5 = /* @__PURE__ */ dual2(3, (elements, zero3, f) => fromIterable11(elements).reduceRight((acc, el, i) => flatMap16(acc, (a) => f(el, a, i)), succeed7(zero3)));
var reduceWhile3 = /* @__PURE__ */ dual2(3, (elements, zero3, options) => flatMap16(sync5(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop2(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop2 = /* @__PURE__ */ __name((iterator, index, state, predicate, f) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return flatMap16(f(state, next.value, index), (nextState) => reduceWhileLoop2(iterator, index + 1, nextState, predicate, f));
  }
  return succeed7(state);
}, "reduceWhileLoop");
var repeatN3 = /* @__PURE__ */ dual2(2, (self, n) => suspend5(() => repeatNLoop2(self, n)));
var repeatNLoop2 = /* @__PURE__ */ __name((self, n) => flatMap16(self, (a) => n <= 0 ? succeed7(a) : zipRight3(yieldNow5(), repeatNLoop2(self, n - 1))), "repeatNLoop");
var sandbox3 = /* @__PURE__ */ __name((self) => matchCauseEffect4(self, {
  onFailure: fail6,
  onSuccess: succeed7
}), "sandbox");
var setFiberRefs3 = /* @__PURE__ */ __name((fiberRefs5) => suspend5(() => setAll4(fiberRefs5)), "setFiberRefs");
var sleep7 = sleep6;
var succeedNone3 = /* @__PURE__ */ succeed7(/* @__PURE__ */ none11());
var succeedSome3 = /* @__PURE__ */ __name((value) => succeed7(some6(value)), "succeedSome");
var summarized3 = /* @__PURE__ */ dual2(3, (self, summary9, f) => flatMap16(summary9, (start5) => flatMap16(self, (value) => map19(summary9, (end5) => [f(start5, end5), value]))));
var tagMetrics3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), function() {
  return labelMetrics3(arguments[0], typeof arguments[1] === "string" ? [make66(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make66(k, v)));
});
var labelMetrics3 = /* @__PURE__ */ dual2(2, (self, labels) => fiberRefLocallyWith2(self, currentMetricLabels2, (old) => union8(old, labels)));
var takeUntil3 = /* @__PURE__ */ dual2(2, (elements, predicate) => suspend5(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect = succeed7(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    effect = flatMap16(effect, (bool) => {
      if (bool) {
        return succeed7(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map19(effect, () => builder);
}));
var takeWhile3 = /* @__PURE__ */ dual2(2, (elements, predicate) => suspend5(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed7(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    taking = flatMap16(taking, (taking2) => pipe2(taking2 ? predicate(a, index) : succeed7(false), map19((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map19(taking, () => builder);
}));
var tapBoth3 = /* @__PURE__ */ dual2(2, (self, {
  onFailure,
  onSuccess
}) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const either7 = failureOrCause2(cause5);
    switch (either7._tag) {
      case "Left": {
        return zipRight3(onFailure(either7.left), failCause5(cause5));
      }
      case "Right": {
        return failCause5(cause5);
      }
    }
  }, "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => as4(onSuccess(a), a), "onSuccess")
}));
var tapDefect3 = /* @__PURE__ */ dual2(2, (self, f) => catchAllCause3(self, (cause5) => match11(keepDefects2(cause5), {
  onNone: /* @__PURE__ */ __name(() => failCause5(cause5), "onNone"),
  onSome: /* @__PURE__ */ __name((a) => zipRight3(f(a), failCause5(cause5)), "onSome")
})));
var tapError3 = /* @__PURE__ */ dual2(2, (self, f) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => {
    const either7 = failureOrCause2(cause5);
    switch (either7._tag) {
      case "Left":
        return zipRight3(f(either7.left), failCause5(cause5));
      case "Right":
        return failCause5(cause5);
    }
  }, "onFailure"),
  onSuccess: succeed7
}));
var tapErrorTag3 = /* @__PURE__ */ dual2(3, (self, k, f) => tapError3(self, (e) => {
  if (isTagged2(e, k)) {
    return f(e);
  }
  return void_3;
}));
var tapErrorCause3 = /* @__PURE__ */ dual2(2, (self, f) => matchCauseEffect4(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => zipRight3(f(cause5), failCause5(cause5)), "onFailure"),
  onSuccess: succeed7
}));
var timed3 = /* @__PURE__ */ __name((self) => timedWith3(self, currentTimeNanos4), "timed");
var timedWith3 = /* @__PURE__ */ dual2(2, (self, nanos3) => summarized3(self, nanos3, (start5, end5) => nanos2(end5 - start5)));
var tracerWith7 = tracerWith6;
var tracer3 = /* @__PURE__ */ tracerWith7(succeed7);
var tryPromise3 = /* @__PURE__ */ __name((arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  const fail9 = /* @__PURE__ */ __name((e) => catcher ? failSync3(() => catcher(e)) : fail6(new UnknownException2(e, "An unknown error occurred in Effect.tryPromise")), "fail");
  if (evaluate3.length >= 1) {
    return async_2((resolve, signal) => {
      try {
        evaluate3(signal).then((a) => resolve(succeed7(a)), (e) => resolve(fail9(e)));
      } catch (e) {
        resolve(fail9(e));
      }
    });
  }
  return async_2((resolve) => {
    try {
      evaluate3().then((a) => resolve(succeed7(a)), (e) => resolve(fail9(e)));
    } catch (e) {
      resolve(fail9(e));
    }
  });
}, "tryPromise");
var tryMap3 = /* @__PURE__ */ dual2(2, (self, options) => flatMap16(self, (a) => try_3({
  try: /* @__PURE__ */ __name(() => options.try(a), "try"),
  catch: options.catch
})));
var tryMapPromise3 = /* @__PURE__ */ dual2(2, (self, options) => flatMap16(self, (a) => tryPromise3({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless3 = /* @__PURE__ */ dual2(2, (self, condition) => suspend5(() => condition() ? succeedNone3 : asSome3(self)));
var unlessEffect3 = /* @__PURE__ */ dual2(2, (self, condition) => flatMap16(condition, (b) => b ? succeedNone3 : asSome3(self)));
var unsandbox3 = /* @__PURE__ */ __name((self) => mapErrorCause3(self, flatten9), "unsandbox");
var updateFiberRefs3 = /* @__PURE__ */ __name((f) => withFiberRuntime3((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_3;
}), "updateFiberRefs");
var updateService3 = /* @__PURE__ */ dual2(3, (self, tag, f) => mapInputContext3(self, (context7) => add7(context7, tag, f(unsafeGet8(context7, tag)))));
var when3 = /* @__PURE__ */ dual2(2, (self, condition) => suspend5(() => condition() ? map19(self, some6) : succeed7(none11())));
var whenFiberRef3 = /* @__PURE__ */ dual2(3, (self, fiberRef, predicate) => flatMap16(fiberRefGet2(fiberRef), (s) => predicate(s) ? map19(self, (a) => [s, some6(a)]) : succeed7([s, none11()])));
var whenRef3 = /* @__PURE__ */ dual2(3, (self, ref, predicate) => flatMap16(get24(ref), (s) => predicate(s) ? map19(self, (a) => [s, some6(a)]) : succeed7([s, none11()])));
var withMetric3 = /* @__PURE__ */ dual2(2, (self, metric) => metric(self));
var serviceFunctionEffect3 = /* @__PURE__ */ __name((getService, f) => (...args3) => flatMap16(getService, (a) => f(a)(...args3)), "serviceFunctionEffect");
var serviceFunction3 = /* @__PURE__ */ __name((getService, f) => (...args3) => map19(getService, (a) => f(a)(...args3)), "serviceFunction");
var serviceFunctions3 = /* @__PURE__ */ __name((getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args3) => flatMap16(getService, (s) => s[prop](...args3));
  }
}), "serviceFunctions");
var serviceConstants3 = /* @__PURE__ */ __name((getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap16(getService, (s) => isEffect3(s[prop]) ? s[prop] : succeed7(s[prop]));
  }
}), "serviceConstants");
var serviceMembers3 = /* @__PURE__ */ __name((getService) => ({
  functions: serviceFunctions3(getService),
  constants: serviceConstants3(getService)
}), "serviceMembers");
var serviceOption3 = /* @__PURE__ */ __name((tag) => map19(context4(), getOption4(tag)), "serviceOption");
var serviceOptional3 = /* @__PURE__ */ __name((tag) => flatMap16(context4(), getOption4(tag)), "serviceOptional");
var annotateCurrentSpan3 = /* @__PURE__ */ __name(function() {
  const args3 = arguments;
  return ignore3(flatMap16(currentSpan3, (span3) => sync5(() => {
    if (typeof args3[0] === "string") {
      span3.attribute(args3[0], args3[1]);
    } else {
      for (const key in args3[0]) {
        span3.attribute(key, args3[0][key]);
      }
    }
  })));
}, "annotateCurrentSpan");
var linkSpanCurrent3 = /* @__PURE__ */ __name(function() {
  const args3 = arguments;
  const links = Array.isArray(args3[0]) ? args3[0] : [{
    _tag: "SpanLink",
    span: args3[0],
    attributes: args3[1] ?? {}
  }];
  return ignore3(flatMap16(currentSpan3, (span3) => sync5(() => span3.addLinks(links))));
}, "linkSpanCurrent");
var annotateSpans3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), function() {
  const args3 = arguments;
  return fiberRefLocallyWith2(args3[0], currentTracerSpanAnnotations2, typeof args3[1] === "string" ? set8(args3[1], args3[2]) : (annotations) => Object.entries(args3[1]).reduce((acc, [key, value]) => set8(acc, key, value), annotations));
});
var currentParentSpan3 = /* @__PURE__ */ serviceOptional3(spanTag2);
var currentSpan3 = /* @__PURE__ */ flatMap16(/* @__PURE__ */ context4(), (context7) => {
  const span3 = context7.unsafeMap.get(spanTag2.key);
  return span3 !== void 0 && span3._tag === "Span" ? succeed7(span3) : fail6(new NoSuchElementException2());
});
var linkSpans3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), (self, span3, attributes) => fiberRefLocallyWith2(self, currentTracerSpanLinks2, append5({
  _tag: "SpanLink",
  span: span3,
  attributes: attributes ?? {}
})));
var bigint05 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation2 = /* @__PURE__ */ flatMap10((span3) => get15(span3.context, DisablePropagation2) ? span3._tag === "Span" ? filterDisablePropagation2(span3.parent) : none11() : some6(span3));
var unsafeMakeSpan2 = /* @__PURE__ */ __name((fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled2) || options.context && get15(options.context, DisablePropagation2);
  const context7 = fiber.getFiberRef(currentContext2);
  const parent = options.parent ? some6(options.parent) : options.root ? none11() : filterDisablePropagation2(getOption4(context7, spanTag2));
  let span3;
  if (disablePropagation) {
    span3 = noopSpan2({
      name,
      parent,
      context: add7(options.context ?? empty31(), DisablePropagation2, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices2);
    const tracer5 = get15(services, tracerTag2);
    const clock5 = get15(services, Clock2);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled2);
    const fiberRefs5 = fiber.getFiberRefs();
    const annotationsFromEnv = get22(fiberRefs5, currentTracerSpanAnnotations2);
    const linksFromEnv = get22(fiberRefs5, currentTracerSpanLinks2);
    const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray2(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray2(linksFromEnv.value) : options.links ?? empty29();
    span3 = tracer5.span(name, parent, options.context ?? empty31(), links, timingEnabled ? clock5.unsafeCurrentTimeNanos() : bigint05, options.kind ?? "internal", options);
    if (annotationsFromEnv._tag === "Some") {
      forEach11(annotationsFromEnv.value, (value, key) => span3.attribute(key, value));
    }
    if (options.attributes !== void 0) {
      Object.entries(options.attributes).forEach(([k, v]) => span3.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace2.set(span3, options.captureStackTrace);
  }
  return span3;
}, "unsafeMakeSpan");
var makeSpan3 = /* @__PURE__ */ __name((name, options) => {
  options = addSpanStackTrace2(options);
  return withFiberRuntime3((fiber) => succeed7(unsafeMakeSpan2(fiber, name, options)));
}, "makeSpan");
var spanAnnotations3 = /* @__PURE__ */ fiberRefGet2(currentTracerSpanAnnotations2);
var spanLinks3 = /* @__PURE__ */ fiberRefGet2(currentTracerSpanLinks2);
var endSpan2 = /* @__PURE__ */ __name((span3, exit7, clock5, timingEnabled) => sync5(() => {
  if (span3.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure2(exit7) && spanToTrace2.has(span3)) {
    span3.attribute("code.stacktrace", spanToTrace2.get(span3)());
  }
  span3.end(timingEnabled ? clock5.unsafeCurrentTimeNanos() : bigint05, exit7);
}), "endSpan");
var useSpan3 = /* @__PURE__ */ __name((name, ...args3) => {
  const options = addSpanStackTrace2(args3.length === 1 ? void 0 : args3[0]);
  const evaluate3 = args3[args3.length - 1];
  return withFiberRuntime3((fiber) => {
    const span3 = unsafeMakeSpan2(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled2);
    const clock5 = get15(fiber.getFiberRef(currentServices2), clockTag2);
    return onExit4(evaluate3(span3), (exit7) => endSpan2(span3, exit7, clock5, timingEnabled));
  });
}, "useSpan");
var withParentSpan3 = /* @__PURE__ */ dual2(2, (self, span3) => provideService3(self, spanTag2, span3));
var withSpan3 = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace2(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan3(name, options, (span3) => withParentSpan3(self, span3));
  }
  return (self) => useSpan3(name, options, (span3) => withParentSpan3(self, span3));
}, "withSpan");
var functionWithSpan3 = /* @__PURE__ */ __name((options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error();
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = /* @__PURE__ */ __name(() => {
      if (cache !== false) {
        return cache;
      }
      if (error.stack) {
        const stack = error.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    }, "captureStackTrace");
  }
  return suspend5(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan3(suspend5(() => internalCall2(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
}, "functionWithSpan");
var fromNullable5 = /* @__PURE__ */ __name((value) => value == null ? fail6(new NoSuchElementException2()) : succeed7(value), "fromNullable");
var optionFromOptional3 = /* @__PURE__ */ __name((self) => catchAll3(map19(self, some6), (error) => isNoSuchElementException2(error) ? succeedNone3 : fail6(error)), "optionFromOptional");

// node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL4 = "Sequential";
var OP_PARALLEL4 = "Parallel";
var OP_PARALLEL_N2 = "ParallelN";
var sequential5 = {
  _tag: OP_SEQUENTIAL4
};
var parallel5 = {
  _tag: OP_PARALLEL4
};
var parallelN3 = /* @__PURE__ */ __name((parallelism) => ({
  _tag: OP_PARALLEL_N2,
  parallelism
}), "parallelN");
var isSequential2 = /* @__PURE__ */ __name((self) => self._tag === OP_SEQUENTIAL4, "isSequential");
var isParallel2 = /* @__PURE__ */ __name((self) => self._tag === OP_PARALLEL4, "isParallel");

// node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential6 = sequential5;
var parallel6 = parallel5;
var parallelN4 = parallelN3;

// node_modules/effect/dist/esm/FiberRefsPatch.js
var diff13 = diff12;
var patch15 = patch14;

// node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey2 = "effect/FiberStatus";
var FiberStatusTypeId2 = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey2);
var OP_DONE3 = "Done";
var OP_RUNNING2 = "Running";
var OP_SUSPENDED2 = "Suspended";
var DoneHash2 = /* @__PURE__ */ string2(`${FiberStatusSymbolKey2}-${OP_DONE3}`);
var Done2 = class {
  static {
    __name(this, "Done");
  }
  [FiberStatusTypeId2] = FiberStatusTypeId2;
  _tag = OP_DONE3;
  [symbol3]() {
    return DoneHash2;
  }
  [symbol4](that) {
    return isFiberStatus2(that) && that._tag === OP_DONE3;
  }
};
var Running2 = class {
  static {
    __name(this, "Running");
  }
  runtimeFlags;
  [FiberStatusTypeId2] = FiberStatusTypeId2;
  _tag = OP_RUNNING2;
  constructor(runtimeFlags3) {
    this.runtimeFlags = runtimeFlags3;
  }
  [symbol3]() {
    return pipe2(hash2(FiberStatusSymbolKey2), combine9(hash2(this._tag)), combine9(hash2(this.runtimeFlags)), cached4(this));
  }
  [symbol4](that) {
    return isFiberStatus2(that) && that._tag === OP_RUNNING2 && this.runtimeFlags === that.runtimeFlags;
  }
};
var Suspended2 = class {
  static {
    __name(this, "Suspended");
  }
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId2] = FiberStatusTypeId2;
  _tag = OP_SUSPENDED2;
  constructor(runtimeFlags3, blockingOn) {
    this.runtimeFlags = runtimeFlags3;
    this.blockingOn = blockingOn;
  }
  [symbol3]() {
    return pipe2(hash2(FiberStatusSymbolKey2), combine9(hash2(this._tag)), combine9(hash2(this.runtimeFlags)), combine9(hash2(this.blockingOn)), cached4(this));
  }
  [symbol4](that) {
    return isFiberStatus2(that) && that._tag === OP_SUSPENDED2 && this.runtimeFlags === that.runtimeFlags && equals3(this.blockingOn, that.blockingOn);
  }
};
var done9 = /* @__PURE__ */ new Done2();
var running3 = /* @__PURE__ */ __name((runtimeFlags3) => new Running2(runtimeFlags3), "running");
var suspended3 = /* @__PURE__ */ __name((runtimeFlags3, blockingOn) => new Suspended2(runtimeFlags3, blockingOn), "suspended");
var isFiberStatus2 = /* @__PURE__ */ __name((u) => hasProperty2(u, FiberStatusTypeId2), "isFiberStatus");
var isDone5 = /* @__PURE__ */ __name((self) => self._tag === OP_DONE3, "isDone");

// node_modules/effect/dist/esm/FiberStatus.js
var done10 = done9;
var running4 = running3;
var suspended4 = suspended3;
var isDone6 = isDone5;

// node_modules/effect/dist/esm/Micro.js
var TypeId28 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId2 = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId2 = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance2 = {
  _E: identity2
};
var MicroCauseImpl2 = class extends globalThis.Error {
  static {
    __name(this, "MicroCauseImpl");
  }
  _tag;
  traces;
  [MicroCauseTypeId2];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown2(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId2] = microCauseVariance2;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol2]() {
    return this.stack;
  }
};
var Die2 = class extends MicroCauseImpl2 {
  static {
    __name(this, "Die");
  }
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
var causeDie2 = /* @__PURE__ */ __name((defect, traces = []) => new Die2(defect, traces), "causeDie");
var Interrupt2 = class extends MicroCauseImpl2 {
  static {
    __name(this, "Interrupt");
  }
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt2 = /* @__PURE__ */ __name((traces = []) => new Interrupt2(traces), "causeInterrupt");
var causeIsInterrupt2 = /* @__PURE__ */ __name((self) => self._tag === "Interrupt", "causeIsInterrupt");
var MicroFiberTypeId2 = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance3 = {
  _A: identity2,
  _E: identity2
};
var MicroFiberImpl2 = class {
  static {
    __name(this, "MicroFiberImpl");
  }
  context;
  interruptible;
  [MicroFiberTypeId2];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context7, interruptible9 = true) {
    this.context = context7;
    this.interruptible = interruptible9;
    this[MicroFiberTypeId2] = fiberVariance3;
  }
  getRef(ref) {
    return unsafeGetReference2(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid2;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt4);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit7 = this.runLoop(effect);
    if (exit7 === Yield2) {
      return;
    }
    const interruptChildren = fiberMiddleware2.interruptChildren && fiberMiddleware2.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap17(interruptChildren, () => exit7));
    }
    this._exit = exit7;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit7);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler2).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap17(yieldNow6, () => prev);
        }
        current = current[evaluate2](this);
        if (current === Yield2) {
          const yielded = this._yielded;
          if (MicroExitTypeId2 in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield2;
        }
      }
    } catch (error) {
      if (!hasProperty2(current, evaluate2)) {
        return exitDie4(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie4(error);
    }
  }
  getCont(symbol5) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont2] && op[ensureCont2](this);
      if (cont) return {
        [symbol5]: cont
      };
      if (op[symbol5]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value) {
    this._yielded = value;
    return Yield2;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
var fiberMiddleware2 = /* @__PURE__ */ globalValue2("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberInterruptAll2 = /* @__PURE__ */ __name((fibers) => suspend6(() => {
  for (const fiber of fibers) fiber.unsafeInterrupt();
  const iter = fibers[Symbol.iterator]();
  const wait = suspend6(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async3((resume3) => {
        fiber.addObserver((_) => {
          resume3(wait);
        });
      });
    }
    return exitVoid4;
  });
  return wait;
}), "fiberInterruptAll");
var identifier2 = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args2 = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate2 = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont2 = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont2 = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont2 = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield2 = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance2 = {
  _A: identity2,
  _E: identity2,
  _R: identity2
};
var MicroProto2 = {
  ...EffectPrototype4,
  _op: "Micro",
  [TypeId28]: microVariance2,
  pipe() {
    return pipeArguments2(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen3(new YieldWrap2(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier2],
      ...args2 in this ? {
        args: this[args2]
      } : void 0
    };
  },
  toString() {
    return format4(this);
  },
  [NodeInspectSymbol2]() {
    return format4(this);
  }
};
function defaultEvaluate2(_fiber) {
  return exitDie4(`Micro.evaluate: Not implemented`);
}
__name(defaultEvaluate2, "defaultEvaluate");
var makePrimitiveProto2 = /* @__PURE__ */ __name((options) => ({
  ...MicroProto2,
  [identifier2]: options.op,
  [evaluate2]: options.eval ?? defaultEvaluate2,
  [successCont2]: options.contA,
  [failureCont2]: options.contE,
  [ensureCont2]: options.ensure
}), "makePrimitiveProto");
var makePrimitive2 = /* @__PURE__ */ __name((options) => {
  const Proto3 = makePrimitiveProto2(options);
  return function() {
    const self = Object.create(Proto3);
    self[args2] = options.single === false ? arguments : arguments[0];
    return self;
  };
}, "makePrimitive");
var makeExit2 = /* @__PURE__ */ __name((options) => {
  const Proto3 = {
    ...makePrimitiveProto2(options),
    [MicroExitTypeId2]: MicroExitTypeId2,
    _tag: options.op,
    get [options.prop]() {
      return this[args2];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args2]
      };
    },
    [symbol4](that) {
      return isMicroExit2(that) && that._tag === options.op && equals3(this[args2], that[args2]);
    },
    [symbol3]() {
      return cached4(this, combine9(string2(options.op))(hash2(this[args2])));
    }
  };
  return function(value) {
    const self = Object.create(Proto3);
    self[args2] = value;
    self[successCont2] = void 0;
    self[failureCont2] = void 0;
    self[ensureCont2] = void 0;
    return self;
  };
}, "makeExit");
var succeed9 = /* @__PURE__ */ makeExit2({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont2);
    return cont ? cont[successCont2](this[args2], fiber) : fiber.yieldWith(this);
  }
});
var failCause6 = /* @__PURE__ */ makeExit2({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont2);
    while (causeIsInterrupt2(this[args2]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont2);
    }
    return cont ? cont[failureCont2](this[args2], fiber) : fiber.yieldWith(this);
  }
});
var sync6 = /* @__PURE__ */ makePrimitive2({
  op: "Sync",
  eval(fiber) {
    const value = this[args2]();
    const cont = fiber.getCont(successCont2);
    return cont ? cont[successCont2](value, fiber) : fiber.yieldWith(exitSucceed4(value));
  }
});
var suspend6 = /* @__PURE__ */ makePrimitive2({
  op: "Suspend",
  eval(_fiber) {
    return this[args2]();
  }
});
var yieldNowWith2 = /* @__PURE__ */ makePrimitive2({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler2).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid4);
    }, this[args2] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow6 = /* @__PURE__ */ yieldNowWith2(0);
var void_4 = /* @__PURE__ */ succeed9(void 0);
var withMicroFiber2 = /* @__PURE__ */ makePrimitive2({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args2](fiber);
  }
});
var asyncOptions2 = /* @__PURE__ */ makePrimitive2({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args2][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args2][1] ? new AbortController() : void 0;
    const onCancel = register((effect) => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect);
      } else {
        yielded = effect;
      }
    }, controller?.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield2;
    }
    fiber._stack.push(asyncFinalizer2(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid4;
    }));
    return Yield2;
  }
});
var asyncFinalizer2 = /* @__PURE__ */ makePrimitive2({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible2(true));
    }
  },
  contE(cause5, _fiber) {
    return causeIsInterrupt2(cause5) ? flatMap17(this[args2](), () => failCause6(cause5)) : failCause6(cause5);
  }
});
var async3 = /* @__PURE__ */ __name((register) => asyncOptions2(register, register.length >= 2), "async");
var as5 = /* @__PURE__ */ dual2(2, (self, value) => map20(self, (_) => value));
var exit5 = /* @__PURE__ */ __name((self) => matchCause5(self, {
  onFailure: exitFailCause4,
  onSuccess: exitSucceed4
}), "exit");
var flatMap17 = /* @__PURE__ */ dual2(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto2);
  onSuccess[args2] = self;
  onSuccess[successCont2] = f;
  return onSuccess;
});
var OnSuccessProto2 = /* @__PURE__ */ makePrimitiveProto2({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args2];
  }
});
var map20 = /* @__PURE__ */ dual2(2, (self, f) => flatMap17(self, (a) => succeed9(f(a))));
var isMicroExit2 = /* @__PURE__ */ __name((u) => hasProperty2(u, MicroExitTypeId2), "isMicroExit");
var exitSucceed4 = succeed9;
var exitFailCause4 = failCause6;
var exitInterrupt4 = /* @__PURE__ */ exitFailCause4(/* @__PURE__ */ causeInterrupt2());
var exitDie4 = /* @__PURE__ */ __name((defect) => exitFailCause4(causeDie2(defect)), "exitDie");
var exitVoid4 = /* @__PURE__ */ exitSucceed4(void 0);
var exitVoidAll2 = /* @__PURE__ */ __name((exits) => {
  for (const exit7 of exits) {
    if (exit7._tag === "Failure") {
      return exit7;
    }
  }
  return exitVoid4;
}, "exitVoidAll");
var setImmediate2 = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault2 = class {
  static {
    __name(this, "MicroSchedulerDefault");
  }
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate2(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = /* @__PURE__ */ __name(() => {
    this.running = false;
    this.runTasks();
  }, "afterScheduled");
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield2);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var updateContext2 = /* @__PURE__ */ dual2(2, (self, f) => withMicroFiber2((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit5(self, () => {
    fiber.context = prev;
    return void_4;
  });
}));
var provideContext4 = /* @__PURE__ */ dual2(2, (self, provided) => updateContext2(self, merge9(provided)));
var MaxOpsBeforeYield2 = class extends (/* @__PURE__ */ Reference4()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: /* @__PURE__ */ __name(() => 2048, "defaultValue")
})) {
  static {
    __name(this, "MaxOpsBeforeYield");
  }
};
var CurrentConcurrency2 = class extends (/* @__PURE__ */ Reference4()("effect/Micro/currentConcurrency", {
  defaultValue: /* @__PURE__ */ __name(() => "unbounded", "defaultValue")
})) {
  static {
    __name(this, "CurrentConcurrency");
  }
};
var CurrentScheduler2 = class extends (/* @__PURE__ */ Reference4()("effect/Micro/currentScheduler", {
  defaultValue: /* @__PURE__ */ __name(() => new MicroSchedulerDefault2(), "defaultValue")
})) {
  static {
    __name(this, "CurrentScheduler");
  }
};
var matchCauseEffect5 = /* @__PURE__ */ dual2(2, (self, options) => {
  const primitive = Object.create(OnSuccessAndFailureProto2);
  primitive[args2] = self;
  primitive[successCont2] = options.onSuccess;
  primitive[failureCont2] = options.onFailure;
  return primitive;
});
var OnSuccessAndFailureProto2 = /* @__PURE__ */ makePrimitiveProto2({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args2];
  }
});
var matchCause5 = /* @__PURE__ */ dual2(2, (self, options) => matchCauseEffect5(self, {
  onFailure: /* @__PURE__ */ __name((cause5) => sync6(() => options.onFailure(cause5)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((value) => sync6(() => options.onSuccess(value)), "onSuccess")
}));
var MicroScopeTypeId2 = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
var MicroScopeImpl2 = class _MicroScopeImpl {
  static {
    __name(this, "MicroScopeImpl");
  }
  [MicroScopeTypeId2];
  state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Set()
  };
  constructor() {
    this[MicroScopeTypeId2] = MicroScopeTypeId2;
  }
  unsafeAddFinalizer(finalizer) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer);
    }
  }
  addFinalizer(finalizer) {
    return suspend6(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer);
        return void_4;
      }
      return finalizer(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer);
    }
  }
  close(microExit) {
    return suspend6(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap17(forEach12(finalizers, (finalizer) => exit5(finalizer(microExit))), exitVoidAll2);
      }
      return void_4;
    });
  }
  get fork() {
    return sync6(() => {
      const newScope = new _MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit7) {
        return newScope.close(exit7);
      }
      __name(fin, "fin");
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_) => sync6(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
var onExit5 = /* @__PURE__ */ dual2(2, (self, f) => uninterruptibleMask5((restore) => matchCauseEffect5(restore(self), {
  onFailure: /* @__PURE__ */ __name((cause5) => flatMap17(f(exitFailCause4(cause5)), () => failCause6(cause5)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => flatMap17(f(exitSucceed4(a)), () => succeed9(a)), "onSuccess")
})));
var setInterruptible2 = /* @__PURE__ */ makePrimitive2({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args2];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt4;
    }
  }
});
var interruptible7 = /* @__PURE__ */ __name((self) => withMicroFiber2((fiber) => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible2(false));
  if (fiber._interrupted) return exitInterrupt4;
  return self;
}), "interruptible");
var uninterruptibleMask5 = /* @__PURE__ */ __name((f) => withMicroFiber2((fiber) => {
  if (!fiber.interruptible) return f(identity2);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible2(true));
  return f(interruptible7);
}), "uninterruptibleMask");
var whileLoop5 = /* @__PURE__ */ makePrimitive2({
  op: "While",
  contA(value, fiber) {
    this[args2].step(value);
    if (this[args2].while()) {
      fiber._stack.push(this);
      return this[args2].body();
    }
    return exitVoid4;
  },
  eval(fiber) {
    if (this[args2].while()) {
      fiber._stack.push(this);
      return this[args2].body();
    }
    return exitVoid4;
  }
});
var forEach12 = /* @__PURE__ */ __name((iterable, f, options) => withMicroFiber2((parent) => {
  const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency2) : options?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable11(iterable);
  let length3 = items.length;
  if (length3 === 0) {
    return options?.discard ? void_4 : succeed9([]);
  }
  const out = options?.discard ? void 0 : new Array(length3);
  let index = 0;
  if (concurrency === 1) {
    return as5(whileLoop5({
      while: /* @__PURE__ */ __name(() => index < items.length, "while"),
      body: /* @__PURE__ */ __name(() => f(items[index], index), "body"),
      step: out ? (b) => out[index++] = b : (_) => index++
    }), out);
  }
  return async3((resume3) => {
    const fibers = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index < length3) {
        const currentIndex = index;
        const item = items[currentIndex];
        index++;
        inProgress++;
        try {
          const child = unsafeFork4(parent, f(item, currentIndex), true, true);
          fibers.add(child);
          child.addObserver((exit7) => {
            fibers.delete(child);
            if (interrupted) {
              return;
            } else if (exit7._tag === "Failure") {
              if (result === void 0) {
                result = exit7;
                length3 = index;
                fibers.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit7.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length3) {
              resume3(result ?? succeed9(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err) {
          result = exitDie4(err);
          length3 = index;
          fibers.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    __name(pump, "pump");
    pump();
    return suspend6(() => {
      interrupted = true;
      index = length3;
      return fiberInterruptAll2(fibers);
    });
  });
}), "forEach");
var unsafeFork4 = /* @__PURE__ */ __name((parent, effect, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl2(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect);
  } else {
    parent.getRef(CurrentScheduler2).scheduleTask(() => child.evaluate(effect), 0);
  }
  return child;
}, "unsafeFork");
var runFork3 = /* @__PURE__ */ __name((effect, options) => {
  const fiber = new MicroFiberImpl2(CurrentScheduler2.context(options?.scheduler ?? new MicroSchedulerDefault2()));
  fiber.evaluate(effect);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = /* @__PURE__ */ __name(() => fiber.unsafeInterrupt(), "abort");
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
}, "runFork");

// node_modules/effect/dist/esm/Scheduler.js
var PriorityBuckets2 = class {
  static {
    __name(this, "PriorityBuckets");
  }
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length3 = this.buckets.length;
    let bucket = void 0;
    let index = 0;
    for (; index < length3; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length3) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler2 = class {
  static {
    __name(this, "MixedScheduler");
  }
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets2();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield2) ? fiber.getFiberRef(currentSchedulingPriority2) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler2(2048));
var SyncScheduler2 = class {
  static {
    __name(this, "SyncScheduler");
  }
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets2();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler2.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield2) ? fiber.getFiberRef(currentSchedulingPriority2) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var currentScheduler2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake2(defaultScheduler2));
var withScheduler3 = /* @__PURE__ */ dual2(2, (self, scheduler) => fiberRefLocally2(self, currentScheduler2, scheduler));

// node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake2(/* @__PURE__ */ new Map()));

// node_modules/effect/dist/esm/internal/concurrency.js
var match17 = /* @__PURE__ */ __name((concurrency, sequential7, unbounded3, bounded) => {
  switch (concurrency) {
    case void 0:
      return sequential7();
    case "unbounded":
      return unbounded3();
    case "inherit":
      return fiberRefGetWith2(currentConcurrency2, (concurrency2) => concurrency2 === "unbounded" ? unbounded3() : concurrency2 > 1 ? bounded(concurrency2) : sequential7());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential7();
  }
}, "match");
var matchSimple2 = /* @__PURE__ */ __name((concurrency, sequential7, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential7();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith2(currentConcurrency2, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential7());
    default:
      return concurrency > 1 ? concurrent() : sequential7();
  }
}, "matchSimple");

// node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL2 = "InterruptSignal";
var OP_STATEFUL2 = "Stateful";
var OP_RESUME2 = "Resume";
var OP_YIELD_NOW2 = "YieldNow";
var interruptSignal2 = /* @__PURE__ */ __name((cause5) => ({
  _tag: OP_INTERRUPT_SIGNAL2,
  cause: cause5
}), "interruptSignal");
var stateful2 = /* @__PURE__ */ __name((onFiber) => ({
  _tag: OP_STATEFUL2,
  onFiber
}), "stateful");
var resume2 = /* @__PURE__ */ __name((effect) => ({
  _tag: OP_RESUME2,
  effect
}), "resume");
var yieldNow7 = /* @__PURE__ */ __name(() => ({
  _tag: OP_YIELD_NOW2
}), "yieldNow");

// node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey2 = "effect/FiberScope";
var FiberScopeTypeId2 = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey2);
var Global2 = class {
  static {
    __name(this, "Global");
  }
  [FiberScopeTypeId2] = FiberScopeTypeId2;
  fiberId = none13;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var Local2 = class {
  static {
    __name(this, "Local");
  }
  fiberId;
  parent;
  [FiberScopeTypeId2] = FiberScopeTypeId2;
  constructor(fiberId5, parent) {
    this.fiberId = fiberId5;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful2((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake13 = /* @__PURE__ */ __name((fiber) => {
  return new Local2(fiber.id(), fiber);
}, "unsafeMake");
var globalScope2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global2());

// node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey2 = "effect/Fiber";
var FiberTypeId2 = /* @__PURE__ */ Symbol.for(FiberSymbolKey2);
var fiberVariance4 = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var fiberProto2 = {
  [FiberTypeId2]: fiberVariance4,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var RuntimeFiberSymbolKey2 = "effect/Fiber";
var RuntimeFiberTypeId2 = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey2);
var isRuntimeFiber2 = /* @__PURE__ */ __name((self) => RuntimeFiberTypeId2 in self, "isRuntimeFiber");
var _await4 = /* @__PURE__ */ __name((self) => self.await, "_await");
var inheritAll2 = /* @__PURE__ */ __name((self) => self.inheritAll, "inheritAll");
var interruptAllAs2 = /* @__PURE__ */ dual2(2, /* @__PURE__ */ fnUntraced3(function* (fibers, fiberId5) {
  for (const fiber of fibers) {
    if (isRuntimeFiber2(fiber)) {
      fiber.unsafeInterruptAsFork(fiberId5);
      continue;
    }
    yield* fiber.interruptAsFork(fiberId5);
  }
  for (const fiber of fibers) {
    if (isRuntimeFiber2(fiber) && fiber.unsafePoll()) {
      continue;
    }
    yield* fiber.await;
  }
}));
var interruptAsFork2 = /* @__PURE__ */ dual2(2, (self, fiberId5) => self.interruptAsFork(fiberId5));
var join4 = /* @__PURE__ */ __name((self) => zipLeft3(flatten10(self.await), self.inheritAll), "join");
var _never2 = {
  ...CommitPrototype3,
  commit() {
    return join4(this);
  },
  ...fiberProto2,
  id: /* @__PURE__ */ __name(() => none13, "id"),
  await: never3,
  children: /* @__PURE__ */ succeed7([]),
  inheritAll: never3,
  poll: /* @__PURE__ */ succeed7(/* @__PURE__ */ none11()),
  interruptAsFork: /* @__PURE__ */ __name(() => never3, "interruptAsFork")
};
var currentFiberURI2 = "effect/FiberCurrent";

// node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey2 = "effect/Logger";
var LoggerTypeId2 = /* @__PURE__ */ Symbol.for(LoggerSymbolKey2);
var loggerVariance2 = {
  /* c8 ignore next */
  _Message: /* @__PURE__ */ __name((_) => _, "_Message"),
  /* c8 ignore next */
  _Output: /* @__PURE__ */ __name((_) => _, "_Output")
};
var makeLogger2 = /* @__PURE__ */ __name((log5) => ({
  [LoggerTypeId2]: loggerVariance2,
  log: log5,
  pipe() {
    return pipeArguments2(this, arguments);
  }
}), "makeLogger");
var none16 = {
  [LoggerTypeId2]: loggerVariance2,
  log: constVoid2,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var textOnly2 = /^[^\s"=]*$/;
var format6 = /* @__PURE__ */ __name((quoteValue, whitespace) => ({
  annotations,
  cause: cause5,
  date,
  fiberId: fiberId5,
  logLevel,
  message,
  spans
}) => {
  const formatValue = /* @__PURE__ */ __name((value) => value.match(textOnly2) ? value : quoteValue(value), "formatValue");
  const format7 = /* @__PURE__ */ __name((label, value) => `${formatLabel2(label)}=${formatValue(value)}`, "format");
  const append7 = /* @__PURE__ */ __name((label, value) => " " + format7(label, value), "append");
  let out = format7("timestamp", date.toISOString());
  out += append7("level", logLevel.label);
  out += append7("fiber", threadName3(fiberId5));
  const messages = ensure2(message);
  for (let i = 0; i < messages.length; i++) {
    out += append7("message", toStringUnknown2(messages[i], whitespace));
  }
  if (!isEmptyType2(cause5)) {
    out += append7("cause", pretty2(cause5, {
      renderErrorCause: true
    }));
  }
  for (const span3 of spans) {
    out += " " + render2(date.getTime())(span3);
  }
  for (const [label, value] of annotations) {
    out += append7(label, toStringUnknown2(value, whitespace));
  }
  return out;
}, "format");
var escapeDoubleQuotes2 = /* @__PURE__ */ __name((s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`, "escapeDoubleQuotes");
var stringLogger2 = /* @__PURE__ */ makeLogger2(/* @__PURE__ */ format6(escapeDoubleQuotes2));
var colors2 = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors2 = {
  None: [],
  All: [],
  Trace: [colors2.gray],
  Debug: [colors2.blue],
  Info: [colors2.green],
  Warning: [colors2.yellow],
  Error: [colors2.red],
  Fatal: [colors2.bgBrightRed, colors2.black]
};
var hasProcessStdout2 = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY2 = hasProcessStdout2 && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno2 = hasProcessStdout2 || "Deno" in globalThis;

// node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey2 = "effect/MetricBoundaries";
var MetricBoundariesTypeId2 = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey2);
var MetricBoundariesImpl2 = class {
  static {
    __name(this, "MetricBoundariesImpl");
  }
  values;
  [MetricBoundariesTypeId2] = MetricBoundariesTypeId2;
  constructor(values5) {
    this.values = values5;
    this._hash = pipe2(string2(MetricBoundariesSymbolKey2), combine9(array5(this.values)));
  }
  _hash;
  [symbol3]() {
    return this._hash;
  }
  [symbol4](u) {
    return isMetricBoundaries2(u) && equals3(this.values, u.values);
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var isMetricBoundaries2 = /* @__PURE__ */ __name((u) => hasProperty2(u, MetricBoundariesTypeId2), "isMetricBoundaries");
var fromIterable17 = /* @__PURE__ */ __name((iterable) => {
  const values5 = pipe2(iterable, appendAll4(of6(Number.POSITIVE_INFINITY)), dedupe2);
  return new MetricBoundariesImpl2(values5);
}, "fromIterable");
var exponential2 = /* @__PURE__ */ __name((options) => pipe2(makeBy2(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray2, fromIterable17), "exponential");

// node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey2 = "effect/MetricKeyType";
var MetricKeyTypeTypeId2 = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey2);
var CounterKeyTypeSymbolKey2 = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId2 = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey2);
var FrequencyKeyTypeSymbolKey2 = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId2 = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey2);
var GaugeKeyTypeSymbolKey2 = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId2 = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey2);
var HistogramKeyTypeSymbolKey2 = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId2 = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey2);
var SummaryKeyTypeSymbolKey2 = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId2 = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey2);
var metricKeyTypeVariance2 = {
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var CounterKeyType2 = class {
  static {
    __name(this, "CounterKeyType");
  }
  incremental;
  bigint;
  [MetricKeyTypeTypeId2] = metricKeyTypeVariance2;
  [CounterKeyTypeTypeId2] = CounterKeyTypeTypeId2;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string2(CounterKeyTypeSymbolKey2);
  }
  _hash;
  [symbol3]() {
    return this._hash;
  }
  [symbol4](that) {
    return isCounterKey2(that);
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var FrequencyKeyTypeHash2 = /* @__PURE__ */ string2(FrequencyKeyTypeSymbolKey2);
var FrequencyKeyType2 = class {
  static {
    __name(this, "FrequencyKeyType");
  }
  preregisteredWords;
  [MetricKeyTypeTypeId2] = metricKeyTypeVariance2;
  [FrequencyKeyTypeTypeId2] = FrequencyKeyTypeTypeId2;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [symbol3]() {
    return FrequencyKeyTypeHash2;
  }
  [symbol4](that) {
    return isFrequencyKey2(that);
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var GaugeKeyTypeHash2 = /* @__PURE__ */ string2(GaugeKeyTypeSymbolKey2);
var GaugeKeyType2 = class {
  static {
    __name(this, "GaugeKeyType");
  }
  bigint;
  [MetricKeyTypeTypeId2] = metricKeyTypeVariance2;
  [GaugeKeyTypeTypeId2] = GaugeKeyTypeTypeId2;
  constructor(bigint) {
    this.bigint = bigint;
  }
  [symbol3]() {
    return GaugeKeyTypeHash2;
  }
  [symbol4](that) {
    return isGaugeKey2(that);
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var HistogramKeyType2 = class {
  static {
    __name(this, "HistogramKeyType");
  }
  boundaries;
  [MetricKeyTypeTypeId2] = metricKeyTypeVariance2;
  [HistogramKeyTypeTypeId2] = HistogramKeyTypeTypeId2;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe2(string2(HistogramKeyTypeSymbolKey2), combine9(hash2(this.boundaries)));
  }
  _hash;
  [symbol3]() {
    return this._hash;
  }
  [symbol4](that) {
    return isHistogramKey2(that) && equals3(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var SummaryKeyType2 = class {
  static {
    __name(this, "SummaryKeyType");
  }
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId2] = metricKeyTypeVariance2;
  [SummaryKeyTypeTypeId2] = SummaryKeyTypeTypeId2;
  constructor(maxAge, maxSize, error, quantiles) {
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error;
    this.quantiles = quantiles;
    this._hash = pipe2(string2(SummaryKeyTypeSymbolKey2), combine9(hash2(this.maxAge)), combine9(hash2(this.maxSize)), combine9(hash2(this.error)), combine9(array5(this.quantiles)));
  }
  _hash;
  [symbol3]() {
    return this._hash;
  }
  [symbol4](that) {
    return isSummaryKey2(that) && equals3(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals3(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var counter6 = /* @__PURE__ */ __name((options) => new CounterKeyType2(options?.incremental ?? false, options?.bigint ?? false), "counter");
var histogram6 = /* @__PURE__ */ __name((boundaries) => {
  return new HistogramKeyType2(boundaries);
}, "histogram");
var isCounterKey2 = /* @__PURE__ */ __name((u) => hasProperty2(u, CounterKeyTypeTypeId2), "isCounterKey");
var isFrequencyKey2 = /* @__PURE__ */ __name((u) => hasProperty2(u, FrequencyKeyTypeTypeId2), "isFrequencyKey");
var isGaugeKey2 = /* @__PURE__ */ __name((u) => hasProperty2(u, GaugeKeyTypeTypeId2), "isGaugeKey");
var isHistogramKey2 = /* @__PURE__ */ __name((u) => hasProperty2(u, HistogramKeyTypeTypeId2), "isHistogramKey");
var isSummaryKey2 = /* @__PURE__ */ __name((u) => hasProperty2(u, SummaryKeyTypeTypeId2), "isSummaryKey");

// node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey2 = "effect/MetricKey";
var MetricKeyTypeId2 = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey2);
var metricKeyVariance2 = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type")
};
var arrayEquivilence2 = /* @__PURE__ */ getEquivalence4(equals3);
var MetricKeyImpl2 = class {
  static {
    __name(this, "MetricKeyImpl");
  }
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId2] = metricKeyVariance2;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe2(string2(this.name + this.description), combine9(hash2(this.keyType)), combine9(array5(this.tags)));
  }
  _hash;
  [symbol3]() {
    return this._hash;
  }
  [symbol4](u) {
    return isMetricKey2(u) && this.name === u.name && equals3(this.keyType, u.keyType) && equals3(this.description, u.description) && arrayEquivilence2(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var isMetricKey2 = /* @__PURE__ */ __name((u) => hasProperty2(u, MetricKeyTypeId2), "isMetricKey");
var counter7 = /* @__PURE__ */ __name((name, options) => new MetricKeyImpl2(name, counter6(options), fromNullable4(options?.description)), "counter");
var histogram7 = /* @__PURE__ */ __name((name, boundaries, description) => new MetricKeyImpl2(name, histogram6(boundaries), fromNullable4(description)), "histogram");
var taggedWithLabels3 = /* @__PURE__ */ dual2(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl2(self.name, self.keyType, self.description, union8(self.tags, extraTags)));

// node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey2 = "effect/MetricState";
var MetricStateTypeId2 = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey2);
var CounterStateSymbolKey2 = "effect/MetricState/Counter";
var CounterStateTypeId2 = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey2);
var FrequencyStateSymbolKey2 = "effect/MetricState/Frequency";
var FrequencyStateTypeId2 = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey2);
var GaugeStateSymbolKey2 = "effect/MetricState/Gauge";
var GaugeStateTypeId2 = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey2);
var HistogramStateSymbolKey2 = "effect/MetricState/Histogram";
var HistogramStateTypeId2 = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey2);
var SummaryStateSymbolKey2 = "effect/MetricState/Summary";
var SummaryStateTypeId2 = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey2);
var metricStateVariance2 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var CounterState2 = class {
  static {
    __name(this, "CounterState");
  }
  count;
  [MetricStateTypeId2] = metricStateVariance2;
  [CounterStateTypeId2] = CounterStateTypeId2;
  constructor(count) {
    this.count = count;
  }
  [symbol3]() {
    return pipe2(hash2(CounterStateSymbolKey2), combine9(hash2(this.count)), cached4(this));
  }
  [symbol4](that) {
    return isCounterState2(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var arrayEquals2 = /* @__PURE__ */ getEquivalence4(equals3);
var FrequencyState2 = class {
  static {
    __name(this, "FrequencyState");
  }
  occurrences;
  [MetricStateTypeId2] = metricStateVariance2;
  [FrequencyStateTypeId2] = FrequencyStateTypeId2;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol3]() {
    return pipe2(string2(FrequencyStateSymbolKey2), combine9(array5(fromIterable11(this.occurrences.entries()))), cached4(this));
  }
  [symbol4](that) {
    return isFrequencyState2(that) && arrayEquals2(fromIterable11(this.occurrences.entries()), fromIterable11(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var GaugeState2 = class {
  static {
    __name(this, "GaugeState");
  }
  value;
  [MetricStateTypeId2] = metricStateVariance2;
  [GaugeStateTypeId2] = GaugeStateTypeId2;
  constructor(value) {
    this.value = value;
  }
  [symbol3]() {
    return pipe2(hash2(GaugeStateSymbolKey2), combine9(hash2(this.value)), cached4(this));
  }
  [symbol4](u) {
    return isGaugeState2(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var HistogramState2 = class {
  static {
    __name(this, "HistogramState");
  }
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId2] = metricStateVariance2;
  [HistogramStateTypeId2] = HistogramStateTypeId2;
  constructor(buckets, count, min5, max9, sum3) {
    this.buckets = buckets;
    this.count = count;
    this.min = min5;
    this.max = max9;
    this.sum = sum3;
  }
  [symbol3]() {
    return pipe2(hash2(HistogramStateSymbolKey2), combine9(hash2(this.buckets)), combine9(hash2(this.count)), combine9(hash2(this.min)), combine9(hash2(this.max)), combine9(hash2(this.sum)), cached4(this));
  }
  [symbol4](that) {
    return isHistogramState2(that) && equals3(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var SummaryState2 = class {
  static {
    __name(this, "SummaryState");
  }
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId2] = metricStateVariance2;
  [SummaryStateTypeId2] = SummaryStateTypeId2;
  constructor(error, quantiles, count, min5, max9, sum3) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min5;
    this.max = max9;
    this.sum = sum3;
  }
  [symbol3]() {
    return pipe2(hash2(SummaryStateSymbolKey2), combine9(hash2(this.error)), combine9(hash2(this.quantiles)), combine9(hash2(this.count)), combine9(hash2(this.min)), combine9(hash2(this.max)), combine9(hash2(this.sum)), cached4(this));
  }
  [symbol4](that) {
    return isSummaryState2(that) && this.error === that.error && equals3(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var counter8 = /* @__PURE__ */ __name((count) => new CounterState2(count), "counter");
var frequency6 = /* @__PURE__ */ __name((occurrences) => {
  return new FrequencyState2(occurrences);
}, "frequency");
var gauge6 = /* @__PURE__ */ __name((count) => new GaugeState2(count), "gauge");
var histogram8 = /* @__PURE__ */ __name((options) => new HistogramState2(options.buckets, options.count, options.min, options.max, options.sum), "histogram");
var summary6 = /* @__PURE__ */ __name((options) => new SummaryState2(options.error, options.quantiles, options.count, options.min, options.max, options.sum), "summary");
var isCounterState2 = /* @__PURE__ */ __name((u) => hasProperty2(u, CounterStateTypeId2), "isCounterState");
var isFrequencyState2 = /* @__PURE__ */ __name((u) => hasProperty2(u, FrequencyStateTypeId2), "isFrequencyState");
var isGaugeState2 = /* @__PURE__ */ __name((u) => hasProperty2(u, GaugeStateTypeId2), "isGaugeState");
var isHistogramState2 = /* @__PURE__ */ __name((u) => hasProperty2(u, HistogramStateTypeId2), "isHistogramState");
var isSummaryState2 = /* @__PURE__ */ __name((u) => hasProperty2(u, SummaryStateTypeId2), "isSummaryState");

// node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey2 = "effect/MetricHook";
var MetricHookTypeId2 = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey2);
var metricHookVariance2 = {
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var make67 = /* @__PURE__ */ __name((options) => ({
  [MetricHookTypeId2]: metricHookVariance2,
  pipe() {
    return pipeArguments2(this, arguments);
  },
  ...options
}), "make");
var bigint06 = /* @__PURE__ */ BigInt(0);
var counter9 = /* @__PURE__ */ __name((key) => {
  let sum3 = key.keyType.bigint ? bigint06 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint06 : (value) => value >= 0 : (_value) => true;
  const update9 = /* @__PURE__ */ __name((value) => {
    if (canUpdate(value)) {
      sum3 = sum3 + value;
    }
  }, "update");
  return make67({
    get: /* @__PURE__ */ __name(() => counter8(sum3), "get"),
    update: update9,
    modify: update9
  });
}, "counter");
var frequency7 = /* @__PURE__ */ __name((key) => {
  const values5 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values5.set(word, 0);
  }
  const update9 = /* @__PURE__ */ __name((word) => {
    const slotCount = values5.get(word) ?? 0;
    values5.set(word, slotCount + 1);
  }, "update");
  return make67({
    get: /* @__PURE__ */ __name(() => frequency6(values5), "get"),
    update: update9,
    modify: update9
  });
}, "frequency");
var gauge7 = /* @__PURE__ */ __name((_key, startAt) => {
  let value = startAt;
  return make67({
    get: /* @__PURE__ */ __name(() => gauge6(value), "get"),
    update: /* @__PURE__ */ __name((v) => {
      value = v;
    }, "update"),
    modify: /* @__PURE__ */ __name((v) => {
      value = value + v;
    }, "modify")
  });
}, "gauge");
var histogram9 = /* @__PURE__ */ __name((key) => {
  const bounds = key.keyType.boundaries.values;
  const size17 = bounds.length;
  const values5 = new Uint32Array(size17 + 1);
  const boundaries = new Float64Array(size17);
  let count = 0;
  let sum3 = 0;
  let min5 = Number.MAX_VALUE;
  let max9 = Number.MIN_VALUE;
  pipe2(bounds, sort2(Order3), map13((n, i) => {
    boundaries[i] = n;
  }));
  const update9 = /* @__PURE__ */ __name((value) => {
    let from = 0;
    let to = size17;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values5[from] = values5[from] + 1;
    count = count + 1;
    sum3 = sum3 + value;
    if (value < min5) {
      min5 = value;
    }
    if (value > max9) {
      max9 = value;
    }
  }, "update");
  const getBuckets = /* @__PURE__ */ __name(() => {
    const builder = allocate2(size17);
    let cumulated = 0;
    for (let i = 0; i < size17; i++) {
      const boundary = boundaries[i];
      const value = values5[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  }, "getBuckets");
  return make67({
    get: /* @__PURE__ */ __name(() => histogram8({
      buckets: getBuckets(),
      count,
      min: min5,
      max: max9,
      sum: sum3
    }), "get"),
    update: update9,
    modify: update9
  });
}, "histogram");
var summary7 = /* @__PURE__ */ __name((key) => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe2(quantiles, sort2(Order3));
  const values5 = allocate2(maxSize);
  let head9 = 0;
  let count = 0;
  let sum3 = 0;
  let min5 = 0;
  let max9 = 0;
  const snapshot = /* @__PURE__ */ __name((now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values5[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis2(now - t);
        if (greaterThanOrEqualTo4(age, zero2) && lessThanOrEqualTo4(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles2(error, sortedQuantiles, sort2(builder, Order3));
  }, "snapshot");
  const observe = /* @__PURE__ */ __name((value, timestamp) => {
    if (maxSize > 0) {
      head9 = head9 + 1;
      const target = head9 % maxSize;
      values5[target] = [timestamp, value];
    }
    min5 = count === 0 ? value : Math.min(min5, value);
    max9 = count === 0 ? value : Math.max(max9, value);
    count = count + 1;
    sum3 = sum3 + value;
  }, "observe");
  return make67({
    get: /* @__PURE__ */ __name(() => summary6({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min: min5,
      max: max9,
      sum: sum3
    }), "get"),
    update: /* @__PURE__ */ __name(([value, timestamp]) => observe(value, timestamp), "update"),
    modify: /* @__PURE__ */ __name(([value, timestamp]) => observe(value, timestamp), "modify")
  });
}, "summary");
var calculateQuantiles2 = /* @__PURE__ */ __name((error, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray2(sortedQuantiles)) {
    return empty29();
  }
  const head9 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile2(error, sampleCount, none11(), 0, head9, sortedSamples);
  const resolved = of5(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile2(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map13(resolved, (rq) => [rq.quantile, rq.value]);
}, "calculateQuantiles");
var resolveQuantile2 = /* @__PURE__ */ __name((error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray2(rest_1)) {
      return {
        quantile: quantile_1,
        value: none11(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some6(lastNonEmpty2(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty3(rest_1);
    const sameHead = span2(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head5(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone5(current_1) ? some6(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head5(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head5(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some6(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "resolveQuantile");

// node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey2 = "effect/MetricPair";
var MetricPairTypeId2 = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey2);
var metricPairVariance2 = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type")
};
var unsafeMake14 = /* @__PURE__ */ __name((metricKey, metricState) => {
  return {
    [MetricPairTypeId2]: metricPairVariance2,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments2(this, arguments);
    }
  };
}, "unsafeMake");

// node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey2 = "effect/MetricRegistry";
var MetricRegistryTypeId2 = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey2);
var MetricRegistryImpl2 = class {
  static {
    __name(this, "MetricRegistryImpl");
  }
  [MetricRegistryTypeId2] = MetricRegistryTypeId2;
  map = /* @__PURE__ */ empty45();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake14(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe2(this.map, get20(key), getOrUndefined2);
    if (hook == null) {
      if (isCounterKey2(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey2(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey2(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey2(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey2(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe2(this.map, get20(key), getOrUndefined2);
    if (value == null) {
      const counter11 = counter9(key);
      if (!pipe2(this.map, has10(key))) {
        pipe2(this.map, set9(key, counter11));
      }
      value = counter11;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe2(this.map, get20(key), getOrUndefined2);
    if (value == null) {
      const frequency9 = frequency7(key);
      if (!pipe2(this.map, has10(key))) {
        pipe2(this.map, set9(key, frequency9));
      }
      value = frequency9;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe2(this.map, get20(key), getOrUndefined2);
    if (value == null) {
      const gauge9 = gauge7(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe2(this.map, has10(key))) {
        pipe2(this.map, set9(key, gauge9));
      }
      value = gauge9;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe2(this.map, get20(key), getOrUndefined2);
    if (value == null) {
      const histogram11 = histogram9(key);
      if (!pipe2(this.map, has10(key))) {
        pipe2(this.map, set9(key, histogram11));
      }
      value = histogram11;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe2(this.map, get20(key), getOrUndefined2);
    if (value == null) {
      const summary9 = summary7(key);
      if (!pipe2(this.map, has10(key))) {
        pipe2(this.map, set9(key, summary9));
      }
      value = summary9;
    }
    return value;
  }
};
var make68 = /* @__PURE__ */ __name(() => {
  return new MetricRegistryImpl2();
}, "make");

// node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey2 = "effect/Metric";
var MetricTypeId2 = /* @__PURE__ */ Symbol.for(MetricSymbolKey2);
var metricVariance2 = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var globalMetricRegistry2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make68());
var make69 = /* @__PURE__ */ __name(function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect) => tap3(effect, (a) => update8(metric, a)), {
    [MetricTypeId2]: metricVariance2,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments2(this, arguments);
    }
  });
  return metric;
}, "make");
var counter10 = /* @__PURE__ */ __name((name, options) => fromMetricKey2(counter7(name, options)), "counter");
var fromMetricKey2 = /* @__PURE__ */ __name((key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = /* @__PURE__ */ __name((extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry2.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry2.get(taggedWithLabels3(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  }, "hook");
  return make69(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
}, "fromMetricKey");
var histogram10 = /* @__PURE__ */ __name((name, boundaries, description) => fromMetricKey2(histogram7(name, boundaries, description)), "histogram");
var tagged4 = /* @__PURE__ */ dual2(3, (self, key, value) => taggedWithLabels4(self, [make66(key, value)]));
var taggedWithLabels4 = /* @__PURE__ */ dual2(2, (self, extraTags) => {
  return make69(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union8(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union8(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union8(extraTags, extraTags1)));
});
var update8 = /* @__PURE__ */ dual2(2, (self, input) => fiberRefGetWith2(currentMetricLabels2, (tags) => sync5(() => self.unsafeUpdate(input, tags))));

// node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey2 = "effect/Request";
var RequestTypeId2 = /* @__PURE__ */ Symbol.for(RequestSymbolKey2);
var requestVariance2 = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var RequestPrototype2 = {
  ...StructuralPrototype2,
  [RequestTypeId2]: requestVariance2
};
var isRequest3 = /* @__PURE__ */ __name((u) => hasProperty2(u, RequestTypeId2), "isRequest");
var complete3 = /* @__PURE__ */ dual2(2, (self, result) => fiberRefGetWith2(currentRequestMap2, (map23) => sync5(() => {
  if (map23.has(self)) {
    const entry = map23.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone2(entry.result, result);
    }
  }
})));
var Listeners2 = class {
  static {
    __name(this, "Listeners");
  }
  count = 0;
  observers = /* @__PURE__ */ new Set();
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
};

// node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction2 = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator2 = class _RedBlackTreeIterator {
  static {
    __name(this, "RedBlackTreeIterator");
  }
  self;
  stack;
  direction;
  count = 0;
  constructor(self, stack, direction) {
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction2.Forward ? Direction2.Backward : Direction2.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction2.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some6(this.stack[this.stack.length - 1].key);
    }
    return none11();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some6(this.stack[this.stack.length - 1].value);
    }
    return none11();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map12(last3(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color2 = {
  Red: 0,
  Black: 1 << 0
};
var clone2 = /* @__PURE__ */ __name(({
  color,
  count,
  key,
  left: left5,
  right: right5,
  value
}) => ({
  color,
  key,
  value,
  left: left5,
  right: right5,
  count
}), "clone");
function swap4(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
__name(swap4, "swap");
var repaint2 = /* @__PURE__ */ __name(({
  count,
  key,
  left: left5,
  right: right5,
  value
}, color) => ({
  color,
  key,
  value,
  left: left5,
  right: right5,
  count
}), "repaint");
var recount2 = /* @__PURE__ */ __name((node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
}, "recount");

// node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey2 = "effect/RedBlackTree";
var RedBlackTreeTypeId2 = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey2);
var redBlackTreeVariance2 = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var RedBlackTreeProto2 = {
  [RedBlackTreeTypeId2]: redBlackTreeVariance2,
  [symbol3]() {
    let hash3 = hash2(RedBlackTreeSymbolKey2);
    for (const item of this) {
      hash3 ^= pipe2(hash2(item[0]), combine9(hash2(item[1])));
    }
    return cached4(this, hash3);
  },
  [symbol4](that) {
    if (isRedBlackTree2(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries3 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries3[i];
        return equals3(itemSelf[0], itemThat[0]) && equals3(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator2(this, stack, Direction2.Forward);
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var makeImpl6 = /* @__PURE__ */ __name((ord, root) => {
  const tree = Object.create(RedBlackTreeProto2);
  tree._ord = ord;
  tree._root = root;
  return tree;
}, "makeImpl");
var isRedBlackTree2 = /* @__PURE__ */ __name((u) => hasProperty2(u, RedBlackTreeTypeId2), "isRedBlackTree");
var findFirst9 = /* @__PURE__ */ dual2(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals3(key, node.key)) {
      return some6(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none11();
});
var has11 = /* @__PURE__ */ dual2(2, (self, key) => isSome4(findFirst9(self, key)));
var insert3 = /* @__PURE__ */ dual2(3, (self, key, value) => {
  const cmp = self._ord;
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color2.Red,
    key,
    value,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color2.Black || n3.color === Color2.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color2.Red) {
          p.color = Color2.Black;
          pp.right = repaint2(y, Color2.Black);
          pp.color = Color2.Red;
          s -= 1;
        } else {
          pp.color = Color2.Red;
          pp.left = p.right;
          p.color = Color2.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount2(pp);
          recount2(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color2.Red) {
          p.color = Color2.Black;
          pp.right = repaint2(y, Color2.Black);
          pp.color = Color2.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color2.Red;
          pp.left = n3.right;
          n3.color = Color2.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount2(pp);
          recount2(p);
          recount2(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color2.Red) {
          p.color = Color2.Black;
          pp.left = repaint2(y, Color2.Black);
          pp.color = Color2.Red;
          s -= 1;
        } else {
          pp.color = Color2.Red;
          pp.right = p.left;
          p.color = Color2.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount2(pp);
          recount2(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color2.Red) {
          p.color = Color2.Black;
          pp.left = repaint2(y, Color2.Black);
          pp.color = Color2.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color2.Red;
          pp.right = n3.left;
          n3.color = Color2.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount2(pp);
          recount2(p);
          recount2(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color2.Black;
  return makeImpl6(self._ord, n_stack[0]);
});
var keysForward2 = /* @__PURE__ */ __name((self) => keys7(self, Direction2.Forward), "keysForward");
var keys7 = /* @__PURE__ */ __name((self, direction) => {
  const begin = self[Symbol.iterator]();
  let count = 0;
  return {
    [Symbol.iterator]: () => keys7(self, direction),
    next: /* @__PURE__ */ __name(() => {
      count++;
      const entry = begin.key;
      if (direction === Direction2.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }, "next")
  };
}, "keys");
var removeFirst3 = /* @__PURE__ */ dual2(2, (self, key) => {
  if (!has11(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals3(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split - 1].key = n.key;
    cstack[split - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split - 1].left = cstack[split];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color2.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl6(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap4(n, n.left);
      } else if (n.right !== void 0) {
        swap4(n, n.right);
      }
      n.color = Color2.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl6(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl6(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack2(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl6(ord, cstack[0]);
});
var fixDoubleBlack2 = /* @__PURE__ */ __name((stack) => {
  let n, p, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color2.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color2.Red) {
        s = p.right = clone2(s);
        z = s.right = clone2(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s.color = p.color;
        n.color = Color2.Black;
        p.color = Color2.Black;
        z.color = Color2.Black;
        recount2(p);
        recount2(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color2.Red) {
        s = p.right = clone2(s);
        z = s.left = clone2(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z.color = p.color;
        p.color = Color2.Black;
        s.color = Color2.Black;
        n.color = Color2.Black;
        recount2(p);
        recount2(s);
        recount2(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color2.Black) {
        if (p.color === Color2.Red) {
          p.color = Color2.Black;
          p.right = repaint2(s, Color2.Red);
          return;
        } else {
          p.right = repaint2(s, Color2.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone2(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color2.Red;
        recount2(p);
        recount2(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color2.Red) {
        s = p.left = clone2(s);
        z = s.left = clone2(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s.color = p.color;
        n.color = Color2.Black;
        p.color = Color2.Black;
        z.color = Color2.Black;
        recount2(p);
        recount2(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color2.Red) {
        s = p.left = clone2(s);
        z = s.right = clone2(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z.color = p.color;
        p.color = Color2.Black;
        s.color = Color2.Black;
        n.color = Color2.Black;
        recount2(p);
        recount2(s);
        recount2(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color2.Black) {
        if (p.color === Color2.Red) {
          p.color = Color2.Black;
          p.left = repaint2(s, Color2.Red);
          return;
        } else {
          p.left = repaint2(s, Color2.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone2(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color2.Red;
        recount2(p);
        recount2(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
}, "fixDoubleBlack");

// node_modules/effect/dist/esm/RedBlackTree.js
var has12 = has11;
var insert4 = insert3;
var keys8 = keysForward2;
var removeFirst4 = removeFirst3;

// node_modules/effect/dist/esm/SortedSet.js
var TypeId29 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto2 = {
  [TypeId29]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  [symbol3]() {
    return pipe2(hash2(this.keyTree), combine9(hash2(TypeId29)), cached4(this));
  },
  [symbol4](that) {
    return isSortedSet2(that) && equals3(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys8(this.keyTree);
  },
  toString() {
    return format4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON2)
    };
  },
  [NodeInspectSymbol2]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var fromTree2 = /* @__PURE__ */ __name((keyTree) => {
  const a = Object.create(SortedSetProto2);
  a.keyTree = keyTree;
  return a;
}, "fromTree");
var isSortedSet2 = /* @__PURE__ */ __name((u) => hasProperty2(u, TypeId29), "isSortedSet");
var add10 = /* @__PURE__ */ dual2(2, (self, value) => has12(self.keyTree, value) ? self : fromTree2(insert4(self.keyTree, value, true)));
var remove14 = /* @__PURE__ */ dual2(2, (self, value) => fromTree2(removeFirst4(self.keyTree, value)));

// node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey2 = "effect/Supervisor";
var SupervisorTypeId2 = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey2);
var supervisorVariance2 = {
  /* c8 ignore next */
  _T: /* @__PURE__ */ __name((_) => _, "_T")
};
var ProxySupervisor2 = class _ProxySupervisor {
  static {
    __name(this, "ProxySupervisor");
  }
  underlying;
  value0;
  [SupervisorTypeId2] = supervisorVariance2;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context7, effect, parent, fiber) {
    this.underlying.onStart(context7, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new _ProxySupervisor(this, pipe2(this.value, map19(f)));
  }
  zip(right5) {
    return new Zip2(this, right5);
  }
};
var Zip2 = class _Zip {
  static {
    __name(this, "Zip");
  }
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId2] = supervisorVariance2;
  constructor(left5, right5) {
    this.left = left5;
    this.right = right5;
  }
  get value() {
    return zip6(this.left.value, this.right.value);
  }
  onStart(context7, effect, parent, fiber) {
    this.left.onStart(context7, effect, parent, fiber);
    this.right.onStart(context7, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor2(this, pipe2(this.value, map19(f)));
  }
  zip(right5) {
    return new _Zip(this, right5);
  }
};
var isZip2 = /* @__PURE__ */ __name((self) => hasProperty2(self, SupervisorTypeId2) && isTagged2(self, "Zip"), "isZip");
var Track2 = class {
  static {
    __name(this, "Track");
  }
  [SupervisorTypeId2] = supervisorVariance2;
  fibers = /* @__PURE__ */ new Set();
  get value() {
    return sync5(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor2(this, pipe2(this.value, map19(f)));
  }
  zip(right5) {
    return new Zip2(this, right5);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var Const2 = class {
  static {
    __name(this, "Const");
  }
  effect;
  [SupervisorTypeId2] = supervisorVariance2;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor2(this, pipe2(this.value, map19(f)));
  }
  zip(right5) {
    return new Zip2(this, right5);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var FibersIn2 = class {
  static {
    __name(this, "FibersIn");
  }
  ref;
  [SupervisorTypeId2] = supervisorVariance2;
  constructor(ref) {
    this.ref = ref;
  }
  get value() {
    return sync5(() => get18(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe2(this.ref, set7(pipe2(get18(this.ref), add10(fiber))));
  }
  onEnd(_value, fiber) {
    pipe2(this.ref, set7(pipe2(get18(this.ref), remove14(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor2(this, pipe2(this.value, map19(f)));
  }
  zip(right5) {
    return new Zip2(this, right5);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var unsafeTrack2 = /* @__PURE__ */ __name(() => {
  return new Track2();
}, "unsafeTrack");
var track2 = /* @__PURE__ */ sync5(unsafeTrack2);
var fromEffect3 = /* @__PURE__ */ __name((effect) => {
  return new Const2(effect);
}, "fromEffect");
var none17 = /* @__PURE__ */ globalValue2("effect/Supervisor/none", () => fromEffect3(void_3));

// node_modules/effect/dist/esm/Differ.js
var make71 = make52;

// node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY6 = "Empty";
var OP_ADD_SUPERVISOR2 = "AddSupervisor";
var OP_REMOVE_SUPERVISOR2 = "RemoveSupervisor";
var OP_AND_THEN4 = "AndThen";
var empty53 = {
  _tag: OP_EMPTY6
};
var combine16 = /* @__PURE__ */ __name((self, that) => {
  return {
    _tag: OP_AND_THEN4,
    first: self,
    second: that
  };
}, "combine");
var patch16 = /* @__PURE__ */ __name((self, supervisor) => {
  return patchLoop2(supervisor, of6(self));
}, "patch");
var patchLoop2 = /* @__PURE__ */ __name((_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty5(patches)) {
    const head9 = headNonEmpty4(patches);
    switch (head9._tag) {
      case OP_EMPTY6: {
        patches = tailNonEmpty4(patches);
        break;
      }
      case OP_ADD_SUPERVISOR2: {
        supervisor = supervisor.zip(head9.supervisor);
        patches = tailNonEmpty4(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR2: {
        supervisor = removeSupervisor2(supervisor, head9.supervisor);
        patches = tailNonEmpty4(patches);
        break;
      }
      case OP_AND_THEN4: {
        patches = prepend5(head9.first)(prepend5(head9.second)(tailNonEmpty4(patches)));
        break;
      }
    }
  }
  return supervisor;
}, "patchLoop");
var removeSupervisor2 = /* @__PURE__ */ __name((self, that) => {
  if (equals3(self, that)) {
    return none17;
  } else {
    if (isZip2(self)) {
      return removeSupervisor2(self.left, that).zip(removeSupervisor2(self.right, that));
    } else {
      return self;
    }
  }
}, "removeSupervisor");
var toSet4 = /* @__PURE__ */ __name((self) => {
  if (equals3(self, none17)) {
    return empty35();
  } else {
    if (isZip2(self)) {
      return pipe2(toSet4(self.left), union10(toSet4(self.right)));
    } else {
      return make48(self);
    }
  }
}, "toSet");
var diff14 = /* @__PURE__ */ __name((oldValue, newValue) => {
  if (equals3(oldValue, newValue)) {
    return empty53;
  }
  const oldSupervisors = toSet4(oldValue);
  const newSupervisors = toSet4(newValue);
  const added = pipe2(newSupervisors, difference6(oldSupervisors), reduce14(empty53, (patch17, supervisor) => combine16(patch17, {
    _tag: OP_ADD_SUPERVISOR2,
    supervisor
  })));
  const removed = pipe2(oldSupervisors, difference6(newSupervisors), reduce14(empty53, (patch17, supervisor) => combine16(patch17, {
    _tag: OP_REMOVE_SUPERVISOR2,
    supervisor
  })));
  return combine16(added, removed);
}, "diff");
var differ4 = /* @__PURE__ */ make71({
  empty: empty53,
  patch: patch16,
  combine: combine16,
  diff: diff14
});

// node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted2 = /* @__PURE__ */ counter10("effect_fiber_started", {
  incremental: true
});
var fiberActive2 = /* @__PURE__ */ counter10("effect_fiber_active");
var fiberSuccesses2 = /* @__PURE__ */ counter10("effect_fiber_successes", {
  incremental: true
});
var fiberFailures2 = /* @__PURE__ */ counter10("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes2 = /* @__PURE__ */ tagged4(/* @__PURE__ */ histogram10("effect_fiber_lifetimes", /* @__PURE__ */ exponential2({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue2 = "Continue";
var EvaluationSignalDone2 = "Done";
var EvaluationSignalYieldNow2 = "Yield";
var runtimeFiberVariance2 = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var absurd2 = /* @__PURE__ */ __name((_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown2(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
}, "absurd");
var YieldedOp2 = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel2 = /* @__PURE__ */ globalValue2("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess2 = {
  [OP_ON_SUCCESS2]: (_, cont, value) => {
    return internalCall2(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: /* @__PURE__ */ __name((_, _cont, value) => {
    return exitSucceed3(exitSucceed3(value));
  }, "OnStep"),
  [OP_ON_SUCCESS_AND_FAILURE2]: (_, cont, value) => {
    return internalCall2(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS2]: (self, cont, value) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible5(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause3(self.getInterruptedCause());
    } else {
      return exitSucceed3(value);
    }
  },
  [OP_WHILE2]: (self, cont, value) => {
    internalCall2(() => cont.effect_instruction_i2(value));
    if (internalCall2(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall2(() => cont.effect_instruction_i1());
    } else {
      return void_3;
    }
  },
  [OP_ITERATOR2]: (self, cont, value) => {
    while (true) {
      const state = internalCall2(() => cont.effect_instruction_i0.next(value));
      if (state.done) {
        return exitSucceed3(state.value);
      }
      const primitive = yieldWrapGet2(state.value);
      if (!exitIsExit2(primitive)) {
        self.pushStack(cont);
        return primitive;
      } else if (primitive._tag === "Failure") {
        return primitive;
      }
      value = primitive.value;
    }
  }
};
var drainQueueWhileRunningTable2 = {
  [OP_INTERRUPT_SIGNAL2]: (self, runtimeFlags3, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible5(runtimeFlags3) ? exitFailCause3(message.cause) : cur;
  },
  [OP_RESUME2]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL2]: (self, runtimeFlags3, cur, message) => {
    message.onFiber(self, running4(runtimeFlags3));
    return cur;
  },
  [OP_YIELD_NOW2]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap16(yieldNow5(), () => cur);
  }
};
var runBlockedRequests2 = /* @__PURE__ */ __name((self) => forEachSequentialDiscard2(flatten8(self), (requestsByRequestResolver) => forEachConcurrentDiscard2(sequentialCollectionToChunk2(requestsByRequestResolver), ([dataSource, sequential7]) => {
  const map23 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential7) {
    arr.push(toReadonlyArray2(block));
    for (const entry of block) {
      map23.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally2(invokeWithInterrupt2(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap2, map23);
}, false, false)), "runBlockedRequests");
var _version2 = /* @__PURE__ */ getCurrentVersion2();
var FiberRuntime2 = class extends Class6 {
  static {
    __name(this, "FiberRuntime");
  }
  [FiberTypeId2] = fiberVariance4;
  [RuntimeFiberTypeId2] = runtimeFiberVariance2;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array();
  _children = null;
  _observers = /* @__PURE__ */ new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId5, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId5;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics2(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels2);
      fiberStarted2.unsafeUpdate(1, tags);
      fiberActive2.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join4(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect) {
    this.tell(resume2(effect));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status) => status);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (isDone6(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake13(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause2);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend5(() => {
      const deferred = deferredUnsafeMake2(this._fiberId);
      this.tell(stateful2((fiber, status) => {
        deferredUnsafeDone2(deferred, sync5(() => f(fiber, status)));
      }));
      return deferredAwait2(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_2((resume3) => {
      const cb = /* @__PURE__ */ __name((exit7) => resume3(succeed7(exit7)), "cb");
      this.tell(stateful2((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync5(() => this.tell(stateful2((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime3((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs3(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags2);
      const patch17 = pipe2(
        diff11(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude4(Interruption2),
        exclude4(WindDown2)
      );
      return updateRuntimeFlags2(patch17);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync5(() => fromNullable4(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId5) {
    return sync5(() => this.tell(interruptSignal2(interrupt5(fiberId5))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId5) {
    this.tell(interruptSignal2(interrupt5(fiberId5)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags2, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_3(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs3(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices2);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag2.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor2);
    this.currentScheduler = this.getFiberRef(currentScheduler2);
    this.currentContext = this.getFiberRef(currentContext2);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag2.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs5) {
    this._fiberRefs = fiberRefs5;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope5) {
    const children = this._children;
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        if (child._exitValue === null) {
          scope5.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue2;
      const prev = globalThis[currentFiberURI2];
      globalThis[currentFiberURI2] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue2) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone2 : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI2] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow2) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority2));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags3, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable2[message._tag](this, runtimeFlags3, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty13(this.getFiberRef(currentInterruptedCause2));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause5) {
    const oldSC = this.getFiberRef(currentInterruptedCause2);
    this.setFiberRef(currentInterruptedCause2, sequential4(oldSC, cause5));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause5) {
    this.addInterruptedCause(cause5);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal2(interrupt5(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone9 = false;
      const body = /* @__PURE__ */ __name(() => {
        const next = it.next();
        if (!next.done) {
          return asVoid4(next.value.await);
        } else {
          return sync5(() => {
            isDone9 = true;
          });
        }
      }, "body");
      return whileLoop4({
        while: /* @__PURE__ */ __name(() => !isDone9, "while"),
        body,
        step: /* @__PURE__ */ __name(() => {
        }, "step")
      });
    }
    return null;
  }
  reportExitValue(exit7) {
    if (runtimeMetrics2(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels2);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes2.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive2.unsafeUpdate(-1, tags);
      switch (exit7._tag) {
        case OP_SUCCESS2: {
          fiberSuccesses2.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE2: {
          fiberFailures2.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit7._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel2);
      if (!isInterruptedOnly2(exit7.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit7.cause, level);
      }
    }
  }
  setExitValue(exit7) {
    this._exitValue = exit7;
    this.reportExitValue(exit7);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit7);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers2);
  }
  log(message, cause5, overrideLogLevel) {
    const logLevel = isSome4(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel2);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel2);
    if (greaterThan4(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan2);
    const annotations = this.getFiberRef(currentLogAnnotations2);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size11(loggers) > 0) {
      const clockService = get15(this.getFiberRef(currentServices2), clockTag2);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext2(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause: cause5,
            context: contextMap,
            spans,
            annotations,
            date
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW2: {
        return EvaluationSignalYieldNow2;
      }
      case OP_INTERRUPT_SIGNAL2: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause3(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue2;
      }
      case OP_RESUME2: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue2;
      }
      case OP_STATEFUL2: {
        message.onFiber(this, this._exitValue !== null ? done10 : suspended4(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue2;
      }
      default: {
        return absurd2(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = interruptible5(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause3(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit7 = this.runLoop(eff);
        if (exit7 === YieldedOp2) {
          const op = yieldedOpChannel2.currentOp;
          yieldedOpChannel2.currentOp = null;
          if (op._op === OP_YIELD2) {
            if (cooperativeYielding2(this.currentRuntimeFlags)) {
              this.tell(yieldNow7());
              this.tell(resume2(exitVoid3));
              effect = null;
            } else {
              effect = exitVoid3;
            }
          } else if (op._op === OP_ASYNC2) {
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = pipe2(this.currentRuntimeFlags, enable5(WindDown2));
          const interruption3 = this.interruptAllChildren();
          if (interruption3 !== null) {
            effect = flatMap16(interruption3, () => exit7);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit7);
            } else {
              this.tell(resume2(exit7));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI2];
      globalThis[currentFiberURI2] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI2] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume2(effect));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect) {
    this.tell(resume2(effect));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch17) {
    const newRuntimeFlags = patch12(oldRuntimeFlags, patch17);
    globalThis[currentFiberURI2] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags3, asyncRegister) {
    let alreadyCalled = false;
    const callback = /* @__PURE__ */ __name((effect) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume2(effect));
      }
    }, "callback");
    if (interruptible5(runtimeFlags3)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause5(die4(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE2) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS2 && frame._op !== OP_WHILE2 && frame._op !== OP_ITERATOR2) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG2](op) {
    return sync5(() => unsafeGet8(this.currentContext, op));
  }
  ["Left"](op) {
    return fail6(op.left);
  }
  ["None"](_) {
    return fail6(new NoSuchElementException2());
  }
  ["Right"](op) {
    return exitSucceed3(op.right);
  }
  ["Some"](op) {
    return exitSucceed3(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync2((microResume) => {
      let resume3 = microResume;
      const fiber = runFork3(provideContext4(op, this.currentContext));
      fiber.addObserver((exit7) => {
        if (exit7._tag === "Success") {
          return resume3(exitSucceed3(exit7.value));
        }
        switch (exit7.cause._tag) {
          case "Interrupt": {
            return resume3(exitFailCause3(interrupt5(none13)));
          }
          case "Fail": {
            return resume3(fail6(exit7.cause.error));
          }
          case "Die": {
            return resume3(die5(exit7.cause.defect));
          }
        }
      });
      return unsafeAsync2((abortResume) => {
        resume3 = /* @__PURE__ */ __name((_) => {
          abortResume(void_3);
        }, "resume");
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC2](op) {
    const value = internalCall2(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess2)) {
        absurd2(cont);
      }
      return contOpSuccess2[cont._op](this, cont, value);
    } else {
      yieldedOpChannel2.currentOp = exitSucceed3(value);
      return YieldedOp2;
    }
  }
  [OP_SUCCESS2](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess2)) {
        absurd2(cont);
      }
      return contOpSuccess2[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel2.currentOp = oldCur;
      return YieldedOp2;
    }
  }
  [OP_FAILURE2](op) {
    const cause5 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE2:
        case OP_ON_SUCCESS_AND_FAILURE2: {
          if (!(interruptible5(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall2(() => cont.effect_instruction_i1(cause5));
          } else {
            return exitFailCause3(stripFailures2(cause5));
          }
        }
        case "OnStep": {
          if (!(interruptible5(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed3(exitFailCause3(cause5));
          } else {
            return exitFailCause3(stripFailures2(cause5));
          }
        }
        case OP_REVERT_FLAGS2: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible5(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause3(sequential4(cause5, this.getInterruptedCause()));
          } else {
            return exitFailCause3(cause5);
          }
        }
        default: {
          absurd2(cont);
        }
      }
    } else {
      yieldedOpChannel2.currentOp = exitFailCause3(cause5);
      return YieldedOp2;
    }
  }
  [OP_WITH_RUNTIME2](op) {
    return internalCall2(() => op.effect_instruction_i0(this, running4(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff13(snap.refs, refs);
      const patchFlags = diff11(snap.flags, flags);
      return exitSucceed3(blocked3(op.effect_instruction_i0, withFiberRuntime3((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch15(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch12(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask4((restore) => flatMap16(forkDaemon3(runRequestBlock3(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests2(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS2](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch12(oldRuntimeFlags, updateFlags);
    if (interruptible5(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause3(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff11(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags2(revertFlags, op));
        return internalCall2(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid3;
      }
    }
  }
  [OP_ON_SUCCESS2](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE2](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE2](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC2](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel2.currentOp = op;
    return YieldedOp2;
  }
  [OP_YIELD2](op) {
    this._isYielding = false;
    yieldedOpChannel2.currentOp = op;
    return YieldedOp2;
  }
  [OP_WHILE2](op) {
    const check3 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check3()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid3;
    }
  }
  [OP_ITERATOR2](op) {
    return contOpSuccess2[OP_ITERATOR2](this, op, void 0);
  }
  [OP_COMMIT2](op) {
    return internalCall2(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision2) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap16(yieldNow5({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version2 !== cur[EffectTypeId5]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel2);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId5]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion2()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty44, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp2) {
          const op = yieldedOpChannel2.currentOp;
          if (op._op === OP_YIELD2 || op._op === OP_ASYNC2) {
            return YieldedOp2;
          }
          yieldedOpChannel2.currentOp = null;
          return op._op === OP_SUCCESS2 || op._op === OP_FAILURE2 ? op : exitFailCause3(die4(op));
        }
      } catch (e) {
        if (cur !== YieldedOp2 && !hasProperty2(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage3(`Not a valid effect: ${toStringUnknown2(cur)}`);
        } else if (isInterruptedException2(e)) {
          cur = exitFailCause3(sequential4(die4(e), interrupt5(none13)));
        } else {
          cur = die5(e);
        }
      }
    }
  }
  run = /* @__PURE__ */ __name(() => {
    this.drainQueueOnCurrentThread();
  }, "run");
};
var currentMinimumLogLevel2 = /* @__PURE__ */ globalValue2("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake2(fromLiteral2("Info")));
var loggerWithConsoleLog2 = /* @__PURE__ */ __name((self) => makeLogger2((opts) => {
  const services = getOrDefault4(opts.context, currentServices2);
  get15(services, consoleTag2).unsafe.log(self.log(opts));
}), "loggerWithConsoleLog");
var defaultLogger2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog2(stringLogger2));
var tracerLogger2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger2(({
  annotations,
  cause: cause5,
  context: context7,
  fiberId: fiberId5,
  logLevel,
  message
}) => {
  const span3 = getOption4(getOrDefault3(context7, currentContext2), spanTag2);
  if (span3._tag === "None" || span3.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet8(getOrDefault3(context7, currentServices2), clockTag2);
  const attributes = {};
  for (const [key, value] of annotations) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName4(fiberId5);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause5 !== null && cause5._tag !== "Empty") {
    attributes["effect.cause"] = pretty2(cause5, {
      renderErrorCause: true
    });
  }
  span3.value.event(toStringUnknown2(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet2(make48(defaultLogger2, tracerLogger2)));
var annotateLogsScoped3 = /* @__PURE__ */ __name(function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith2(currentLogAnnotations2, set8(arguments[0], arguments[1]));
  }
  const entries3 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith2(currentLogAnnotations2, mutate6((annotations) => {
    for (let i = 0; i < entries3.length; i++) {
      const [key, value] = entries3[i];
      set8(annotations, key, value);
    }
    return annotations;
  }));
}, "annotateLogsScoped");
var whenLogLevel3 = /* @__PURE__ */ dual2(2, (effect, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral2(level) : level;
  return withFiberRuntime3((fiberState) => {
    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel2);
    if (greaterThan4(minimumLogLevel, requiredLogLevel)) {
      return succeed7(none11());
    }
    return map19(effect, some6);
  });
});
var acquireRelease3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), (acquire, release) => uninterruptible3(tap3(acquire, (a) => addFinalizer3((exit7) => release(a, exit7)))));
var acquireReleaseInterruptible3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), (acquire, release) => ensuring3(acquire, addFinalizer3((exit7) => release(exit7))));
var addFinalizer3 = /* @__PURE__ */ __name((finalizer) => withFiberRuntime3((runtime7) => {
  const acquireRefs = runtime7.getFiberRefs();
  const acquireFlags = disable5(runtime7.currentRuntimeFlags, Interruption2);
  return flatMap16(scope3, (scope5) => scopeAddFinalizerExit2(scope5, (exit7) => withFiberRuntime3((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff13(preRefs, acquireRefs);
    const patchFlags = diff11(preFlags, acquireFlags);
    const inverseRefs = diff13(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch15(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring3(withRuntimeFlags2(finalizer(exit7), patchFlags), sync5(() => {
      runtimeFinalizer.setFiberRefs(patch15(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
}), "addFinalizer");
var daemonChildren3 = /* @__PURE__ */ __name((self) => {
  const forkScope = fiberRefLocally2(currentForkScopeOverride2, some6(globalScope2));
  return forkScope(self);
}, "daemonChildren");
var _existsParFound2 = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists3 = /* @__PURE__ */ dual2((args3) => isIterable2(args3[0]) && !isEffect3(args3[0]), (elements, predicate, options) => matchSimple2(options?.concurrency, () => suspend5(() => existsLoop2(elements[Symbol.iterator](), 0, predicate)), () => matchEffect3(forEach15(elements, (a, i) => if_3(predicate(a, i), {
  onTrue: /* @__PURE__ */ __name(() => fail6(_existsParFound2), "onTrue"),
  onFalse: /* @__PURE__ */ __name(() => void_3, "onFalse")
}), options), {
  onFailure: /* @__PURE__ */ __name((e) => e === _existsParFound2 ? succeed7(true) : fail6(e), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => succeed7(false), "onSuccess")
})));
var existsLoop2 = /* @__PURE__ */ __name((iterator, index, f) => {
  const next = iterator.next();
  if (next.done) {
    return succeed7(false);
  }
  return flatMap16(f(next.value, index), (b) => b ? succeed7(b) : existsLoop2(iterator, index + 1, f));
}, "existsLoop");
var filter9 = /* @__PURE__ */ dual2((args3) => isIterable2(args3[0]) && !isEffect3(args3[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map19(predicate(a, i), not2) : predicate;
  return matchSimple2(options?.concurrency, () => suspend5(() => fromIterable11(elements).reduceRight((effect, a, i) => zipWith5(effect, suspend5(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync5(() => new Array()))), () => map19(forEach15(elements, (a, i) => map19(predicate_(a, i), (b) => b ? some6(a) : none11()), options), getSomes2));
});
var allResolveInput2 = /* @__PURE__ */ __name((input) => {
  if (Array.isArray(input) || isIterable2(input)) {
    return [input, none11()];
  }
  const keys9 = Object.keys(input);
  const size17 = keys9.length;
  return [keys9.map((k) => input[k]), some6((values5) => {
    const res = {};
    for (let i = 0; i < size17; i++) {
      ;
      res[keys9[i]] = values5[i];
    }
    return res;
  })];
}, "allResolveInput");
var allValidate2 = /* @__PURE__ */ __name((effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either5(effect));
  }
  return flatMap16(forEach15(eitherEffects, identity2, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none19 = none11();
    const size17 = eithers.length;
    const errors = new Array(size17);
    const successes = new Array(size17);
    let errored = false;
    for (let i = 0; i < size17; i++) {
      const either7 = eithers[i];
      if (either7._tag === "Left") {
        errors[i] = some6(either7.left);
        errored = true;
      } else {
        successes[i] = either7.right;
        errors[i] = none19;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail6(reconcile.value(errors)) : fail6(errors);
    } else if (options?.discard) {
      return void_3;
    }
    return reconcile._tag === "Some" ? succeed7(reconcile.value(successes)) : succeed7(successes);
  });
}, "allValidate");
var allEither2 = /* @__PURE__ */ __name((effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either5(effect));
  }
  if (options?.discard) {
    return forEach15(eitherEffects, identity2, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map19(forEach15(eitherEffects, identity2, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
}, "allEither");
var all5 = /* @__PURE__ */ __name((arg, options) => {
  const [effects, reconcile] = allResolveInput2(arg);
  if (options?.mode === "validate") {
    return allValidate2(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither2(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map19(forEach15(effects, identity2, options), reconcile.value) : forEach15(effects, identity2, options);
}, "all");
var allWith3 = /* @__PURE__ */ __name((options) => (arg) => all5(arg, options), "allWith");
var allSuccesses3 = /* @__PURE__ */ __name((elements, options) => map19(all5(fromIterable11(elements).map(exit4), options), filterMap5((exit7) => exitIsSuccess2(exit7) ? some6(exit7.effect_instruction_i0) : none11())), "allSuccesses");
var replicate3 = /* @__PURE__ */ dual2(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), (self, n, options) => all5(replicate3(self, n), options));
var forEach15 = /* @__PURE__ */ dual2((args3) => isIterable2(args3[0]), (self, f, options) => withFiberRuntime3((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching2);
  if (options?.discard) {
    return match17(options.concurrency, () => finalizersMaskInternal2(sequential6, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard2(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard2(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal2(parallel6, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard2(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal2(parallelN4(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard2(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match17(options?.concurrency, () => finalizersMaskInternal2(sequential6, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN2(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential2(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal2(parallel6, options?.concurrentFinalizers)((restore) => forEachParUnbounded2(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal2(parallelN4(n), options?.concurrentFinalizers)((restore) => forEachParN2(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded2 = /* @__PURE__ */ __name((self, f, batching) => suspend5(() => {
  const as7 = fromIterable11(self);
  const array6 = new Array(as7.length);
  const fn3 = /* @__PURE__ */ __name((a, i) => flatMap16(f(a, i), (b) => sync5(() => array6[i] = b)), "fn");
  return zipRight3(forEachConcurrentDiscard2(as7, fn3, batching, false), succeed7(array6));
}), "forEachParUnbounded");
var forEachConcurrentDiscard2 = /* @__PURE__ */ __name((self, f, batching, processAll, n) => uninterruptibleMask4((restore) => transplant3((graft) => withFiberRuntime3((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_3;
  }
  let counter11 = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll = /* @__PURE__ */ __name(() => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  }), "interruptAll");
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = /* @__PURE__ */ __name(() => {
    const exits = results.filter(({
      exit: exit7
    }) => exit7._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit7
    }) => exit7);
    if (exits.length === 0) {
      exits.push(exitVoid3);
    }
    return exits;
  }, "collectExits");
  const runFiber = /* @__PURE__ */ __name((eff, interruptImmediately = false) => {
    const runnable = uninterruptible3(graft(eff));
    const fiber = unsafeForkUnstarted2(runnable, parent, parent.currentRuntimeFlags, globalScope2);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  }, "runFiber");
  const onInterruptSignal = /* @__PURE__ */ __name(() => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  }, "onInterruptSignal");
  const stepOrExit = batching ? step5 : exit4;
  const processingFiber = runFiber(async_2((resume3) => {
    const pushResult = /* @__PURE__ */ __name((res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    }, "pushResult");
    const next = /* @__PURE__ */ __name(() => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter11++;
        const returnNextElement = /* @__PURE__ */ __name(() => {
          const a2 = todos.pop();
          index = counter11++;
          return flatMap16(yieldNow5(), () => flatMap16(stepOrExit(restore(f(a2, index))), onRes));
        }, "returnNextElement");
        const onRes = /* @__PURE__ */ __name((res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed7(res);
        }, "onRes");
        const todo = flatMap16(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit7;
          if (wrapped._op === "Failure") {
            exit7 = wrapped;
          } else {
            exit7 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit7, index);
          if (results.length === target) {
            resume3(succeed7(getOrElse5(exitCollectAll2(collectExits(), {
              parallel: true
            }), () => exitVoid3)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked5) => blocked5.effect_instruction_i0).reduce(par2);
            resume3(succeed7(blocked3(requests, forEachConcurrentDiscard2([getOrElse5(exitCollectAll2(exits, {
              parallel: true
            }), () => exitVoid3), ...residual.map((blocked5) => blocked5.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    }, "next");
    for (let i = 0; i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid4(onExit4(flatten10(restore(join4(processingFiber))), exitMatch2({
    onFailure: /* @__PURE__ */ __name((cause5) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_2((cb) => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check3 = /* @__PURE__ */ __name((index2, hitNext) => (exit7) => {
          exits[index2] = exit7;
          count++;
          if (count === target2) {
            cb(exitSucceed3(exitFailCause3(cause5)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        }, "check");
        const next = /* @__PURE__ */ __name(() => {
          runFiber(toPop.pop(), true).addObserver(check3(index, true));
          index++;
        }, "next");
        processingFiber.addObserver(check3(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next();
        }
      });
    }, "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => forEachSequential2(joinOrder, (f2) => f2.inheritAll), "onSuccess")
  })));
}))), "forEachConcurrentDiscard");
var forEachParN2 = /* @__PURE__ */ __name((self, n, f, batching) => suspend5(() => {
  const as7 = fromIterable11(self);
  const array6 = new Array(as7.length);
  const fn3 = /* @__PURE__ */ __name((a, i) => map19(f(a, i), (b) => array6[i] = b), "fn");
  return zipRight3(forEachConcurrentDiscard2(as7, fn3, batching, false, n), succeed7(array6));
}), "forEachParN");
var fork4 = /* @__PURE__ */ __name((self) => withFiberRuntime3((state, status) => succeed7(unsafeFork5(self, state, status.runtimeFlags))), "fork");
var forkDaemon3 = /* @__PURE__ */ __name((self) => forkWithScopeOverride2(self, globalScope2), "forkDaemon");
var forkWithErrorHandler3 = /* @__PURE__ */ dual2(2, (self, handler) => fork4(onError3(self, (cause5) => {
  const either7 = failureOrCause2(cause5);
  switch (either7._tag) {
    case "Left":
      return handler(either7.left);
    case "Right":
      return failCause5(either7.right);
  }
})));
var unsafeFork5 = /* @__PURE__ */ __name((effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber2(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
}, "unsafeFork");
var unsafeForkUnstarted2 = /* @__PURE__ */ __name((effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber2(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
}, "unsafeForkUnstarted");
var unsafeMakeChildFiber2 = /* @__PURE__ */ __name((effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake9();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs2(parentFiberRefs, childId);
  const childFiber = new FiberRuntime2(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault3(childFiberRefs, currentContext2);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some6(parentFiber), childFiber);
  childFiber.addObserver((exit7) => supervisor.onEnd(exit7, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe2(parentFiber.getFiberRef(currentForkScopeOverride2), getOrElse5(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
}, "unsafeMakeChildFiber");
var forkWithScopeOverride2 = /* @__PURE__ */ __name((self, scopeOverride) => withFiberRuntime3((parentFiber, parentStatus) => succeed7(unsafeFork5(self, parentFiber, parentStatus.runtimeFlags, scopeOverride))), "forkWithScopeOverride");
var mergeAll8 = /* @__PURE__ */ dual2((args3) => isFunction4(args3[2]), (elements, zero3, f, options) => matchSimple2(options?.concurrency, () => fromIterable11(elements).reduce((acc, a, i) => zipWith5(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed7(zero3)), () => flatMap16(make65(zero3), (acc) => flatMap16(forEach15(elements, (effect, i) => flatMap16(effect, (a) => update7(acc, (b) => f(b, a, i))), options), () => get24(acc)))));
var partition7 = /* @__PURE__ */ dual2((args3) => isIterable2(args3[0]), (elements, f, options) => pipe2(forEach15(elements, (a, i) => either5(f(a, i)), options), map19((chunk3) => partitionMap4(chunk3, identity2))));
var validateAll3 = /* @__PURE__ */ dual2((args3) => isIterable2(args3[0]), (elements, f, options) => flatMap16(partition7(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray4(es) ? fail6(es) : options?.discard ? void_3 : succeed7(bs)));
var raceAll3 = /* @__PURE__ */ __name((all7) => withFiberRuntime3((state, status) => async_2((resume3) => {
  const fibers = /* @__PURE__ */ new Set();
  let winner;
  let failures3 = empty44;
  const interruptAll = /* @__PURE__ */ __name(() => {
    for (const fiber of fibers) {
      fiber.unsafeInterruptAsFork(state.id());
    }
  }, "interruptAll");
  let latch = false;
  let empty57 = true;
  for (const self of all7) {
    empty57 = false;
    const fiber = unsafeFork5(interruptible6(self), state, status.runtimeFlags);
    fibers.add(fiber);
    fiber.addObserver((exit7) => {
      fibers.delete(fiber);
      if (!winner) {
        if (exit7._tag === "Success") {
          latch = true;
          winner = fiber;
          failures3 = empty44;
          interruptAll();
        } else {
          failures3 = parallel4(exit7.cause, failures3);
        }
      }
      if (latch && fibers.size === 0) {
        resume3(winner ? zipRight3(inheritAll2(winner), winner.unsafePoll()) : failCause5(failures3));
      }
    });
    if (winner) break;
  }
  if (empty57) {
    return resume3(dieSync3(() => new IllegalArgumentException2(`Received an empty collection of effects`)));
  }
  latch = true;
  return interruptAllAs2(fibers, state.id());
})), "raceAll");
var reduceEffect3 = /* @__PURE__ */ dual2((args3) => isIterable2(args3[0]) && !isEffect3(args3[0]), (elements, zero3, f, options) => matchSimple2(options?.concurrency, () => fromIterable11(elements).reduce((acc, a, i) => zipWith5(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend5(() => pipe2(mergeAll8([zero3, ...elements], none11(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some6(elem);
    }
    case "Some": {
      return some6(f(acc.value, elem, i));
    }
  }
}, options), map19((option5) => {
  switch (option5._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option5.value;
    }
  }
})))));
var parallelFinalizers3 = /* @__PURE__ */ __name((self) => contextWithEffect3((context7) => match11(getOption4(context7, scopeTag2), {
  onNone: /* @__PURE__ */ __name(() => self, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    switch (scope5.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap16(scopeFork2(scope5, parallel6), (inner) => scopeExtend2(self, inner));
    }
  }, "onSome")
})), "parallelFinalizers");
var parallelNFinalizers2 = /* @__PURE__ */ __name((parallelism) => (self) => contextWithEffect3((context7) => match11(getOption4(context7, scopeTag2), {
  onNone: /* @__PURE__ */ __name(() => self, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap16(scopeFork2(scope5, parallelN4(parallelism)), (inner) => scopeExtend2(self, inner));
  }, "onSome")
})), "parallelNFinalizers");
var finalizersMask3 = /* @__PURE__ */ __name((strategy) => (self) => finalizersMaskInternal2(strategy, true)(self), "finalizersMask");
var finalizersMaskInternal2 = /* @__PURE__ */ __name((strategy, concurrentFinalizers) => (self) => contextWithEffect3((context7) => match11(getOption4(context7, scopeTag2), {
  onNone: /* @__PURE__ */ __name(() => self(identity2), "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    if (concurrentFinalizers === true) {
      const patch17 = strategy._tag === "Parallel" ? parallelFinalizers3 : strategy._tag === "Sequential" ? sequentialFinalizers3 : parallelNFinalizers2(strategy.parallelism);
      switch (scope5.strategy._tag) {
        case "Parallel":
          return patch17(self(parallelFinalizers3));
        case "Sequential":
          return patch17(self(sequentialFinalizers3));
        case "ParallelN":
          return patch17(self(parallelNFinalizers2(scope5.strategy.parallelism)));
      }
    } else {
      return self(identity2);
    }
  }, "onSome")
})), "finalizersMaskInternal");
var scopeWith3 = /* @__PURE__ */ __name((f) => flatMap16(scopeTag2, f), "scopeWith");
var scopedWith3 = /* @__PURE__ */ __name((f) => flatMap16(scopeMake2(), (scope5) => onExit4(f(scope5), (exit7) => scope5.close(exit7))), "scopedWith");
var scopedEffect2 = /* @__PURE__ */ __name((effect) => flatMap16(scopeMake2(), (scope5) => scopeUse2(effect, scope5)), "scopedEffect");
var sequentialFinalizers3 = /* @__PURE__ */ __name((self) => contextWithEffect3((context7) => match11(getOption4(context7, scopeTag2), {
  onNone: /* @__PURE__ */ __name(() => self, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    switch (scope5.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap16(scopeFork2(scope5, sequential6), (inner) => scopeExtend2(self, inner));
    }
  }, "onSome")
})), "sequentialFinalizers");
var tagMetricsScoped3 = /* @__PURE__ */ __name((key, value) => labelMetricsScoped3([make66(key, value)]), "tagMetricsScoped");
var labelMetricsScoped3 = /* @__PURE__ */ __name((labels) => fiberRefLocallyScopedWith2(currentMetricLabels2, (old) => union8(old, labels)), "labelMetricsScoped");
var using3 = /* @__PURE__ */ dual2(2, (self, use) => scopedWith3((scope5) => flatMap16(scopeExtend2(self, scope5), use)));
var validate3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[1]), (self, that, options) => validateWith3(self, that, (a, b) => [a, b], options));
var validateWith3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[1]), (self, that, f, options) => flatten10(zipWithOptions2(exit4(self), exit4(that), (ea, eb) => exitZipWith2(ea, eb, {
  onSuccess: f,
  onFailure: /* @__PURE__ */ __name((ca, cb) => options?.concurrent ? parallel4(ca, cb) : sequential4(ca, cb), "onFailure")
}), options)));
var validateFirst3 = /* @__PURE__ */ dual2((args3) => isIterable2(args3[0]), (elements, f, options) => flip3(forEach15(elements, (a, i) => flip3(f(a, i)), options)));
var withClockScoped3 = /* @__PURE__ */ __name((c) => fiberRefLocallyScopedWith2(currentServices2, add7(clockTag2, c)), "withClockScoped");
var withRandomScoped3 = /* @__PURE__ */ __name((value) => fiberRefLocallyScopedWith2(currentServices2, add7(randomTag2, value)), "withRandomScoped");
var withConfigProviderScoped3 = /* @__PURE__ */ __name((provider) => fiberRefLocallyScopedWith2(currentServices2, add7(configProviderTag2, provider)), "withConfigProviderScoped");
var withEarlyRelease3 = /* @__PURE__ */ __name((self) => scopeWith3((parent) => flatMap16(scopeFork2(parent, sequential5), (child) => pipe2(self, scopeExtend2(child), map19((value) => [fiberIdWith3((fiberId5) => scopeClose2(child, exitInterrupt3(fiberId5))), value])))), "withEarlyRelease");
var zipOptions2 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[1]), (self, that, options) => zipWithOptions2(self, that, (a, b) => [a, b], options));
var zipLeftOptions2 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipLeft3(self, that);
  }
  return zipWithOptions2(self, that, (a, _) => a, options);
});
var zipRightOptions2 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipRight3(self, that);
  }
  return zipWithOptions2(self, that, (_, b) => b, options);
});
var zipWithOptions2 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[1]), (self, that, f, options) => map19(all5([self, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped2 = /* @__PURE__ */ __name((update9) => {
  if (update9 === empty42) {
    return void_3;
  }
  return pipe2(runtimeFlags2, flatMap16((runtimeFlags3) => {
    const updatedRuntimeFlags = patch12(runtimeFlags3, update9);
    const revertRuntimeFlags = diff11(updatedRuntimeFlags, runtimeFlags3);
    return pipe2(updateRuntimeFlags2(update9), zipRight3(addFinalizer3(() => updateRuntimeFlags2(revertRuntimeFlags))), asVoid4);
  }), uninterruptible3);
}, "withRuntimeFlagsScoped");
var scopeTag2 = /* @__PURE__ */ GenericTag2("effect/Scope");
var scope3 = scopeTag2;
var scopeUnsafeAddFinalizer2 = /* @__PURE__ */ __name((scope5, fin) => {
  if (scope5.state._tag === "Open") {
    scope5.state.finalizers.set({}, fin);
  }
}, "scopeUnsafeAddFinalizer");
var ScopeImplProto2 = {
  [ScopeTypeId2]: ScopeTypeId2,
  [CloseableScopeTypeId2]: CloseableScopeTypeId2,
  pipe() {
    return pipeArguments2(this, arguments);
  },
  fork(strategy) {
    return sync5(() => {
      const newScope = scopeUnsafeMake2(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = /* @__PURE__ */ __name((exit7) => newScope.close(exit7), "fin");
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer2(newScope, (_) => sync5(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit7) {
    return suspend5(() => {
      if (this.state._tag === "Closed") {
        return void_3;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit7
      };
      if (finalizers.length === 0) {
        return void_3;
      }
      return isSequential2(this.strategy) ? pipe2(forEachSequential2(finalizers, (fin) => exit4(fin(exit7))), flatMap16((results) => pipe2(exitCollectAll2(results), map12(exitAsVoid2), getOrElse5(() => exitVoid3)))) : isParallel2(this.strategy) ? pipe2(forEachParUnbounded2(finalizers, (fin) => exit4(fin(exit7)), false), flatMap16((results) => pipe2(exitCollectAll2(results, {
        parallel: true
      }), map12(exitAsVoid2), getOrElse5(() => exitVoid3)))) : pipe2(forEachParN2(finalizers, this.strategy.parallelism, (fin) => exit4(fin(exit7)), false), flatMap16((results) => pipe2(exitCollectAll2(results, {
        parallel: true
      }), map12(exitAsVoid2), getOrElse5(() => exitVoid3))));
    });
  },
  addFinalizer(fin) {
    return suspend5(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_3;
    });
  }
};
var scopeUnsafeMake2 = /* @__PURE__ */ __name((strategy = sequential5) => {
  const scope5 = Object.create(ScopeImplProto2);
  scope5.strategy = strategy;
  scope5.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope5;
}, "scopeUnsafeMake");
var scopeMake2 = /* @__PURE__ */ __name((strategy = sequential5) => sync5(() => scopeUnsafeMake2(strategy)), "scopeMake");
var scopeExtend2 = /* @__PURE__ */ dual2(2, (effect, scope5) => mapInputContext3(
  effect,
  // @ts-expect-error
  merge9(make43(scopeTag2, scope5))
));
var scopeUse2 = /* @__PURE__ */ dual2(2, (effect, scope5) => pipe2(effect, scopeExtend2(scope5), onExit4((exit7) => scope5.close(exit7))));
var fiberRefUnsafeMakeSupervisor2 = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch2(initial, {
  differ: differ4,
  fork: empty53
}), "fiberRefUnsafeMakeSupervisor");
var fiberRefLocallyScoped2 = /* @__PURE__ */ dual2(2, (self, value) => asVoid4(acquireRelease3(flatMap16(fiberRefGet2(self), (oldValue) => as4(fiberRefSet2(self, value), oldValue)), (oldValue) => fiberRefSet2(self, oldValue))));
var fiberRefLocallyScopedWith2 = /* @__PURE__ */ dual2(2, (self, f) => fiberRefGetWith2(self, (a) => fiberRefLocallyScoped2(self, f(a))));
var currentRuntimeFlags2 = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags2(none14);
var currentSupervisor2 = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor2(none17);
var fiberAwaitAll2 = /* @__PURE__ */ __name((fibers) => forEach15(fibers, _await4), "fiberAwaitAll");
var fiberAll2 = /* @__PURE__ */ __name((fibers) => {
  const _fiberAll = {
    ...CommitPrototype4,
    commit() {
      return join4(this);
    },
    [FiberTypeId2]: fiberVariance4,
    id: /* @__PURE__ */ __name(() => fromIterable11(fibers).reduce((id, fiber) => combine11(id, fiber.id()), none13), "id"),
    await: exit4(forEachParUnbounded2(fibers, (fiber) => flatten10(fiber.await), false)),
    children: map19(forEachParUnbounded2(fibers, (fiber) => fiber.children, false), flatten7),
    inheritAll: forEachSequentialDiscard2(fibers, (fiber) => fiber.inheritAll),
    poll: map19(forEachSequential2(fibers, (fiber) => fiber.poll), reduceRight4(some6(exitSucceed3(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none11();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none11();
            }
            case "Some": {
              return some6(exitZipWith2(optionA.value, optionB.value, {
                onSuccess: /* @__PURE__ */ __name((a, chunk3) => [a, ...chunk3], "onSuccess"),
                onFailure: parallel4
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: /* @__PURE__ */ __name((fiberId5) => forEachSequentialDiscard2(fibers, (fiber) => fiber.interruptAsFork(fiberId5)), "interruptAsFork")
  };
  return _fiberAll;
}, "fiberAll");
var raceWith3 = /* @__PURE__ */ dual2(3, (self, other, options) => raceFibersWith2(self, other, {
  onSelfWin: /* @__PURE__ */ __name((winner, loser) => flatMap16(winner.await, (exit7) => {
    switch (exit7._tag) {
      case OP_SUCCESS2: {
        return flatMap16(winner.inheritAll, () => options.onSelfDone(exit7, loser));
      }
      case OP_FAILURE2: {
        return options.onSelfDone(exit7, loser);
      }
    }
  }), "onSelfWin"),
  onOtherWin: /* @__PURE__ */ __name((winner, loser) => flatMap16(winner.await, (exit7) => {
    switch (exit7._tag) {
      case OP_SUCCESS2: {
        return flatMap16(winner.inheritAll, () => options.onOtherDone(exit7, loser));
      }
      case OP_FAILURE2: {
        return options.onOtherDone(exit7, loser);
      }
    }
  }), "onOtherWin")
}));
var disconnect3 = /* @__PURE__ */ __name((self) => uninterruptibleMask4((restore) => fiberIdWith3((fiberId5) => flatMap16(forkDaemon3(restore(self)), (fiber) => pipe2(restore(join4(fiber)), onInterrupt3(() => pipe2(fiber, interruptAsFork2(fiberId5))))))), "disconnect");
var race3 = /* @__PURE__ */ dual2(2, (self, that) => fiberIdWith3((parentFiberId) => raceWith3(self, that, {
  onSelfDone: /* @__PURE__ */ __name((exit7, right5) => exitMatchEffect2(exit7, {
    onFailure: /* @__PURE__ */ __name((cause5) => pipe2(join4(right5), mapErrorCause3((cause22) => parallel4(cause5, cause22))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value) => pipe2(right5, interruptAsFiber2(parentFiberId), as4(value)), "onSuccess")
  }), "onSelfDone"),
  onOtherDone: /* @__PURE__ */ __name((exit7, left5) => exitMatchEffect2(exit7, {
    onFailure: /* @__PURE__ */ __name((cause5) => pipe2(join4(left5), mapErrorCause3((cause22) => parallel4(cause22, cause5))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value) => pipe2(left5, interruptAsFiber2(parentFiberId), as4(value)), "onSuccess")
  }), "onOtherDone")
})));
var raceFibersWith2 = /* @__PURE__ */ dual2(3, (self, other, options) => withFiberRuntime3((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make49(true);
  const leftFiber = unsafeMakeChildFiber2(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber2(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_2((cb) => {
    leftFiber.addObserver(() => completeRace2(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace2(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine11(leftFiber.id(), rightFiber.id()));
}));
var completeRace2 = /* @__PURE__ */ __name((winner, loser, cont, ab, cb) => {
  if (compareAndSet2(true, false)(ab)) {
    cb(cont(winner, loser));
  }
}, "completeRace");
var ensuring3 = /* @__PURE__ */ dual2(2, (self, finalizer) => uninterruptibleMask4((restore) => matchCauseEffect4(restore(self), {
  onFailure: /* @__PURE__ */ __name((cause1) => matchCauseEffect4(finalizer, {
    onFailure: /* @__PURE__ */ __name((cause22) => failCause5(sequential4(cause1, cause22)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => failCause5(cause1), "onSuccess")
  }), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => as4(finalizer, a), "onSuccess")
})));
var invokeWithInterrupt2 = /* @__PURE__ */ __name((self, entries3, onInterrupt5) => fiberIdWith3((id) => flatMap16(flatMap16(forkDaemon3(interruptible6(self)), (processing) => async_2((cb) => {
  const counts = entries3.map((_) => _.listeners.count);
  const checkDone = /* @__PURE__ */ __name(() => {
    if (counts.every((count) => count === 0)) {
      if (entries3.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit2(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted2(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt5?.();
        cb(interruptFiber2(processing));
      }
    }
  }, "checkDone");
  processing.addObserver((exit7) => {
    cleanup.forEach((f) => f());
    cb(exit7);
  });
  const cleanup = entries3.map((r, i) => {
    const observer = /* @__PURE__ */ __name((count) => {
      counts[i] = count;
      checkDone();
    }, "observer");
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync5(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend5(() => {
  const residual = entries3.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard2(residual, (entry) => complete3(entry.request, exitInterrupt3(id)));
}))), "invokeWithInterrupt");
var makeSpanScoped3 = /* @__PURE__ */ __name((name, options) => {
  options = addSpanStackTrace2(options);
  return uninterruptible3(withFiberRuntime3((fiber) => {
    const scope5 = unsafeGet8(fiber.getFiberRef(currentContext2), scopeTag2);
    const span3 = unsafeMakeSpan2(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled2);
    const clock_ = get15(fiber.getFiberRef(currentServices2), clockTag2);
    return as4(scopeAddFinalizerExit2(scope5, (exit7) => endSpan2(span3, exit7, clock_, timingEnabled)), span3);
  }));
}, "makeSpanScoped");
var withTracerScoped3 = /* @__PURE__ */ __name((value) => fiberRefLocallyScopedWith2(currentServices2, add7(tracerTag2, value)), "withTracerScoped");
var withSpanScoped3 = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace2(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return flatMap16(makeSpanScoped3(name, addSpanStackTrace2(options)), (span3) => provideService3(self, spanTag2, span3));
  }
  return (self) => flatMap16(makeSpanScoped3(name, addSpanStackTrace2(options)), (span3) => provideService3(self, spanTag2, span3));
}, "withSpanScoped");

// node_modules/effect/dist/esm/internal/cache.js
var complete4 = /* @__PURE__ */ __name((key, exit7, entryStats, timeToLiveMillis) => struct3({
  _tag: "Complete",
  key,
  exit: exit7,
  entryStats,
  timeToLiveMillis
}), "complete");
var pending4 = /* @__PURE__ */ __name((key, deferred) => struct3({
  _tag: "Pending",
  key,
  deferred
}), "pending");
var refreshing2 = /* @__PURE__ */ __name((deferred, complete5) => struct3({
  _tag: "Refreshing",
  deferred,
  complete: complete5
}), "refreshing");
var MapKeyTypeId2 = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
var MapKeyImpl2 = class {
  static {
    __name(this, "MapKeyImpl");
  }
  current;
  [MapKeyTypeId2] = MapKeyTypeId2;
  previous = void 0;
  next = void 0;
  constructor(current) {
    this.current = current;
  }
  [symbol3]() {
    return pipe2(hash2(this.current), combine9(hash2(this.previous)), combine9(hash2(this.next)), cached4(this));
  }
  [symbol4](that) {
    if (this === that) {
      return true;
    }
    return isMapKey2(that) && equals3(this.current, that.current) && equals3(this.previous, that.previous) && equals3(this.next, that.next);
  }
};
var makeMapKey2 = /* @__PURE__ */ __name((current) => new MapKeyImpl2(current), "makeMapKey");
var isMapKey2 = /* @__PURE__ */ __name((u) => hasProperty2(u, MapKeyTypeId2), "isMapKey");
var KeySetImpl2 = class {
  static {
    __name(this, "KeySetImpl");
  }
  head = void 0;
  tail = void 0;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous = key.previous;
        const next = key.next;
        if (next !== void 0) {
          key.next = void 0;
          if (previous !== void 0) {
            previous.next = next;
            next.previous = previous;
          } else {
            this.head = next;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next = key.next;
      if (next !== void 0) {
        key.next = void 0;
        this.head = next;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet2 = /* @__PURE__ */ __name(() => new KeySetImpl2(), "makeKeySet");
var makeCacheState2 = /* @__PURE__ */ __name((map23, keys9, accesses, updating, hits, misses) => ({
  map: map23,
  keys: keys9,
  accesses,
  updating,
  hits,
  misses
}), "makeCacheState");
var initialCacheState2 = /* @__PURE__ */ __name(() => makeCacheState2(empty45(), makeKeySet2(), unbounded2(), make49(false), 0, 0), "initialCacheState");
var CacheSymbolKey2 = "effect/Cache";
var CacheTypeId2 = /* @__PURE__ */ Symbol.for(CacheSymbolKey2);
var cacheVariance2 = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Error: /* @__PURE__ */ __name((_) => _, "_Error"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var ConsumerCacheSymbolKey2 = "effect/ConsumerCache";
var ConsumerCacheTypeId2 = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey2);
var consumerCacheVariance2 = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Error: /* @__PURE__ */ __name((_) => _, "_Error"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var makeCacheStats2 = /* @__PURE__ */ __name((options) => options, "makeCacheStats");
var makeEntryStats2 = /* @__PURE__ */ __name((loadedMillis) => ({
  loadedMillis
}), "makeEntryStats");
var CacheImpl2 = class {
  static {
    __name(this, "CacheImpl");
  }
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId2] = cacheVariance2;
  [ConsumerCacheTypeId2] = consumerCacheVariance2;
  cacheState;
  constructor(capacity, context7, fiberId5, lookup, timeToLive) {
    this.capacity = capacity;
    this.context = context7;
    this.fiberId = fiberId5;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState2();
  }
  get(key) {
    return map19(this.getEither(key), merge7);
  }
  get cacheStats() {
    return sync5(() => makeCacheStats2({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size12(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend5(() => match11(get20(this.cacheState.map, key), {
      onNone: /* @__PURE__ */ __name(() => {
        const mapKey = makeMapKey2(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed7(none11());
      }, "onNone"),
      onSome: /* @__PURE__ */ __name((value) => this.resolveMapValue(value), "onSome")
    }));
  }
  getOptionComplete(key) {
    return suspend5(() => match11(get20(this.cacheState.map, key), {
      onNone: /* @__PURE__ */ __name(() => {
        const mapKey = makeMapKey2(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed7(none11());
      }, "onNone"),
      onSome: /* @__PURE__ */ __name((value) => this.resolveMapValue(value, true), "onSome")
    }));
  }
  contains(key) {
    return sync5(() => has10(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync5(() => {
      const option5 = get20(this.cacheState.map, key);
      if (isSome4(option5)) {
        switch (option5.value._tag) {
          case "Complete": {
            const loaded = option5.value.entryStats.loadedMillis;
            return some6(makeEntryStats2(loaded));
          }
          case "Pending": {
            return none11();
          }
          case "Refreshing": {
            const loaded = option5.value.complete.entryStats.loadedMillis;
            return some6(makeEntryStats2(loaded));
          }
        }
      }
      return none11();
    });
  }
  getEither(key) {
    return suspend5(() => {
      const k = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value = getOrUndefined2(get20(this.cacheState.map, k));
      if (value === void 0) {
        deferred = unsafeMake10(this.fiberId);
        mapKey = makeMapKey2(k);
        if (has10(this.cacheState.map, k)) {
          value = getOrUndefined2(get20(this.cacheState.map, k));
        } else {
          set9(this.cacheState.map, k, pending4(mapKey, deferred));
        }
      }
      if (value === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map19(this.lookupValueOf(key, deferred), right4);
      } else {
        return flatMap16(this.resolveMapValue(value), match11({
          onNone: /* @__PURE__ */ __name(() => this.getEither(key), "onNone"),
          onSome: /* @__PURE__ */ __name((value2) => succeed7(left4(value2)), "onSome")
        }));
      }
    });
  }
  invalidate(key) {
    return sync5(() => {
      remove12(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when5) {
    return sync5(() => {
      const value = get20(this.cacheState.map, key);
      if (isSome4(value) && value.value._tag === "Complete") {
        if (value.value.exit._tag === "Success") {
          if (when5(value.value.exit.value)) {
            remove12(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync5(() => {
      this.cacheState.map = empty45();
    });
  }
  refresh(key) {
    return clockWith7((clock5) => suspend5(() => {
      const k = key;
      const deferred = unsafeMake10(this.fiberId);
      let value = getOrUndefined2(get20(this.cacheState.map, k));
      if (value === void 0) {
        if (has10(this.cacheState.map, k)) {
          value = getOrUndefined2(get20(this.cacheState.map, k));
        } else {
          set9(this.cacheState.map, k, pending4(makeMapKey2(k), deferred));
        }
      }
      if (value === void 0) {
        return asVoid4(this.lookupValueOf(key, deferred));
      } else {
        switch (value._tag) {
          case "Complete": {
            if (this.hasExpired(clock5, value.timeToLiveMillis)) {
              const found = getOrUndefined2(get20(this.cacheState.map, k));
              if (equals3(found, value)) {
                remove12(this.cacheState.map, k);
              }
              return asVoid4(this.get(key));
            }
            return pipe2(this.lookupValueOf(key, deferred), when3(() => {
              const current = getOrUndefined2(get20(this.cacheState.map, k));
              if (equals3(current, value)) {
                const mapValue = refreshing2(deferred, value);
                set9(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid4);
          }
          case "Pending": {
            return _await3(value.deferred);
          }
          case "Refreshing": {
            return _await3(value.deferred);
          }
        }
      }
    }));
  }
  set(key, value) {
    return clockWith7((clock5) => sync5(() => {
      const now = clock5.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed8(value);
      const mapValue = complete4(makeMapKey2(k), lookupResult, makeEntryStats2(now), now + toMillis2(decode2(this.timeToLive(lookupResult))));
      set9(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync5(() => {
      return size12(this.cacheState.map);
    });
  }
  get values() {
    return sync5(() => {
      const values5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values5.push(entry[1].exit.value);
        }
      }
      return values5;
    });
  }
  get entries() {
    return sync5(() => {
      const values5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values5.push([entry[0], entry[1].exit.value]);
        }
      }
      return values5;
    });
  }
  get keys() {
    return sync5(() => {
      const keys9 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys9.push(entry[0]);
        }
      }
      return keys9;
    });
  }
  resolveMapValue(value, ignorePending = false) {
    return clockWith7((clock5) => {
      switch (value._tag) {
        case "Complete": {
          this.trackAccess(value.key);
          if (this.hasExpired(clock5, value.timeToLiveMillis)) {
            remove12(this.cacheState.map, value.key.current);
            return succeed7(none11());
          }
          this.trackHit();
          return map19(value.exit, some6);
        }
        case "Pending": {
          this.trackAccess(value.key);
          this.trackHit();
          if (ignorePending) {
            return succeed7(none11());
          }
          return map19(_await3(value.deferred), some6);
        }
        case "Refreshing": {
          this.trackAccess(value.complete.key);
          this.trackHit();
          if (this.hasExpired(clock5, value.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed7(none11());
            }
            return map19(_await3(value.deferred), some6);
          }
          return map19(value.complete.exit, some6);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer2(this.cacheState.accesses, key);
    if (compareAndSet2(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue2);
        if (key2 === EmptyMutableQueue2) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size17 = size12(this.cacheState.map);
      loop5 = size17 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has10(this.cacheState.map, key2.current)) {
            remove12(this.cacheState.map, key2.current);
            size17 = size17 - 1;
            loop5 = size17 > this.capacity;
          }
        } else {
          loop5 = false;
        }
      }
      set7(this.cacheState.updating, false);
    }
  }
  hasExpired(clock5, timeToLiveMillis) {
    return clock5.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith7((clock5) => suspend5(() => {
      const key = input;
      return pipe2(this.lookup(input), provideContext3(this.context), exit4, flatMap16((exit7) => {
        const now = clock5.unsafeCurrentTimeMillis();
        const stats = makeEntryStats2(now);
        const value = complete4(makeMapKey2(key), exit7, stats, now + toMillis2(decode2(this.timeToLive(exit7))));
        set9(this.cacheState.map, key, value);
        return zipRight3(done8(deferred, exit7), exit7);
      }), onInterrupt3(() => zipRight3(interrupt7(deferred), sync5(() => {
        remove12(this.cacheState.map, key);
      }))));
    }));
  }
};
var unsafeMakeWith2 = /* @__PURE__ */ __name((capacity, lookup, timeToLive) => new CacheImpl2(capacity, empty31(), none12, lookup, (exit7) => decode2(timeToLive(exit7))), "unsafeMakeWith");

// node_modules/effect/dist/esm/Effect.js
var Effect_exports2 = {};
__export(Effect_exports2, {
  Do: () => Do4,
  EffectTypeId: () => EffectTypeId6,
  Service: () => Service2,
  Tag: () => Tag4,
  acquireRelease: () => acquireRelease4,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible4,
  acquireUseRelease: () => acquireUseRelease4,
  addFinalizer: () => addFinalizer4,
  all: () => all6,
  allSuccesses: () => allSuccesses4,
  allWith: () => allWith4,
  allowInterrupt: () => allowInterrupt4,
  andThen: () => andThen6,
  annotateCurrentSpan: () => annotateCurrentSpan4,
  annotateLogs: () => annotateLogs4,
  annotateLogsScoped: () => annotateLogsScoped4,
  annotateSpans: () => annotateSpans4,
  ap: () => ap2,
  as: () => as6,
  asSome: () => asSome4,
  asSomeError: () => asSomeError4,
  asVoid: () => asVoid6,
  async: () => async4,
  asyncEffect: () => asyncEffect4,
  awaitAllChildren: () => awaitAllChildren4,
  bind: () => bind6,
  bindAll: () => bindAll4,
  bindTo: () => bindTo6,
  blocked: () => blocked4,
  cacheRequestResult: () => cacheRequestResult2,
  cached: () => cached6,
  cachedFunction: () => cachedFunction4,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL4,
  cachedWithTTL: () => cachedWithTTL2,
  catch: () => _catch4,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  catchAllDefect: () => catchAllDefect4,
  catchIf: () => catchIf4,
  catchSome: () => catchSome4,
  catchSomeCause: () => catchSomeCause4,
  catchSomeDefect: () => catchSomeDefect4,
  catchTag: () => catchTag4,
  catchTags: () => catchTags4,
  cause: () => cause4,
  checkInterruptible: () => checkInterruptible4,
  clock: () => clock4,
  clockWith: () => clockWith8,
  configProviderWith: () => configProviderWith4,
  console: () => console5,
  consoleWith: () => consoleWith4,
  context: () => context6,
  contextWith: () => contextWith4,
  contextWithEffect: () => contextWithEffect4,
  currentParentSpan: () => currentParentSpan4,
  currentSpan: () => currentSpan4,
  custom: () => custom4,
  daemonChildren: () => daemonChildren4,
  delay: () => delay4,
  descriptor: () => descriptor4,
  descriptorWith: () => descriptorWith4,
  die: () => die6,
  dieMessage: () => dieMessage4,
  dieSync: () => dieSync4,
  diffFiberRefs: () => diffFiberRefs4,
  disconnect: () => disconnect4,
  dropUntil: () => dropUntil4,
  dropWhile: () => dropWhile4,
  either: () => either6,
  ensureErrorType: () => ensureErrorType2,
  ensureRequirementsType: () => ensureRequirementsType2,
  ensureSuccessType: () => ensureSuccessType2,
  ensuring: () => ensuring4,
  ensuringChild: () => ensuringChild4,
  ensuringChildren: () => ensuringChildren4,
  eventually: () => eventually4,
  every: () => every10,
  exists: () => exists4,
  exit: () => exit6,
  fail: () => fail8,
  failCause: () => failCause8,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberId: () => fiberId4,
  fiberIdWith: () => fiberIdWith4,
  filter: () => filter10,
  filterEffectOrElse: () => filterEffectOrElse4,
  filterEffectOrFail: () => filterEffectOrFail4,
  filterMap: () => filterMap8,
  filterOrDie: () => filterOrDie4,
  filterOrDieMessage: () => filterOrDieMessage4,
  filterOrElse: () => filterOrElse4,
  filterOrFail: () => filterOrFail4,
  finalizersMask: () => finalizersMask4,
  findFirst: () => findFirst10,
  firstSuccessOf: () => firstSuccessOf4,
  flatMap: () => flatMap18,
  flatten: () => flatten12,
  flip: () => flip4,
  flipWith: () => flipWith4,
  fn: () => fn2,
  fnUntraced: () => fnUntraced4,
  forEach: () => forEach16,
  forever: () => forever6,
  fork: () => fork6,
  forkAll: () => forkAll4,
  forkDaemon: () => forkDaemon4,
  forkIn: () => forkIn4,
  forkScoped: () => forkScoped4,
  forkWithErrorHandler: () => forkWithErrorHandler4,
  fromFiber: () => fromFiber4,
  fromFiberEffect: () => fromFiberEffect4,
  fromNullable: () => fromNullable6,
  functionWithSpan: () => functionWithSpan4,
  gen: () => gen4,
  getFiberRefs: () => getFiberRefs2,
  getRuntimeFlags: () => getRuntimeFlags2,
  head: () => head8,
  if: () => if_4,
  ignore: () => ignore4,
  ignoreLogged: () => ignoreLogged4,
  inheritFiberRefs: () => inheritFiberRefs4,
  interrupt: () => interrupt8,
  interruptWith: () => interruptWith4,
  interruptible: () => interruptible8,
  interruptibleMask: () => interruptibleMask4,
  intoDeferred: () => intoDeferred4,
  isEffect: () => isEffect4,
  isFailure: () => isFailure4,
  isSuccess: () => isSuccess4,
  iterate: () => iterate4,
  labelMetrics: () => labelMetrics4,
  labelMetricsScoped: () => labelMetricsScoped4,
  let: () => let_6,
  liftPredicate: () => liftPredicate4,
  linkSpanCurrent: () => linkSpanCurrent4,
  linkSpans: () => linkSpans4,
  locally: () => locally2,
  locallyScoped: () => locallyScoped2,
  locallyScopedWith: () => locallyScopedWith2,
  locallyWith: () => locallyWith2,
  log: () => log4,
  logAnnotations: () => logAnnotations4,
  logDebug: () => logDebug4,
  logError: () => logError4,
  logFatal: () => logFatal4,
  logInfo: () => logInfo4,
  logTrace: () => logTrace4,
  logWarning: () => logWarning4,
  logWithLevel: () => logWithLevel4,
  loop: () => loop4,
  makeLatch: () => makeLatch4,
  makeSemaphore: () => makeSemaphore4,
  makeSpan: () => makeSpan4,
  makeSpanScoped: () => makeSpanScoped4,
  map: () => map22,
  mapAccum: () => mapAccum6,
  mapBoth: () => mapBoth4,
  mapError: () => mapError4,
  mapErrorCause: () => mapErrorCause4,
  mapInputContext: () => mapInputContext4,
  match: () => match18,
  matchCause: () => matchCause6,
  matchCauseEffect: () => matchCauseEffect6,
  matchEffect: () => matchEffect4,
  merge: () => merge12,
  mergeAll: () => mergeAll10,
  metricLabels: () => metricLabels4,
  negate: () => negate4,
  never: () => never4,
  none: () => none18,
  onError: () => onError4,
  onExit: () => onExit6,
  onInterrupt: () => onInterrupt4,
  once: () => once6,
  option: () => option4,
  optionFromOptional: () => optionFromOptional4,
  orDie: () => orDie4,
  orDieWith: () => orDieWith4,
  orElse: () => orElse4,
  orElseFail: () => orElseFail4,
  orElseSucceed: () => orElseSucceed4,
  parallelErrors: () => parallelErrors4,
  parallelFinalizers: () => parallelFinalizers4,
  partition: () => partition8,
  patchFiberRefs: () => patchFiberRefs4,
  patchRuntimeFlags: () => patchRuntimeFlags2,
  promise: () => promise4,
  provide: () => provide4,
  provideService: () => provideService4,
  provideServiceEffect: () => provideServiceEffect4,
  race: () => race4,
  raceAll: () => raceAll4,
  raceFirst: () => raceFirst4,
  raceWith: () => raceWith4,
  random: () => random6,
  randomWith: () => randomWith4,
  reduce: () => reduce20,
  reduceEffect: () => reduceEffect4,
  reduceRight: () => reduceRight6,
  reduceWhile: () => reduceWhile4,
  repeat: () => repeat2,
  repeatN: () => repeatN4,
  repeatOrElse: () => repeatOrElse2,
  replicate: () => replicate4,
  replicateEffect: () => replicateEffect4,
  request: () => request2,
  retry: () => retry2,
  retryOrElse: () => retryOrElse2,
  runCallback: () => runCallback2,
  runFork: () => runFork4,
  runPromise: () => runPromise2,
  runPromiseExit: () => runPromiseExit2,
  runRequestBlock: () => runRequestBlock4,
  runSync: () => runSync2,
  runSyncExit: () => runSyncExit2,
  runtime: () => runtime6,
  sandbox: () => sandbox4,
  schedule: () => schedule2,
  scheduleForked: () => scheduleForked4,
  scheduleFrom: () => scheduleFrom2,
  scope: () => scope4,
  scopeWith: () => scopeWith4,
  scoped: () => scoped4,
  scopedWith: () => scopedWith4,
  sequentialFinalizers: () => sequentialFinalizers4,
  serviceConstants: () => serviceConstants4,
  serviceFunction: () => serviceFunction4,
  serviceFunctionEffect: () => serviceFunctionEffect4,
  serviceFunctions: () => serviceFunctions4,
  serviceMembers: () => serviceMembers4,
  serviceOption: () => serviceOption4,
  serviceOptional: () => serviceOptional4,
  setFiberRefs: () => setFiberRefs4,
  sleep: () => sleep8,
  spanAnnotations: () => spanAnnotations4,
  spanLinks: () => spanLinks4,
  step: () => step6,
  succeed: () => succeed12,
  succeedNone: () => succeedNone4,
  succeedSome: () => succeedSome4,
  summarized: () => summarized4,
  supervised: () => supervised4,
  suspend: () => suspend8,
  sync: () => sync8,
  tagMetrics: () => tagMetrics4,
  tagMetricsScoped: () => tagMetricsScoped4,
  takeUntil: () => takeUntil4,
  takeWhile: () => takeWhile4,
  tap: () => tap4,
  tapBoth: () => tapBoth4,
  tapDefect: () => tapDefect4,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  tapErrorTag: () => tapErrorTag4,
  timed: () => timed4,
  timedWith: () => timedWith4,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutOption: () => timeoutOption4,
  timeoutTo: () => timeoutTo4,
  tracer: () => tracer4,
  tracerWith: () => tracerWith8,
  transplant: () => transplant4,
  transposeMapOption: () => transposeMapOption2,
  transposeOption: () => transposeOption2,
  try: () => try_4,
  tryMap: () => tryMap4,
  tryMapPromise: () => tryMapPromise4,
  tryPromise: () => tryPromise4,
  uninterruptible: () => uninterruptible4,
  uninterruptibleMask: () => uninterruptibleMask6,
  unless: () => unless4,
  unlessEffect: () => unlessEffect4,
  unsafeMakeLatch: () => unsafeMakeLatch4,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore4,
  unsandbox: () => unsandbox4,
  updateFiberRefs: () => updateFiberRefs4,
  updateService: () => updateService4,
  useSpan: () => useSpan4,
  using: () => using4,
  validate: () => validate4,
  validateAll: () => validateAll4,
  validateFirst: () => validateFirst4,
  validateWith: () => validateWith4,
  void: () => _void2,
  when: () => when4,
  whenEffect: () => whenEffect4,
  whenFiberRef: () => whenFiberRef4,
  whenLogLevel: () => whenLogLevel4,
  whenRef: () => whenRef4,
  whileLoop: () => whileLoop6,
  withClock: () => withClock4,
  withClockScoped: () => withClockScoped4,
  withConcurrency: () => withConcurrency4,
  withConfigProvider: () => withConfigProvider4,
  withConfigProviderScoped: () => withConfigProviderScoped4,
  withConsole: () => withConsole4,
  withConsoleScoped: () => withConsoleScoped4,
  withEarlyRelease: () => withEarlyRelease4,
  withExecutionPlan: () => withExecutionPlan4,
  withFiberRuntime: () => withFiberRuntime4,
  withLogSpan: () => withLogSpan4,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield4,
  withMetric: () => withMetric4,
  withParentSpan: () => withParentSpan4,
  withRandom: () => withRandom4,
  withRandomFixed: () => withRandomFixed2,
  withRandomScoped: () => withRandomScoped4,
  withRequestBatching: () => withRequestBatching4,
  withRequestCache: () => withRequestCache4,
  withRequestCaching: () => withRequestCaching4,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch2,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped2,
  withScheduler: () => withScheduler4,
  withSchedulingPriority: () => withSchedulingPriority4,
  withSpan: () => withSpan4,
  withSpanScoped: () => withSpanScoped4,
  withTracer: () => withTracer4,
  withTracerEnabled: () => withTracerEnabled4,
  withTracerScoped: () => withTracerScoped4,
  withTracerTiming: () => withTracerTiming4,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel4,
  yieldNow: () => yieldNow8,
  zip: () => zip8,
  zipLeft: () => zipLeft4,
  zipRight: () => zipRight4,
  zipWith: () => zipWith6
});

// node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey2 = "effect/ScheduleInterval";
var IntervalTypeId2 = /* @__PURE__ */ Symbol.for(IntervalSymbolKey2);
var empty54 = {
  [IntervalTypeId2]: IntervalTypeId2,
  startMillis: 0,
  endMillis: 0
};
var make72 = /* @__PURE__ */ __name((startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty54;
  }
  return {
    [IntervalTypeId2]: IntervalTypeId2,
    startMillis,
    endMillis
  };
}, "make");
var lessThan8 = /* @__PURE__ */ dual2(2, (self, that) => min4(self, that) === self);
var min4 = /* @__PURE__ */ dual2(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
var isEmpty15 = /* @__PURE__ */ __name((self) => {
  return self.startMillis >= self.endMillis;
}, "isEmpty");
var intersect6 = /* @__PURE__ */ dual2(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end5 = Math.min(self.endMillis, that.endMillis);
  return make72(start5, end5);
});
var after3 = /* @__PURE__ */ __name((startMilliseconds) => {
  return make72(startMilliseconds, Number.POSITIVE_INFINITY);
}, "after");

// node_modules/effect/dist/esm/ScheduleInterval.js
var empty55 = empty54;
var lessThan9 = lessThan8;
var isEmpty16 = isEmpty15;
var intersect7 = intersect6;
var after4 = after3;

// node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey2 = "effect/ScheduleIntervals";
var IntervalsTypeId2 = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey2);
var make74 = /* @__PURE__ */ __name((intervals) => {
  return {
    [IntervalsTypeId2]: IntervalsTypeId2,
    intervals
  };
}, "make");
var intersect8 = /* @__PURE__ */ dual2(2, (self, that) => intersectLoop2(self.intervals, that.intervals, empty32()));
var intersectLoop2 = /* @__PURE__ */ __name((_left, _right, _acc) => {
  let left5 = _left;
  let right5 = _right;
  let acc = _acc;
  while (isNonEmpty5(left5) && isNonEmpty5(right5)) {
    const interval = pipe2(headNonEmpty4(left5), intersect7(headNonEmpty4(right5)));
    const intervals = isEmpty16(interval) ? acc : pipe2(acc, prepend5(interval));
    if (pipe2(headNonEmpty4(left5), lessThan9(headNonEmpty4(right5)))) {
      left5 = tailNonEmpty4(left5);
    } else {
      right5 = tailNonEmpty4(right5);
    }
    acc = intervals;
  }
  return make74(reverse5(acc));
}, "intersectLoop");
var start3 = /* @__PURE__ */ __name((self) => {
  return pipe2(self.intervals, head6, getOrElse5(() => empty55)).startMillis;
}, "start");
var end3 = /* @__PURE__ */ __name((self) => {
  return pipe2(self.intervals, head6, getOrElse5(() => empty55)).endMillis;
}, "end");
var lessThan10 = /* @__PURE__ */ dual2(2, (self, that) => start3(self) < start3(that));
var isNonEmpty7 = /* @__PURE__ */ __name((self) => {
  return isNonEmpty5(self.intervals);
}, "isNonEmpty");

// node_modules/effect/dist/esm/ScheduleIntervals.js
var make75 = make74;
var intersect9 = intersect8;
var start4 = start3;
var end4 = end3;
var lessThan11 = lessThan10;
var isNonEmpty8 = isNonEmpty7;

// node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE2 = "Continue";
var OP_DONE4 = "Done";
var _continue3 = /* @__PURE__ */ __name((intervals) => {
  return {
    _tag: OP_CONTINUE2,
    intervals
  };
}, "_continue");
var continueWith3 = /* @__PURE__ */ __name((interval) => {
  return {
    _tag: OP_CONTINUE2,
    intervals: make75(of6(interval))
  };
}, "continueWith");
var done11 = {
  _tag: OP_DONE4
};
var isContinue3 = /* @__PURE__ */ __name((self) => {
  return self._tag === OP_CONTINUE2;
}, "isContinue");
var isDone7 = /* @__PURE__ */ __name((self) => {
  return self._tag === OP_DONE4;
}, "isDone");

// node_modules/effect/dist/esm/ScheduleDecision.js
var _continue4 = _continue3;
var continueWith4 = continueWith3;
var done12 = done11;
var isContinue4 = isContinue3;
var isDone8 = isDone7;

// node_modules/effect/dist/esm/Scope.js
var close2 = scopeClose2;
var fork5 = scopeFork2;

// node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore2 = class {
  static {
    __name(this, "Semaphore");
  }
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = /* @__PURE__ */ __name((n) => asyncInterrupt2((resume3) => {
    if (this.free < n) {
      const observer = /* @__PURE__ */ __name(() => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume3(succeed7(n));
      }, "observer");
      this.waiters.add(observer);
      return sync5(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume3(succeed7(n));
  }), "take");
  updateTakenUnsafe(fiber, f) {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler2).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority2));
    }
    return succeed7(this.free);
  }
  updateTaken(f) {
    return withFiberRuntime3((fiber) => this.updateTakenUnsafe(fiber, f));
  }
  resize = /* @__PURE__ */ __name((permits) => asVoid4(withFiberRuntime3((fiber) => {
    this.permits = permits;
    if (this.free < 0) {
      return void_3;
    }
    return this.updateTakenUnsafe(fiber, (taken) => taken);
  })), "resize");
  release = /* @__PURE__ */ __name((n) => this.updateTaken((taken) => taken - n), "release");
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = /* @__PURE__ */ __name((n) => (self) => uninterruptibleMask4((restore) => flatMap16(restore(this.take(n)), (permits) => ensuring3(restore(self), this.release(permits)))), "withPermits");
  withPermitsIfAvailable = /* @__PURE__ */ __name((n) => (self) => uninterruptibleMask4((restore) => suspend5(() => {
    if (this.free < n) {
      return succeedNone3;
    }
    this.taken += n;
    return ensuring3(restore(asSome3(self)), this.release(n));
  })), "withPermitsIfAvailable");
};
var unsafeMakeSemaphore3 = /* @__PURE__ */ __name((permits) => new Semaphore2(permits), "unsafeMakeSemaphore");
var makeSemaphore3 = /* @__PURE__ */ __name((permits) => sync5(() => unsafeMakeSemaphore3(permits)), "makeSemaphore");
var Latch2 = class extends Class6 {
  static {
    __name(this, "Latch");
  }
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_3;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority2));
    return void_3;
  }
  flushWaiters = /* @__PURE__ */ __name(() => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0; i < waiters.length; i++) {
      waiters[i](exitVoid3);
    }
  }, "flushWaiters");
  open = /* @__PURE__ */ withFiberRuntime3((fiber) => {
    if (this.isOpen) {
      return void_3;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime3((fiber) => {
    if (this.isOpen) {
      return void_3;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt2((resume3) => {
    if (this.isOpen) {
      return resume3(void_3);
    }
    this.waiters.push(resume3);
    return sync5(() => {
      const index = this.waiters.indexOf(resume3);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync5(() => {
    this.isOpen = false;
  });
  whenOpen = /* @__PURE__ */ __name((self) => {
    return zipRight3(this.await, self);
  }, "whenOpen");
};
var unsafeMakeLatch3 = /* @__PURE__ */ __name((open) => new Latch2(open ?? false), "unsafeMakeLatch");
var makeLatch3 = /* @__PURE__ */ __name((open) => sync5(() => unsafeMakeLatch3(open)), "makeLatch");
var awaitAllChildren3 = /* @__PURE__ */ __name((self) => ensuringChildren3(self, fiberAwaitAll2), "awaitAllChildren");
var cached5 = /* @__PURE__ */ dual2(2, (self, timeToLive) => map19(cachedInvalidateWithTTL3(self, timeToLive), (tuple2) => tuple2[0]));
var cachedInvalidateWithTTL3 = /* @__PURE__ */ dual2(2, (self, timeToLive) => {
  const duration = decode2(timeToLive);
  return flatMap16(context4(), (env) => map19(makeSynchronized2(none11()), (cache) => [provideContext3(getCachedValue2(self, duration, cache), env), invalidateCache2(cache)]));
});
var computeCachedValue2 = /* @__PURE__ */ __name((self, timeToLive, start5) => {
  const timeToLiveMillis = toMillis2(decode2(timeToLive));
  return pipe2(deferredMake2(), tap3((deferred) => intoDeferred3(self, deferred)), map19((deferred) => some6([start5 + timeToLiveMillis, deferred])));
}, "computeCachedValue");
var getCachedValue2 = /* @__PURE__ */ __name((self, timeToLive, cache) => uninterruptibleMask4((restore) => pipe2(clockWith7((clock5) => clock5.currentTimeMillis), flatMap16((time) => updateSomeAndGetEffectSynchronized2(cache, (option5) => {
  switch (option5._tag) {
    case "None": {
      return some6(computeCachedValue2(self, timeToLive, time));
    }
    case "Some": {
      const [end5] = option5.value;
      return end5 - time <= 0 ? some6(computeCachedValue2(self, timeToLive, time)) : none11();
    }
  }
})), flatMap16((option5) => isNone5(option5) ? dieMessage3("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait2(option5.value[1]))))), "getCachedValue");
var invalidateCache2 = /* @__PURE__ */ __name((cache) => set10(cache, none11()), "invalidateCache");
var ensuringChild3 = /* @__PURE__ */ dual2(2, (self, f) => ensuringChildren3(self, (children) => f(fiberAll2(children))));
var ensuringChildren3 = /* @__PURE__ */ dual2(2, (self, children) => flatMap16(track2, (supervisor) => pipe2(supervised3(self, supervisor), ensuring3(flatMap16(supervisor.value, children)))));
var forkAll3 = /* @__PURE__ */ dual2((args3) => isIterable2(args3[0]), (effects, options) => options?.discard ? forEachSequentialDiscard2(effects, fork4) : map19(forEachSequential2(effects, fork4), fiberAll2));
var forkIn3 = /* @__PURE__ */ dual2(2, (self, scope5) => withFiberRuntime3((parent, parentStatus) => {
  const scopeImpl = scope5;
  const fiber = unsafeFork5(self, parent, parentStatus.runtimeFlags, globalScope2);
  if (scopeImpl.state._tag === "Open") {
    const finalizer = /* @__PURE__ */ __name(() => fiberIdWith3((fiberId5) => equals3(fiberId5, fiber.id()) ? void_3 : asVoid4(interruptFiber2(fiber))), "finalizer");
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed7(fiber);
}));
var forkScoped3 = /* @__PURE__ */ __name((self) => scopeWith3((scope5) => forkIn3(self, scope5)), "forkScoped");
var fromFiber3 = /* @__PURE__ */ __name((fiber) => join4(fiber), "fromFiber");
var fromFiberEffect3 = /* @__PURE__ */ __name((fiber) => suspend5(() => flatMap16(fiber, join4)), "fromFiberEffect");
var memoKeySymbol2 = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var Key2 = class {
  static {
    __name(this, "Key");
  }
  a;
  eq;
  [memoKeySymbol2] = memoKeySymbol2;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol4](that) {
    if (hasProperty2(that, memoKeySymbol2)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals3(this.a, that.a);
      }
    }
    return false;
  }
  [symbol3]() {
    return this.eq ? 0 : cached4(this, hash2(this.a));
  }
};
var cachedFunction3 = /* @__PURE__ */ __name((f, eq) => {
  return pipe2(sync5(() => empty45()), flatMap16(makeSynchronized2), map19((ref) => (a) => pipe2(ref.modifyEffect((map23) => {
    const result = pipe2(map23, get20(new Key2(a, eq)));
    if (isNone5(result)) {
      return pipe2(deferredMake2(), tap3((deferred) => pipe2(diffFiberRefs3(f(a)), intoDeferred3(deferred), fork4)), map19((deferred) => [deferred, pipe2(map23, set9(new Key2(a, eq), deferred))]));
    }
    return succeed7([result.value, map23]);
  }), flatMap16(deferredAwait2), flatMap16(([patch17, b]) => pipe2(patchFiberRefs3(patch17), as4(b))))));
}, "cachedFunction");
var raceFirst3 = /* @__PURE__ */ dual2(2, (self, that) => pipe2(exit4(self), race3(exit4(that)), (effect) => flatten10(effect)));
var supervised3 = /* @__PURE__ */ dual2(2, (self, supervisor) => {
  const supervise = fiberRefLocallyWith2(currentSupervisor2, (s) => s.zip(supervisor));
  return supervise(self);
});
var timeout3 = /* @__PURE__ */ dual2(2, (self, duration) => timeoutFail3(self, {
  onTimeout: /* @__PURE__ */ __name(() => timeoutExceptionFromDuration2(duration), "onTimeout"),
  duration
}));
var timeoutFail3 = /* @__PURE__ */ dual2(2, (self, {
  duration,
  onTimeout
}) => flatten10(timeoutTo3(self, {
  onTimeout: /* @__PURE__ */ __name(() => failSync3(onTimeout), "onTimeout"),
  onSuccess: succeed7,
  duration
})));
var timeoutFailCause3 = /* @__PURE__ */ dual2(2, (self, {
  duration,
  onTimeout
}) => flatten10(timeoutTo3(self, {
  onTimeout: /* @__PURE__ */ __name(() => failCauseSync3(onTimeout), "onTimeout"),
  onSuccess: succeed7,
  duration
})));
var timeoutOption3 = /* @__PURE__ */ dual2(2, (self, duration) => timeoutTo3(self, {
  duration,
  onSuccess: some6,
  onTimeout: none11
}));
var timeoutTo3 = /* @__PURE__ */ dual2(2, (self, {
  duration,
  onSuccess,
  onTimeout
}) => fiberIdWith3((parentFiberId) => uninterruptibleMask4((restore) => raceFibersWith2(restore(self), interruptible6(sleep7(duration)), {
  onSelfWin: /* @__PURE__ */ __name((winner, loser) => flatMap16(winner.await, (exit7) => {
    if (exit7._tag === "Success") {
      return flatMap16(winner.inheritAll, () => as4(interruptAsFiber2(loser, parentFiberId), onSuccess(exit7.value)));
    } else {
      return flatMap16(interruptAsFiber2(loser, parentFiberId), () => exitFailCause3(exit7.cause));
    }
  }), "onSelfWin"),
  onOtherWin: /* @__PURE__ */ __name((winner, loser) => flatMap16(winner.await, (exit7) => {
    if (exit7._tag === "Success") {
      return flatMap16(winner.inheritAll, () => as4(interruptAsFiber2(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap16(interruptAsFiber2(loser, parentFiberId), () => exitFailCause3(exit7.cause));
    }
  }), "onOtherWin"),
  otherScope: globalScope2
}))));
var SynchronizedSymbolKey2 = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId2 = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey2);
var synchronizedVariance2 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var SynchronizedImpl2 = class extends Class6 {
  static {
    __name(this, "SynchronizedImpl");
  }
  ref;
  withLock;
  [SynchronizedTypeId2] = synchronizedVariance2;
  [RefTypeId2] = refVariance2;
  [TypeId27] = TypeId27;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get23(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed7(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe2(flatMap16(get23(this.ref), f), flatMap16(([b, a]) => as4(set10(this.ref, a), b))));
  }
};
var makeSynchronized2 = /* @__PURE__ */ __name((value) => sync5(() => unsafeMakeSynchronized2(value)), "makeSynchronized");
var unsafeMakeSynchronized2 = /* @__PURE__ */ __name((value) => {
  const ref = unsafeMake12(value);
  const sem = unsafeMakeSemaphore3(1);
  return new SynchronizedImpl2(ref, sem.withPermits(1));
}, "unsafeMakeSynchronized");
var updateSomeAndGetEffectSynchronized2 = /* @__PURE__ */ dual2(2, (self, pf) => self.modifyEffect((value) => {
  const result = pf(value);
  switch (result._tag) {
    case "None": {
      return succeed7([value, value]);
    }
    case "Some": {
      return map19(result.value, (a) => [a, a]);
    }
  }
}));
var bindAll3 = /* @__PURE__ */ dual2((args3) => isEffect3(args3[0]), (self, f, options) => flatMap16(self, (a) => all5(f(a), options).pipe(map19((record) => Object.assign({}, a, record)))));

// node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId30 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_FRESH2 = "Fresh";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_SCOPED2 = "Scoped";
var OP_SUSPEND2 = "Suspend";
var OP_PROVIDE2 = "Provide";
var OP_PROVIDE_MERGE2 = "ProvideMerge";
var OP_MERGE_ALL2 = "MergeAll";

// node_modules/effect/dist/esm/Fiber.js
var interruptAs2 = interruptAsFiber2;

// node_modules/effect/dist/esm/internal/runtime.js
var makeDual2 = /* @__PURE__ */ __name((f) => function() {
  if (arguments.length === 1) {
    const runtime7 = arguments[0];
    return (effect, ...args3) => f(runtime7, effect, ...args3);
  }
  return f.apply(this, arguments);
}, "makeDual");
var unsafeFork6 = /* @__PURE__ */ makeDual2((runtime7, self, options) => {
  const fiberId5 = unsafeMake9();
  const fiberRefUpdates = [[currentContext2, [[fiberId5, runtime7.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler2, [[fiberId5, options.scheduler]]]);
  }
  let fiberRefs5 = updateManyAs4(runtime7.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId5
  });
  if (options?.updateRefs) {
    fiberRefs5 = options.updateRefs(fiberRefs5, fiberId5);
  }
  const fiberRuntime = new FiberRuntime2(fiberId5, fiberRefs5, runtime7.runtimeFlags);
  let effect = self;
  if (options?.scope) {
    effect = flatMap16(fork5(options.scope, sequential5), (closeableScope) => zipRight3(scopeAddFinalizer2(closeableScope, fiberIdWith3((id) => equals3(id, fiberRuntime.id()) ? void_3 : interruptAsFiber2(fiberRuntime, id))), onExit4(self, (exit7) => close2(closeableScope, exit7))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none17) {
    supervisor.onStart(runtime7.context, effect, none11(), fiberRuntime);
    fiberRuntime.addObserver((exit7) => supervisor.onEnd(exit7, fiberRuntime));
  }
  globalScope2.add(runtime7.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
});
var unsafeRunCallback2 = /* @__PURE__ */ makeDual2((runtime7, effect, options = {}) => {
  const fiberRuntime = unsafeFork6(runtime7, effect, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit7) => {
      options.onExit(exit7);
    });
  }
  return (id, cancelOptions) => unsafeRunCallback2(runtime7)(pipe2(fiberRuntime, interruptAs2(id ?? none13)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit7) => cancelOptions.onExit(flatten11(exit7)) : void 0
  });
});
var unsafeRunSync2 = /* @__PURE__ */ makeDual2((runtime7, effect) => {
  const result = unsafeRunSyncExit2(runtime7)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure2(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl2 = class extends Error {
  static {
    __name(this, "AsyncFiberExceptionImpl");
  }
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException2 = /* @__PURE__ */ __name((fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl2(fiber);
  Error.stackTraceLimit = limit;
  return error;
}, "asyncFiberException");
var FiberFailureId2 = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId2 = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl2 = class extends Error {
  static {
    __name(this, "FiberFailureImpl");
  }
  [FiberFailureId2];
  [FiberFailureCauseId2];
  constructor(cause5) {
    const head9 = prettyErrors2(cause5)[0];
    super(head9?.message || "An error has occurred");
    this[FiberFailureId2] = FiberFailureId2;
    this[FiberFailureCauseId2] = cause5;
    this.name = head9 ? `(FiberFailure) ${head9.name}` : "FiberFailure";
    if (head9?.stack) {
      this.stack = head9.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId2].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty2(this[FiberFailureCauseId2], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol2]() {
    return this.toString();
  }
};
var fiberFailure2 = /* @__PURE__ */ __name((cause5) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl2(cause5);
  Error.stackTraceLimit = limit;
  return error;
}, "fiberFailure");
var fastPath2 = /* @__PURE__ */ __name((effect) => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail2(op.left);
    }
    case "Right": {
      return exitSucceed3(op.right);
    }
    case "Some": {
      return exitSucceed3(op.value);
    }
    case "None": {
      return exitFail2(new NoSuchElementException2());
    }
  }
}, "fastPath");
var unsafeRunSyncExit2 = /* @__PURE__ */ makeDual2((runtime7, effect) => {
  const op = fastPath2(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler2();
  const fiberRuntime = unsafeFork6(runtime7)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie3(capture2(asyncFiberException2(fiberRuntime), currentSpanFromFiber2(fiberRuntime)));
});
var unsafeRunPromise2 = /* @__PURE__ */ makeDual2((runtime7, effect, options) => unsafeRunPromiseExit2(runtime7, effect, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS2: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE2: {
      throw fiberFailure2(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit2 = /* @__PURE__ */ makeDual2((runtime7, effect, options) => new Promise((resolve) => {
  const op = fastPath2(effect);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork6(runtime7)(effect);
  fiber.addObserver((exit7) => {
    resolve(exit7);
  });
  if (options?.signal !== void 0) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl2 = class {
  static {
    __name(this, "RuntimeImpl");
  }
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context7, runtimeFlags3, fiberRefs5) {
    this.context = context7;
    this.runtimeFlags = runtimeFlags3;
    this.fiberRefs = fiberRefs5;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var make76 = /* @__PURE__ */ __name((options) => new RuntimeImpl2(options.context, options.runtimeFlags, options.fiberRefs), "make");
var runtime5 = /* @__PURE__ */ __name(() => withFiberRuntime3((state, status) => succeed7(new RuntimeImpl2(state.getFiberRef(currentContext2), status.runtimeFlags, state.getFiberRefs()))), "runtime");
var defaultRuntimeFlags2 = /* @__PURE__ */ make54(Interruption2, CooperativeYielding2, RuntimeMetrics2);
var defaultRuntime2 = /* @__PURE__ */ make76({
  context: /* @__PURE__ */ empty31(),
  runtimeFlags: defaultRuntimeFlags2,
  fiberRefs: /* @__PURE__ */ empty49()
});
var unsafeRunEffect2 = /* @__PURE__ */ unsafeRunCallback2(defaultRuntime2);
var unsafeForkEffect2 = /* @__PURE__ */ unsafeFork6(defaultRuntime2);
var unsafeRunPromiseEffect2 = /* @__PURE__ */ unsafeRunPromise2(defaultRuntime2);
var unsafeRunPromiseExitEffect2 = /* @__PURE__ */ unsafeRunPromiseExit2(defaultRuntime2);
var unsafeRunSyncEffect2 = /* @__PURE__ */ unsafeRunSync2(defaultRuntime2);
var unsafeRunSyncExitEffect2 = /* @__PURE__ */ unsafeRunSyncExit2(defaultRuntime2);
var asyncEffect3 = /* @__PURE__ */ __name((register) => suspend5(() => {
  let cleanup = void 0;
  return flatMap16(deferredMake2(), (deferred) => flatMap16(runtime5(), (runtime7) => uninterruptibleMask4((restore) => zipRight3(fork4(restore(matchCauseEffect4(register((cb) => unsafeRunCallback2(runtime7)(intoDeferred3(cb, deferred))), {
    onFailure: /* @__PURE__ */ __name((cause5) => deferredFailCause2(deferred, cause5), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((cleanup_) => {
      cleanup = cleanup_;
      return void_3;
    }, "onSuccess")
  }))), restore(onInterrupt3(deferredAwait2(deferred), () => cleanup ?? void_3))))));
}), "asyncEffect");

// node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect2 = /* @__PURE__ */ dual2(2, (self, f) => self.modifyEffect(f));

// node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey2 = "effect/Layer";
var LayerTypeId2 = /* @__PURE__ */ Symbol.for(LayerSymbolKey2);
var layerVariance2 = {
  /* c8 ignore next */
  _RIn: /* @__PURE__ */ __name((_) => _, "_RIn"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _ROut: /* @__PURE__ */ __name((_) => _, "_ROut")
};
var proto6 = {
  [LayerTypeId2]: layerVariance2,
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var MemoMapTypeIdKey2 = "effect/Layer/MemoMap";
var MemoMapTypeId2 = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey2);
var CurrentMemoMap2 = /* @__PURE__ */ Reference4()("effect/Layer/CurrentMemoMap", {
  defaultValue: /* @__PURE__ */ __name(() => unsafeMakeMemoMap2(), "defaultValue")
});
var isLayer2 = /* @__PURE__ */ __name((u) => hasProperty2(u, LayerTypeId2), "isLayer");
var isFresh2 = /* @__PURE__ */ __name((self) => {
  return self._op_layer === OP_FRESH2;
}, "isFresh");
var MemoMapImpl2 = class {
  static {
    __name(this, "MemoMapImpl");
  }
  ref;
  [MemoMapTypeId2];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId2] = MemoMapTypeId2;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer, scope5) {
    return pipe2(modifyEffect2(this.ref, (map23) => {
      const inMap = map23.get(layer);
      if (inMap !== void 0) {
        const [acquire, release] = inMap;
        const cached7 = pipe2(acquire, flatMap16(([patch17, b]) => pipe2(patchFiberRefs3(patch17), as4(b))), onExit4(exitMatch2({
          onFailure: /* @__PURE__ */ __name(() => void_3, "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => scopeAddFinalizerExit2(scope5, release), "onSuccess")
        })));
        return succeed7([cached7, map23]);
      }
      return pipe2(make64(0), flatMap16((observers) => pipe2(deferredMake2(), flatMap16((deferred) => pipe2(make64(() => void_3), map19((finalizerRef) => {
        const resource = uninterruptibleMask4((restore) => pipe2(scopeMake2(), flatMap16((innerScope) => pipe2(restore(flatMap16(makeBuilder2(layer, innerScope, true), (f) => diffFiberRefs3(f(this)))), exit4, flatMap16((exit7) => {
          switch (exit7._tag) {
            case OP_FAILURE2: {
              return pipe2(deferredFailCause2(deferred, exit7.effect_instruction_i0), zipRight3(scopeClose2(innerScope, exit7)), zipRight3(failCause5(exit7.effect_instruction_i0)));
            }
            case OP_SUCCESS2: {
              return pipe2(set10(finalizerRef, (exit8) => pipe2(scopeClose2(innerScope, exit8), whenEffect3(modify6(observers, (n) => [n === 1, n - 1])), asVoid4)), zipRight3(update6(observers, (n) => n + 1)), zipRight3(scopeAddFinalizerExit2(scope5, (exit8) => pipe2(sync5(() => map23.delete(layer)), zipRight3(get23(finalizerRef)), flatMap16((finalizer) => finalizer(exit8))))), zipRight3(deferredSucceed2(deferred, exit7.effect_instruction_i0)), as4(exit7.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe2(deferredAwait2(deferred), onExit4(exitMatchEffect2({
          onFailure: /* @__PURE__ */ __name(() => void_3, "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => update6(observers, (n) => n + 1), "onSuccess")
        }))), (exit7) => pipe2(get23(finalizerRef), flatMap16((finalizer) => finalizer(exit7)))];
        return [resource, isFresh2(layer) ? map23 : map23.set(layer, memoized)];
      }))))));
    }), flatten10);
  }
};
var makeMemoMap2 = /* @__PURE__ */ suspend5(() => map19(makeSynchronized2(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl2(ref)));
var unsafeMakeMemoMap2 = /* @__PURE__ */ __name(() => new MemoMapImpl2(unsafeMakeSynchronized2(/* @__PURE__ */ new Map())), "unsafeMakeMemoMap");
var buildWithScope2 = /* @__PURE__ */ dual2(2, (self, scope5) => flatMap16(makeMemoMap2, (memoMap) => buildWithMemoMap2(self, memoMap, scope5)));
var buildWithMemoMap2 = /* @__PURE__ */ dual2(3, (self, memoMap, scope5) => flatMap16(makeBuilder2(self, scope5), (run) => provideService3(run(memoMap), CurrentMemoMap2, memoMap)));
var makeBuilder2 = /* @__PURE__ */ __name((self, scope5, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync5(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
    }
    case "ExtendScope": {
      return sync5(() => (memoMap) => scopeWith3((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
    }
    case "Fold": {
      return sync5(() => (memoMap) => pipe2(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect4({
        onFailure: /* @__PURE__ */ __name((cause5) => memoMap.getOrElseMemoize(op.failureK(cause5), scope5), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((value) => memoMap.getOrElseMemoize(op.successK(value), scope5), "onSuccess")
      })));
    }
    case "Fresh": {
      return sync5(() => (_) => pipe2(op.layer, buildWithScope2(scope5)));
    }
    case "FromEffect": {
      return inMemoMap ? sync5(() => (_) => op.effect) : sync5(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Provide": {
      return sync5(() => (memoMap) => pipe2(memoMap.getOrElseMemoize(op.first, scope5), flatMap16((env) => pipe2(memoMap.getOrElseMemoize(op.second, scope5), provideContext3(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync5(() => (_) => scopeExtend2(op.effect, scope5)) : sync5(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Suspend": {
      return sync5(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
    }
    case "ProvideMerge": {
      return sync5(() => (memoMap) => pipe2(memoMap.getOrElseMemoize(op.first, scope5), zipWith5(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
    }
    case "ZipWith": {
      return gen3(function* () {
        const parallelScope = yield* scopeFork2(scope5, parallel5);
        const firstScope = yield* scopeFork2(parallelScope, sequential5);
        const secondScope = yield* scopeFork2(parallelScope, sequential5);
        return (memoMap) => pipe2(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions2(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {
          concurrent: true
        }));
      });
    }
    case "MergeAll": {
      const layers = op.layers;
      return map19(scopeFork2(scope5, parallel5), (parallelScope) => (memoMap) => {
        const contexts = new Array(layers.length);
        return map19(forEachConcurrentDiscard2(layers, fnUntraced3(function* (layer, i) {
          const scope6 = yield* scopeFork2(parallelScope, sequential5);
          const context7 = yield* memoMap.getOrElseMemoize(layer, scope6);
          contexts[i] = context7;
        }), false, false), () => mergeAll7(...contexts));
      });
    }
  }
}, "makeBuilder");
var context5 = /* @__PURE__ */ __name(() => fromEffectContext2(context4()), "context");
var fromEffect4 = /* @__PURE__ */ dual2(2, (a, b) => {
  const tagFirst = isTag4(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return fromEffectContext2(map19(effect, (service) => make43(tag, service)));
});
function fromEffectContext2(effect) {
  const fromEffect5 = Object.create(proto6);
  fromEffect5._op_layer = OP_FROM_EFFECT2;
  fromEffect5.effect = effect;
  return fromEffect5;
}
__name(fromEffectContext2, "fromEffectContext");
var mergeAll9 = /* @__PURE__ */ __name((...layers) => {
  const mergeAll11 = Object.create(proto6);
  mergeAll11._op_layer = OP_MERGE_ALL2;
  mergeAll11.layers = layers;
  return mergeAll11;
}, "mergeAll");
var scoped3 = /* @__PURE__ */ dual2(2, (a, b) => {
  const tagFirst = isTag4(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return scopedContext2(map19(effect, (service) => make43(tag, service)));
});
var scopedContext2 = /* @__PURE__ */ __name((effect) => {
  const scoped5 = Object.create(proto6);
  scoped5._op_layer = OP_SCOPED2;
  scoped5.effect = effect;
  return scoped5;
}, "scopedContext");
var succeed10 = /* @__PURE__ */ dual2(2, (a, b) => {
  const tagFirst = isTag4(a);
  const tag = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext2(succeed7(make43(tag, resource)));
});
var suspend7 = /* @__PURE__ */ __name((evaluate3) => {
  const suspend9 = Object.create(proto6);
  suspend9._op_layer = OP_SUSPEND2;
  suspend9.evaluate = evaluate3;
  return suspend9;
}, "suspend");
var sync7 = /* @__PURE__ */ dual2(2, (a, b) => {
  const tagFirst = isTag4(a);
  const tag = tagFirst ? a : b;
  const evaluate3 = tagFirst ? b : a;
  return fromEffectContext2(sync5(() => make43(tag, evaluate3())));
});
var provide3 = /* @__PURE__ */ dual2(2, (self, that) => suspend7(() => {
  const provideTo = Object.create(proto6);
  provideTo._op_layer = OP_PROVIDE2;
  provideTo.first = Object.create(proto6, {
    _op_layer: {
      value: OP_PROVIDE_MERGE2,
      enumerable: true
    },
    first: {
      value: context5(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll9(...that) : that
    },
    zipK: {
      value: /* @__PURE__ */ __name((a, b) => pipe2(a, merge9(b)), "value")
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideSomeLayer2 = /* @__PURE__ */ dual2(2, (self, layer) => scopedWith3((scope5) => flatMap16(buildWithScope2(layer, scope5), (context7) => provideSomeContext2(self, context7))));
var provideSomeRuntime2 = /* @__PURE__ */ dual2(2, (self, rt) => {
  const patchRefs = diff13(defaultRuntime2.fiberRefs, rt.fiberRefs);
  const patchFlags = diff11(defaultRuntime2.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask4((restore) => withFiberRuntime3((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext2);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch15(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch12(patchFlags)(oldFlags);
    const rollbackRefs = diff13(newRefs, oldRefs);
    const rollbackFlags = diff11(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring3(provideSomeContext2(restore(self), merge9(oldContext, rt.context)), withFiberRuntime3((fiber2) => {
      fiber2.setFiberRefs(patch15(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch12(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_3;
    }));
  }));
});
var effect_provide2 = /* @__PURE__ */ dual2(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer2(self, mergeAll9(...source));
  } else if (isLayer2(source)) {
    return provideSomeLayer2(self, source);
  } else if (isContext4(source)) {
    return provideSomeContext2(self, source);
  } else if (TypeId30 in source) {
    return flatMap16(source.runtimeEffect, (rt) => provideSomeRuntime2(self, rt));
  } else {
    return provideSomeRuntime2(self, source);
  }
});

// node_modules/effect/dist/esm/internal/console.js
var console4 = /* @__PURE__ */ map19(/* @__PURE__ */ fiberRefGet2(currentServices2), /* @__PURE__ */ get15(consoleTag2));
var consoleWith3 = /* @__PURE__ */ __name((f) => fiberRefGetWith2(currentServices2, (services) => f(get15(services, consoleTag2))), "consoleWith");
var withConsole3 = /* @__PURE__ */ dual2(2, (effect, value) => fiberRefLocallyWith2(effect, currentServices2, add7(consoleTag2, value)));
var withConsoleScoped3 = /* @__PURE__ */ __name((console6) => fiberRefLocallyScopedWith2(currentServices2, add7(consoleTag2, console6)), "withConsoleScoped");

// node_modules/effect/dist/esm/Random.js
var fixed4 = fixed3;

// node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey2 = "effect/Schedule";
var ScheduleTypeId2 = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey2);
var isSchedule2 = /* @__PURE__ */ __name((u) => hasProperty2(u, ScheduleTypeId2), "isSchedule");
var ScheduleDriverSymbolKey2 = "effect/ScheduleDriver";
var ScheduleDriverTypeId2 = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey2);
var defaultIterationMetadata2 = {
  start: 0,
  now: 0,
  input: void 0,
  output: void 0,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  recurrence: 0
};
var CurrentIterationMetadata2 = /* @__PURE__ */ Reference4()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: /* @__PURE__ */ __name(() => defaultIterationMetadata2, "defaultValue")
});
var scheduleVariance2 = {
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var scheduleDriverVariance2 = {
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var ScheduleImpl2 = class {
  static {
    __name(this, "ScheduleImpl");
  }
  initial;
  step;
  [ScheduleTypeId2] = scheduleVariance2;
  constructor(initial, step7) {
    this.initial = initial;
    this.step = step7;
  }
  pipe() {
    return pipeArguments2(this, arguments);
  }
};
var updateInfo2 = /* @__PURE__ */ __name((iterationMetaRef, now, input, output) => update6(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  start: now
} : {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis2(now - prev.start),
  elapsedSincePrevious: millis2(now - prev.now),
  start: prev.start
}), "updateInfo");
var ScheduleDriverImpl2 = class {
  static {
    __name(this, "ScheduleDriverImpl");
  }
  schedule;
  ref;
  [ScheduleDriverTypeId2] = scheduleDriverVariance2;
  constructor(schedule3, ref) {
    this.schedule = schedule3;
    this.ref = ref;
  }
  get state() {
    return map19(get23(this.ref), (tuple2) => tuple2[1]);
  }
  get last() {
    return flatMap16(get23(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync3(() => new NoSuchElementException2());
        }
        case "Some": {
          return succeed7(element.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake12(defaultIterationMetadata2);
  get reset() {
    return set10(this.ref, [none11(), this.schedule.initial]).pipe(zipLeft3(set10(this.iterationMeta, defaultIterationMetadata2)));
  }
  next(input) {
    return pipe2(map19(get23(this.ref), (tuple2) => tuple2[1]), flatMap16((state) => pipe2(currentTimeMillis4, flatMap16((now) => pipe2(suspend5(() => this.schedule.step(now, input, state)), flatMap16(([state2, out, decision]) => {
      const setState = set10(this.ref, [some6(out), state2]);
      if (isDone8(decision)) {
        return setState.pipe(zipRight3(fail6(none11())));
      }
      const millis3 = start4(decision.intervals) - now;
      if (millis3 <= 0) {
        return setState.pipe(zipRight3(updateInfo2(this.iterationMeta, now, input, out)), as4(out));
      }
      const duration = millis2(millis3);
      return pipe2(setState, zipRight3(updateInfo2(this.iterationMeta, now, input, out)), zipRight3(sleep7(duration)), as4(out));
    }))))));
  }
};
var makeWithState2 = /* @__PURE__ */ __name((initial, step7) => new ScheduleImpl2(initial, step7), "makeWithState");
var asVoid5 = /* @__PURE__ */ __name((self) => map21(self, constVoid2), "asVoid");
var check2 = /* @__PURE__ */ dual2(2, (self, test) => checkEffect2(self, (input, out) => sync5(() => test(input, out))));
var checkEffect2 = /* @__PURE__ */ dual2(2, (self, test) => makeWithState2(self.initial, (now, input, state) => flatMap16(self.step(now, input, state), ([state2, out, decision]) => {
  if (isDone8(decision)) {
    return succeed7([state2, out, done12]);
  }
  return map19(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done12]);
})));
var driver2 = /* @__PURE__ */ __name((self) => pipe2(make64([none11(), self.initial]), map19((ref) => new ScheduleDriverImpl2(self, ref))), "driver");
var intersect10 = /* @__PURE__ */ dual2(2, (self, that) => intersectWith2(self, that, intersect9));
var intersectWith2 = /* @__PURE__ */ dual2(3, (self, that, f) => makeWithState2([self.initial, that.initial], (now, input, state) => pipe2(zipWith5(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap16(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue4(lDecision) && isContinue4(rDecision)) {
    return intersectWithLoop2(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed7([[lState, rState], [out, out2], done12]);
}))));
var intersectWithLoop2 = /* @__PURE__ */ __name((self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty8(combined)) {
    return succeed7([[lState, rState], [out, out2], _continue4(combined)]);
  }
  if (pipe2(lInterval, lessThan11(rInterval))) {
    return flatMap16(self.step(end4(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone8(decision)) {
        return succeed7([[lState2, rState], [out3, out2], done12]);
      }
      return intersectWithLoop2(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap16(that.step(end4(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone8(decision)) {
      return succeed7([[lState, rState2], [out, out22], done12]);
    }
    return intersectWithLoop2(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
}, "intersectWithLoop");
var map21 = /* @__PURE__ */ dual2(2, (self, f) => mapEffect2(self, (out) => sync5(() => f(out))));
var mapEffect2 = /* @__PURE__ */ dual2(2, (self, f) => makeWithState2(self.initial, (now, input, state) => flatMap16(self.step(now, input, state), ([state2, out, decision]) => map19(f(out), (out2) => [state2, out2, decision]))));
var passthrough2 = /* @__PURE__ */ __name((self) => makeWithState2(self.initial, (now, input, state) => pipe2(self.step(now, input, state), map19(([state2, _, decision]) => [state2, input, decision]))), "passthrough");
var recurs2 = /* @__PURE__ */ __name((n) => whileOutput2(forever5, (out) => out < n), "recurs");
var unfold4 = /* @__PURE__ */ __name((initial, f) => makeWithState2(initial, (now, _, state) => sync5(() => [f(state), state, continueWith4(after4(now))])), "unfold");
var untilInputEffect2 = /* @__PURE__ */ dual2(2, (self, f) => checkEffect2(self, (input, _) => negate3(f(input))));
var whileInputEffect2 = /* @__PURE__ */ dual2(2, (self, f) => checkEffect2(self, (input, _) => f(input)));
var whileOutput2 = /* @__PURE__ */ dual2(2, (self, f) => check2(self, (_, out) => f(out)));
var ScheduleDefectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect2 = class {
  static {
    __name(this, "ScheduleDefect");
  }
  error;
  [ScheduleDefectTypeId2];
  constructor(error) {
    this.error = error;
    this[ScheduleDefectTypeId2] = ScheduleDefectTypeId2;
  }
};
var isScheduleDefect2 = /* @__PURE__ */ __name((u) => hasProperty2(u, ScheduleDefectTypeId2), "isScheduleDefect");
var scheduleDefectWrap2 = /* @__PURE__ */ __name((self) => catchAll3(self, (e) => die5(new ScheduleDefect2(e))), "scheduleDefectWrap");
var scheduleDefectRefailCause2 = /* @__PURE__ */ __name((cause5) => match11(find2(cause5, (_) => isDieType2(_) && isScheduleDefect2(_.defect) ? some6(_.defect) : none11()), {
  onNone: /* @__PURE__ */ __name(() => cause5, "onNone"),
  onSome: /* @__PURE__ */ __name((error) => fail5(error.error), "onSome")
}), "scheduleDefectRefailCause");
var scheduleDefectRefail2 = /* @__PURE__ */ __name((effect) => catchAllCause3(effect, (cause5) => failCause5(scheduleDefectRefailCause2(cause5))), "scheduleDefectRefail");
var repeat_Effect2 = /* @__PURE__ */ dual2(2, (self, schedule3) => repeatOrElse_Effect2(self, schedule3, (e, _) => fail6(e)));
var repeat_combined2 = /* @__PURE__ */ dual2(2, (self, options) => {
  if (isSchedule2(options)) {
    return repeat_Effect2(self, options);
  }
  const base = options.schedule ?? passthrough2(forever5);
  const withWhile = options.while ? whileInputEffect2(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed7(applied);
    }
    return scheduleDefectWrap2(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect2(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed7(applied);
    }
    return scheduleDefectWrap2(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect10(withUntil, recurs2(options.times)).pipe(map21((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail2(repeat_Effect2(self, withTimes));
});
var repeatOrElse_Effect2 = /* @__PURE__ */ dual2(3, (self, schedule3, orElse5) => flatMap16(driver2(schedule3), (driver3) => matchEffect3(self, {
  onFailure: /* @__PURE__ */ __name((error) => orElse5(error, none11()), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((value) => repeatOrElseEffectLoop2(provideServiceEffect3(self, CurrentIterationMetadata2, get23(driver3.iterationMeta)), driver3, (error, option5) => provideServiceEffect3(orElse5(error, option5), CurrentIterationMetadata2, get23(driver3.iterationMeta)), value), "onSuccess")
})));
var repeatOrElseEffectLoop2 = /* @__PURE__ */ __name((self, driver3, orElse5, value) => matchEffect3(driver3.next(value), {
  onFailure: /* @__PURE__ */ __name(() => orDie3(driver3.last), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((b) => matchEffect3(self, {
    onFailure: /* @__PURE__ */ __name((error) => orElse5(error, some6(b)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value2) => repeatOrElseEffectLoop2(self, driver3, orElse5, value2), "onSuccess")
  }), "onSuccess")
}), "repeatOrElseEffectLoop");
var retry_Effect2 = /* @__PURE__ */ dual2(2, (self, policy) => retryOrElse_Effect2(self, policy, (e, _) => fail6(e)));
var retry_combined2 = /* @__PURE__ */ dual2(2, (self, options) => {
  if (isSchedule2(options)) {
    return retry_Effect2(self, options);
  }
  return scheduleDefectRefail2(retry_Effect2(self, fromRetryOptions2(options)));
});
var fromRetryOptions2 = /* @__PURE__ */ __name((options) => {
  const base = options.schedule ?? forever5;
  const withWhile = options.while ? whileInputEffect2(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed7(applied);
    }
    return scheduleDefectWrap2(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect2(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed7(applied);
    }
    return scheduleDefectWrap2(applied);
  }) : withWhile;
  return options.times ? intersect10(withUntil, recurs2(options.times)) : withUntil;
}, "fromRetryOptions");
var retryOrElse_Effect2 = /* @__PURE__ */ dual2(3, (self, policy, orElse5) => flatMap16(driver2(policy), (driver3) => retryOrElse_EffectLoop2(provideServiceEffect3(self, CurrentIterationMetadata2, get23(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect3(orElse5(e, out), CurrentIterationMetadata2, get23(driver3.iterationMeta)))));
var retryOrElse_EffectLoop2 = /* @__PURE__ */ __name((self, driver3, orElse5) => {
  return catchAll3(self, (e) => matchEffect3(driver3.next(e), {
    onFailure: /* @__PURE__ */ __name(() => pipe2(driver3.last, orDie3, flatMap16((out) => orElse5(e, out))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => retryOrElse_EffectLoop2(self, driver3, orElse5), "onSuccess")
  }));
}, "retryOrElse_EffectLoop");
var schedule_Effect2 = /* @__PURE__ */ dual2(2, (self, schedule3) => scheduleFrom_Effect2(self, void 0, schedule3));
var scheduleFrom_Effect2 = /* @__PURE__ */ dual2(3, (self, initial, schedule3) => flatMap16(driver2(schedule3), (driver3) => scheduleFrom_EffectLoop2(provideServiceEffect3(self, CurrentIterationMetadata2, get23(driver3.iterationMeta)), initial, driver3)));
var scheduleFrom_EffectLoop2 = /* @__PURE__ */ __name((self, initial, driver3) => matchEffect3(driver3.next(initial), {
  onFailure: /* @__PURE__ */ __name(() => orDie3(driver3.last), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => flatMap16(self, (a) => scheduleFrom_EffectLoop2(self, a, driver3)), "onSuccess")
}), "scheduleFrom_EffectLoop");
var forever5 = /* @__PURE__ */ unfold4(0, (n) => n + 1);
var once5 = /* @__PURE__ */ asVoid5(/* @__PURE__ */ recurs2(1));
var scheduleForked3 = /* @__PURE__ */ dual2(2, (self, schedule3) => forkScoped3(schedule_Effect2(self, schedule3)));

// node_modules/effect/dist/esm/internal/executionPlan.js
var withExecutionPlan3 = /* @__PURE__ */ dual2(2, (effect, plan) => suspend5(() => {
  let i = 0;
  let result;
  return flatMap16(whileLoop4({
    while: /* @__PURE__ */ __name(() => i < plan.steps.length && (result === void 0 || isLeft4(result)), "while"),
    body: /* @__PURE__ */ __name(() => {
      const step7 = plan.steps[i];
      let nextEffect = effect_provide2(effect, step7.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend5(() => {
          if (attempted) return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail2(retry_Effect2(nextEffect, scheduleFromStep2(step7, false)));
      } else {
        const schedule3 = scheduleFromStep2(step7, true);
        nextEffect = schedule3 ? scheduleDefectRefail2(retry_Effect2(nextEffect, schedule3)) : nextEffect;
      }
      return either5(nextEffect);
    }, "body"),
    step: /* @__PURE__ */ __name((either7) => {
      result = either7;
      i++;
    }, "step")
  }), () => result);
}));
var scheduleFromStep2 = /* @__PURE__ */ __name((step7, first3) => {
  if (!first3) {
    return fromRetryOptions2({
      schedule: step7.schedule ? step7.schedule : step7.attempts ? void 0 : once5,
      times: step7.attempts,
      while: step7.while
    });
  } else if (step7.attempts === 1 || !(step7.schedule || step7.attempts)) {
    return void 0;
  }
  return fromRetryOptions2({
    schedule: step7.schedule,
    while: step7.while,
    times: step7.attempts ? step7.attempts - 1 : void 0
  });
}, "scheduleFromStep");

// node_modules/effect/dist/esm/internal/query.js
var currentCache2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake2(unsafeMakeWith2(65536, () => map19(deferredMake2(), (handle) => ({
  listeners: new Listeners2(),
  handle
})), () => seconds2(60))));
var currentCacheEnabled2 = /* @__PURE__ */ globalValue2(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake2(false));
var fromRequest2 = /* @__PURE__ */ __name((request3, dataSource) => flatMap16(isEffect3(dataSource) ? dataSource : succeed7(dataSource), (ds) => fiberIdWith3((id) => {
  const proxy = new Proxy(request3, {});
  return fiberRefGetWith2(currentCacheEnabled2, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached7 = fiberRefGetWith2(currentCache2, (cache) => flatMap16(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap16(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached7);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask4((restore) => flatMap16(exit4(blocked3(empty43, restore(deferredAwait2(orNew.left.handle)))), (exit7) => {
              orNew.left.listeners.decrement();
              return exit7;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask4((restore) => flatMap16(exit4(blocked3(single2(ds, makeEntry2({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id,
              state: {
                completed: false
              }
            })), restore(deferredAwait2(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait2(orNew.right.handle);
            }));
          }
        }
      }));
      return cached7;
    }
    const listeners = new Listeners2();
    listeners.increment();
    return flatMap16(deferredMake2(), (ref) => ensuring3(blocked3(single2(ds, makeEntry2({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id,
      state: {
        completed: false
      }
    })), deferredAwait2(ref)), sync5(() => listeners.decrement())));
  });
})), "fromRequest");
var cacheRequest2 = /* @__PURE__ */ __name((request3, result) => {
  return fiberRefGetWith2(currentCacheEnabled2, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith2(currentCache2, (cache) => flatMap16(cache.getEither(request3), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_3;
          }
          case "Right": {
            return deferredComplete2(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_3;
  });
}, "cacheRequest");
var withRequestCaching3 = /* @__PURE__ */ dual2(2, (self, strategy) => fiberRefLocally2(self, currentCacheEnabled2, strategy));
var withRequestCache3 = /* @__PURE__ */ dual2(
  2,
  // @ts-expect-error
  (self, cache) => fiberRefLocally2(self, currentCache2, cache)
);

// node_modules/effect/dist/esm/Request.js
var isRequest4 = isRequest3;

// node_modules/effect/dist/esm/Effect.js
var EffectTypeId6 = EffectTypeId5;
var isEffect4 = isEffect3;
var cachedWithTTL2 = cached5;
var cachedInvalidateWithTTL4 = cachedInvalidateWithTTL3;
var cached6 = memoize2;
var cachedFunction4 = cachedFunction3;
var once6 = once4;
var all6 = all5;
var allWith4 = allWith3;
var allSuccesses4 = allSuccesses3;
var dropUntil4 = dropUntil3;
var dropWhile4 = dropWhile3;
var takeUntil4 = takeUntil3;
var takeWhile4 = takeWhile3;
var every10 = every9;
var exists4 = exists3;
var filter10 = filter9;
var filterMap8 = filterMap7;
var findFirst10 = findFirst8;
var forEach16 = forEach15;
var head8 = head7;
var mergeAll10 = mergeAll8;
var partition8 = partition7;
var reduce20 = reduce18;
var reduceWhile4 = reduceWhile3;
var reduceRight6 = reduceRight5;
var reduceEffect4 = reduceEffect3;
var replicate4 = replicate3;
var replicateEffect4 = replicateEffect3;
var validateAll4 = validateAll3;
var validateFirst4 = validateFirst3;
var async4 = async_2;
var asyncEffect4 = asyncEffect3;
var custom4 = custom3;
var withFiberRuntime4 = withFiberRuntime3;
var fail8 = fail6;
var failSync4 = failSync3;
var failCause8 = failCause5;
var failCauseSync4 = failCauseSync3;
var die6 = die5;
var dieMessage4 = dieMessage3;
var dieSync4 = dieSync3;
var gen4 = gen3;
var never4 = never3;
var none18 = none15;
var promise4 = promise3;
var succeed12 = succeed7;
var succeedNone4 = succeedNone3;
var succeedSome4 = succeedSome3;
var suspend8 = suspend5;
var sync8 = sync5;
var _void2 = void_3;
var yieldNow8 = yieldNow5;
var _catch4 = _catch3;
var catchAll4 = catchAll3;
var catchAllCause4 = catchAllCause3;
var catchAllDefect4 = catchAllDefect3;
var catchIf4 = catchIf3;
var catchSome4 = catchSome3;
var catchSomeCause4 = catchSomeCause3;
var catchSomeDefect4 = catchSomeDefect3;
var catchTag4 = catchTag3;
var catchTags4 = catchTags3;
var cause4 = cause3;
var eventually4 = eventually3;
var ignore4 = ignore3;
var ignoreLogged4 = ignoreLogged3;
var parallelErrors4 = parallelErrors3;
var sandbox4 = sandbox3;
var retry2 = retry_combined2;
var withExecutionPlan4 = withExecutionPlan3;
var retryOrElse2 = retryOrElse_Effect2;
var try_4 = try_3;
var tryMap4 = tryMap3;
var tryMapPromise4 = tryMapPromise3;
var tryPromise4 = tryPromise3;
var unsandbox4 = unsandbox3;
var allowInterrupt4 = allowInterrupt3;
var checkInterruptible4 = checkInterruptible3;
var disconnect4 = disconnect3;
var interrupt8 = interrupt6;
var interruptWith4 = interruptWith3;
var interruptible8 = interruptible6;
var interruptibleMask4 = interruptibleMask3;
var onInterrupt4 = onInterrupt3;
var uninterruptible4 = uninterruptible3;
var uninterruptibleMask6 = uninterruptibleMask4;
var liftPredicate4 = liftPredicate3;
var as6 = as4;
var asSome4 = asSome3;
var asSomeError4 = asSomeError3;
var asVoid6 = asVoid4;
var flip4 = flip3;
var flipWith4 = flipWith3;
var map22 = map19;
var mapAccum6 = mapAccum5;
var mapBoth4 = mapBoth3;
var mapError4 = mapError3;
var mapErrorCause4 = mapErrorCause3;
var merge12 = merge11;
var negate4 = negate3;
var acquireRelease4 = acquireRelease3;
var acquireReleaseInterruptible4 = acquireReleaseInterruptible3;
var acquireUseRelease4 = acquireUseRelease3;
var addFinalizer4 = addFinalizer3;
var ensuring4 = ensuring3;
var onError4 = onError3;
var onExit6 = onExit4;
var parallelFinalizers4 = parallelFinalizers3;
var sequentialFinalizers4 = sequentialFinalizers3;
var finalizersMask4 = finalizersMask3;
var scope4 = scope3;
var scopeWith4 = scopeWith3;
var scopedWith4 = scopedWith3;
var scoped4 = scopedEffect2;
var using4 = using3;
var withEarlyRelease4 = withEarlyRelease3;
var awaitAllChildren4 = awaitAllChildren3;
var daemonChildren4 = daemonChildren3;
var descriptor4 = descriptor3;
var descriptorWith4 = descriptorWith3;
var diffFiberRefs4 = diffFiberRefs3;
var ensuringChild4 = ensuringChild3;
var ensuringChildren4 = ensuringChildren3;
var fiberId4 = fiberId3;
var fiberIdWith4 = fiberIdWith3;
var fork6 = fork4;
var forkDaemon4 = forkDaemon3;
var forkAll4 = forkAll3;
var forkIn4 = forkIn3;
var forkScoped4 = forkScoped3;
var forkWithErrorHandler4 = forkWithErrorHandler3;
var fromFiber4 = fromFiber3;
var fromFiberEffect4 = fromFiberEffect3;
var supervised4 = supervised3;
var transplant4 = transplant3;
var withConcurrency4 = withConcurrency3;
var withScheduler4 = withScheduler3;
var withSchedulingPriority4 = withSchedulingPriority3;
var withMaxOpsBeforeYield4 = withMaxOpsBeforeYield3;
var clock4 = clock3;
var clockWith8 = clockWith7;
var withClockScoped4 = withClockScoped3;
var withClock4 = withClock3;
var console5 = console4;
var consoleWith4 = consoleWith3;
var withConsoleScoped4 = withConsoleScoped3;
var withConsole4 = withConsole3;
var delay4 = delay3;
var sleep8 = sleep7;
var timed4 = timed3;
var timedWith4 = timedWith3;
var timeout4 = timeout3;
var timeoutOption4 = timeoutOption3;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var configProviderWith4 = configProviderWith3;
var withConfigProvider4 = withConfigProvider3;
var withConfigProviderScoped4 = withConfigProviderScoped3;
var context6 = context4;
var contextWith4 = contextWith3;
var contextWithEffect4 = contextWithEffect3;
var mapInputContext4 = mapInputContext3;
var provide4 = effect_provide2;
var provideService4 = provideService3;
var provideServiceEffect4 = provideServiceEffect3;
var serviceFunction4 = serviceFunction3;
var serviceFunctionEffect4 = serviceFunctionEffect3;
var serviceFunctions4 = serviceFunctions3;
var serviceConstants4 = serviceConstants3;
var serviceMembers4 = serviceMembers3;
var serviceOption4 = serviceOption3;
var serviceOptional4 = serviceOptional3;
var updateService4 = updateService3;
var Do4 = Do3;
var bind6 = bind5;
var bindAll4 = bindAll3;
var bindTo6 = bindTo5;
var let_6 = let_5;
var option4 = option3;
var either6 = either5;
var exit6 = exit4;
var intoDeferred4 = intoDeferred3;
var if_4 = if_3;
var filterOrDie4 = filterOrDie3;
var filterOrDieMessage4 = filterOrDieMessage3;
var filterOrElse4 = filterOrElse3;
var filterOrFail4 = filterOrFail3;
var filterEffectOrElse4 = filterEffectOrElse3;
var filterEffectOrFail4 = filterEffectOrFail3;
var unless4 = unless3;
var unlessEffect4 = unlessEffect3;
var when4 = when3;
var whenEffect4 = whenEffect3;
var whenFiberRef4 = whenFiberRef3;
var whenRef4 = whenRef3;
var flatMap18 = flatMap16;
var andThen6 = andThen5;
var flatten12 = flatten10;
var race4 = race3;
var raceAll4 = raceAll3;
var raceFirst4 = raceFirst3;
var raceWith4 = raceWith3;
var summarized4 = summarized3;
var tap4 = tap3;
var tapBoth4 = tapBoth3;
var tapDefect4 = tapDefect3;
var tapError4 = tapError3;
var tapErrorTag4 = tapErrorTag3;
var tapErrorCause4 = tapErrorCause3;
var forever6 = forever4;
var iterate4 = iterate3;
var loop4 = loop3;
var repeat2 = repeat_combined2;
var repeatN4 = repeatN3;
var repeatOrElse2 = repeatOrElse_Effect2;
var schedule2 = schedule_Effect2;
var scheduleForked4 = scheduleForked3;
var scheduleFrom2 = scheduleFrom_Effect2;
var whileLoop6 = whileLoop4;
var getFiberRefs2 = fiberRefs4;
var inheritFiberRefs4 = inheritFiberRefs3;
var locally2 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var locallyScopedWith2 = fiberRefLocallyScopedWith2;
var patchFiberRefs4 = patchFiberRefs3;
var setFiberRefs4 = setFiberRefs3;
var updateFiberRefs4 = updateFiberRefs3;
var isFailure4 = isFailure3;
var isSuccess4 = isSuccess3;
var match18 = match15;
var matchCause6 = matchCause4;
var matchCauseEffect6 = matchCauseEffect4;
var matchEffect4 = matchEffect3;
var log4 = log3;
var logWithLevel4 = /* @__PURE__ */ __name((level, ...message) => logWithLevel3(level)(...message), "logWithLevel");
var logTrace4 = logTrace3;
var logDebug4 = logDebug3;
var logInfo4 = logInfo3;
var logWarning4 = logWarning3;
var logError4 = logError3;
var logFatal4 = logFatal3;
var withLogSpan4 = withLogSpan3;
var annotateLogs4 = annotateLogs3;
var annotateLogsScoped4 = annotateLogsScoped3;
var logAnnotations4 = logAnnotations3;
var withUnhandledErrorLogLevel4 = withUnhandledErrorLogLevel3;
var whenLogLevel4 = whenLogLevel3;
var orDie4 = orDie3;
var orDieWith4 = orDieWith3;
var orElse4 = orElse3;
var orElseFail4 = orElseFail3;
var orElseSucceed4 = orElseSucceed3;
var firstSuccessOf4 = firstSuccessOf3;
var random6 = random5;
var randomWith4 = randomWith3;
var withRandom4 = withRandom3;
var withRandomFixed2 = /* @__PURE__ */ dual2(2, (effect, values5) => withRandom4(effect, fixed4(values5)));
var withRandomScoped4 = withRandomScoped3;
var runtime6 = runtime5;
var getRuntimeFlags2 = runtimeFlags2;
var patchRuntimeFlags2 = updateRuntimeFlags2;
var withRuntimeFlagsPatch2 = withRuntimeFlags2;
var withRuntimeFlagsPatchScoped2 = withRuntimeFlagsScoped2;
var tagMetrics4 = tagMetrics3;
var labelMetrics4 = labelMetrics3;
var tagMetricsScoped4 = tagMetricsScoped3;
var labelMetricsScoped4 = labelMetricsScoped3;
var metricLabels4 = metricLabels3;
var withMetric4 = withMetric3;
var unsafeMakeSemaphore4 = unsafeMakeSemaphore3;
var makeSemaphore4 = makeSemaphore3;
var unsafeMakeLatch4 = unsafeMakeLatch3;
var makeLatch4 = makeLatch3;
var runFork4 = unsafeForkEffect2;
var runCallback2 = unsafeRunEffect2;
var runPromise2 = unsafeRunPromiseEffect2;
var runPromiseExit2 = unsafeRunPromiseExitEffect2;
var runSync2 = unsafeRunSyncEffect2;
var runSyncExit2 = unsafeRunSyncExitEffect2;
var validate4 = validate3;
var validateWith4 = validateWith3;
var zip8 = zipOptions2;
var zipLeft4 = zipLeftOptions2;
var zipRight4 = zipRightOptions2;
var zipWith6 = zipWithOptions2;
var ap2 = /* @__PURE__ */ dual2(2, (self, that) => zipWith6(self, that, (f, a) => f(a)));
var blocked4 = blocked3;
var runRequestBlock4 = runRequestBlock3;
var step6 = step5;
var request2 = /* @__PURE__ */ dual2((args3) => isRequest4(args3[0]), fromRequest2);
var cacheRequestResult2 = cacheRequest2;
var withRequestBatching4 = withRequestBatching3;
var withRequestCaching4 = withRequestCaching3;
var withRequestCache4 = withRequestCache3;
var tracer4 = tracer3;
var tracerWith8 = tracerWith5;
var withTracer4 = withTracer3;
var withTracerScoped4 = withTracerScoped3;
var withTracerEnabled4 = withTracerEnabled3;
var withTracerTiming4 = withTracerTiming3;
var annotateSpans4 = annotateSpans3;
var annotateCurrentSpan4 = annotateCurrentSpan3;
var currentSpan4 = currentSpan3;
var currentParentSpan4 = currentParentSpan3;
var spanAnnotations4 = spanAnnotations3;
var spanLinks4 = spanLinks3;
var linkSpans4 = linkSpans3;
var linkSpanCurrent4 = linkSpanCurrent3;
var makeSpan4 = makeSpan3;
var makeSpanScoped4 = makeSpanScoped3;
var useSpan4 = useSpan3;
var withSpan4 = withSpan3;
var functionWithSpan4 = functionWithSpan3;
var withSpanScoped4 = withSpanScoped3;
var withParentSpan4 = withParentSpan3;
var fromNullable6 = fromNullable5;
var optionFromOptional4 = optionFromOptional3;
var transposeOption2 = /* @__PURE__ */ __name((self) => {
  return isNone4(self) ? succeedNone4 : map22(self.value, some5);
}, "transposeOption");
var transposeMapOption2 = /* @__PURE__ */ dual2(2, (self, f) => isNone4(self) ? succeedNone4 : map22(f(self.value), some5));
var makeTagProxy2 = /* @__PURE__ */ __name((TagClass) => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn3 = /* @__PURE__ */ __name((...args3) => andThen5(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args4) => andThen5(target, (s2) => s2[prop](...args4)));
          return s[prop](...args3);
        }
        cache.set(prop, andThen5(target, (s2) => s2[prop]));
        return s[prop];
      }), "fn");
      const cn = andThen5(target, (s) => s[prop]);
      Object.assign(fn3, cn);
      const apply = fn3.apply;
      const bind7 = fn3.bind;
      const call = fn3.call;
      const proto7 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
      proto7.apply = apply;
      proto7.bind = bind7;
      proto7.call = call;
      Object.setPrototypeOf(fn3, proto7);
      cache.set(prop, fn3);
      return fn3;
    }
  });
}, "makeTagProxy");
var Tag4 = /* @__PURE__ */ __name((id) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  __name(TagClass, "TagClass");
  Object.setPrototypeOf(TagClass, TagProto2);
  TagClass.key = id;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen5(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy2(TagClass);
}, "Tag");
var Service2 = /* @__PURE__ */ __name(function() {
  return function() {
    const [id, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = /* @__PURE__ */ __name(function(service) {
      if (patchState === "unchecked") {
        const proto7 = Object.getPrototypeOf(service);
        if (proto7 === Object.prototype || proto7 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto7);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service, Object.getPrototypeOf(this));
        return service;
      }
    }, "TagClass");
    TagClass.prototype._tag = id;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service) => new this(service);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen5(this, body);
      }
    });
    TagClass.key = id;
    Object.assign(TagClass, TagProto2);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction5 = false;
    if ("effect" in maker) {
      isFunction5 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction5) {
            return function() {
              return fromEffect4(TagClass, map22(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect4(TagClass, map22(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction5 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction5) {
            return function() {
              return scoped3(TagClass, map22(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped3(TagClass, map22(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync7(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed10(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction5) {
            return function() {
              return provide3(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide3(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy2(TagClass) : TagClass;
  };
}, "Service");
var fn2 = /* @__PURE__ */ __name(function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength2(nameOrBody.length, function(...args3) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply2({
        self: this,
        body: nameOrBody,
        args: args3,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation2.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength2(body.length, {
    [name](...args3) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply2({
        self: this,
        body,
        args: args3,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
}, "fn");
function defineLength2(length3, fn3) {
  return Object.defineProperty(fn3, "length", {
    value: length3,
    configurable: true
  });
}
__name(defineLength2, "defineLength");
function fnApply2(options) {
  let effect;
  let fnError = void 0;
  if (isGeneratorFunction2(options.body)) {
    effect = fromIterator2(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect = options.body.apply(options.self, options.args);
    } catch (error) {
      fnError = error;
      effect = die6(error);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect = x(effect, ...options.args);
      }
    } catch (error) {
      effect = fnError ? failCause8(sequential4(die4(fnError), die4(error))) : die6(error);
    }
  }
  let cache = false;
  const captureStackTrace = /* @__PURE__ */ __name(() => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split("\n");
      const stackCall = options.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  }, "captureStackTrace");
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan4(effect, options.spanName, opts);
}
__name(fnApply2, "fnApply");
var fnUntraced4 = fnUntraced3;
var ensureSuccessType2 = /* @__PURE__ */ __name(() => (effect) => effect, "ensureSuccessType");
var ensureErrorType2 = /* @__PURE__ */ __name(() => (effect) => effect, "ensureErrorType");
var ensureRequirementsType2 = /* @__PURE__ */ __name(() => (effect) => effect, "ensureRequirementsType");

// node_modules/hono/dist/compose.js
var compose = /* @__PURE__ */ __name((middleware, onError5, onNotFound) => {
  return (context7, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context7.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context7, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError5) {
            context7.error = err;
            res = await onError5(err, context7);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context7.finalized === false && onNotFound) {
          res = await onNotFound(context7);
        }
      }
      if (res && (context7.finalized === false || isError)) {
        context7.res = res;
      }
      return context7;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = /* @__PURE__ */ Symbol();

// node_modules/hono/dist/utils/body.js
var parseBody = /* @__PURE__ */ __name(async (request3, options = /* @__PURE__ */ Object.create(null)) => {
  const { all: all7 = false, dot = false } = options;
  const headers = request3 instanceof HonoRequest ? request3.raw.headers : request3.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request3, { all: all7, dot });
  }
  return {};
}, "parseBody");
async function parseFormData(request3, options) {
  const formData = await request3.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
__name(parseFormData, "parseFormData");
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
__name(convertFormDataToBodyData, "convertFormDataToBodyData");
var handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {
  if (form[key] !== void 0) {
    if (Array.isArray(form[key])) {
      ;
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
}, "handleParsingAllValues");
var handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {
  let nestedForm = form;
  const keys9 = key.split(".");
  keys9.forEach((key2, index) => {
    if (index === keys9.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
}, "handleParsingNestedValues");

// node_modules/hono/dist/utils/url.js
var splitPath = /* @__PURE__ */ __name((path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
}, "splitPath");
var splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
}, "splitRoutingPath");
var extractGroupsFromPath = /* @__PURE__ */ __name((path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match20, index) => {
    const mark = `@${index}`;
    groups.push([mark, match20]);
    return mark;
  });
  return { groups, path };
}, "extractGroupsFromPath");
var replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
}, "replaceGroupMarks");
var patternCache = {};
var getPattern = /* @__PURE__ */ __name((label, next) => {
  if (label === "*") {
    return "*";
  }
  const match20 = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match20) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match20[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match20[1], new RegExp(`^${match20[2]}(?=/${next})`)] : [label, match20[1], new RegExp(`^${match20[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match20[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
}, "getPattern");
var tryDecode = /* @__PURE__ */ __name((str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match20) => {
      try {
        return decoder(match20);
      } catch {
        return match20;
      }
    });
  }
}, "tryDecode");
var tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
var getPath = /* @__PURE__ */ __name((request3) => {
  const url = request3.url;
  const start5 = url.indexOf("/", url.indexOf(":") + 4);
  let i = start5;
  for (; i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start5, queryIndex === -1 ? void 0 : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start5, i);
}, "getPath");
var getPathNoStrict = /* @__PURE__ */ __name((request3) => {
  const result = getPath(request3);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
}, "getPathNoStrict");
var mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
}, "mergePath");
var checkOptionalParameter = /* @__PURE__ */ __name((path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
}, "checkOptionalParameter");
var _decodeURI = /* @__PURE__ */ __name((value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
}, "_decodeURI");
var _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf("?", 8);
    if (keyIndex2 === -1) {
      return void 0;
    }
    if (!url.startsWith(key, keyIndex2 + 1)) {
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
}, "_getQueryParam");
var getQueryParam = _getQueryParam;
var getQueryParams = /* @__PURE__ */ __name((url, key) => {
  return _getQueryParam(url, key, true);
}, "getQueryParams");
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
var HonoRequest = class {
  static {
    __name(this, "HonoRequest");
  }
  /**
   * `.raw` can get the raw Request object.
   *
   * @see {@link https://hono.dev/docs/api/request#raw}
   *
   * @example
   * ```ts
   * // For Cloudflare Workers
   * app.post('/', async (c) => {
   *   const metadata = c.req.raw.cf?.hostMetadata?
   *   ...
   * })
   * ```
   */
  raw;
  #validatedData;
  // Short name of validatedData
  #matchResult;
  routeIndex = 0;
  /**
   * `.path` can get the pathname of the request.
   *
   * @see {@link https://hono.dev/docs/api/request#path}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const pathname = c.req.path // `/about/me`
   * })
   * ```
   */
  path;
  bodyCache = {};
  constructor(request3, path = "/", matchResult = [[]]) {
    this.raw = request3;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys9 = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys9) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value !== void 0) {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = /* @__PURE__ */ __name((key) => {
    const { bodyCache, raw: raw2 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw2[key]();
  }, "#cachedBody");
  /**
   * `.json()` can parse Request body of type `application/json`
   *
   * @see {@link https://hono.dev/docs/api/request#json}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.json()
   * })
   * ```
   */
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  /**
   * `.text()` can parse Request body of type `text/plain`
   *
   * @see {@link https://hono.dev/docs/api/request#text}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.text()
   * })
   * ```
   */
  text() {
    return this.#cachedBody("text");
  }
  /**
   * `.arrayBuffer()` parse Request body as an `ArrayBuffer`
   *
   * @see {@link https://hono.dev/docs/api/request#arraybuffer}
   *
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.arrayBuffer()
   * })
   * ```
   */
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  /**
   * Parses the request body as a `Blob`.
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.blob();
   * });
   * ```
   * @see https://hono.dev/docs/api/request#blob
   */
  blob() {
    return this.#cachedBody("blob");
  }
  /**
   * Parses the request body as `FormData`.
   * @example
   * ```ts
   * app.post('/entry', async (c) => {
   *   const body = await c.req.formData();
   * });
   * ```
   * @see https://hono.dev/docs/api/request#formdata
   */
  formData() {
    return this.#cachedBody("formData");
  }
  /**
   * Adds validated data to the request.
   *
   * @param target - The target of the validation.
   * @param data - The validated data to add.
   */
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  /**
   * `.url()` can get the request url strings.
   *
   * @see {@link https://hono.dev/docs/api/request#url}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const url = c.req.url // `http://localhost:8787/about/me`
   *   ...
   * })
   * ```
   */
  get url() {
    return this.raw.url;
  }
  /**
   * `.method()` can get the method name of the request.
   *
   * @see {@link https://hono.dev/docs/api/request#method}
   *
   * @example
   * ```ts
   * app.get('/about/me', (c) => {
   *   const method = c.req.method // `GET`
   * })
   * ```
   */
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  /**
   * `.matchedRoutes()` can return a matched route in the handler
   *
   * @deprecated
   *
   * Use matchedRoutes helper defined in "hono/route" instead.
   *
   * @see {@link https://hono.dev/docs/api/request#matchedroutes}
   *
   * @example
   * ```ts
   * app.use('*', async function logger(c, next) {
   *   await next()
   *   c.req.matchedRoutes.forEach(({ handler, method, path }, i) => {
   *     const name = handler.name || (handler.length < 2 ? '[handler]' : '[middleware]')
   *     console.log(
   *       method,
   *       ' ',
   *       path,
   *       ' '.repeat(Math.max(10 - path.length, 0)),
   *       name,
   *       i === c.req.routeIndex ? '<- respond from here' : ''
   *     )
   *   })
   * })
   * ```
   */
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  /**
   * `routePath()` can retrieve the path registered within the handler
   *
   * @deprecated
   *
   * Use routePath helper defined in "hono/route" instead.
   *
   * @see {@link https://hono.dev/docs/api/request#routepath}
   *
   * @example
   * ```ts
   * app.get('/posts/:id', (c) => {
   *   return c.json({ path: c.req.routePath })
   * })
   * ```
   */
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = /* @__PURE__ */ __name((value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
}, "raw");
var resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context7, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context: context7 }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context7, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
}, "resolveCallback");

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
}, "setDefaultContentType");
var Context = class {
  static {
    __name(this, "Context");
  }
  #rawRequest;
  #req;
  /**
   * `.env` can get bindings (environment variables, secrets, KV namespaces, D1 database, R2 bucket etc.) in Cloudflare Workers.
   *
   * @see {@link https://hono.dev/docs/api/context#env}
   *
   * @example
   * ```ts
   * // Environment object for Cloudflare Workers
   * app.get('*', async c => {
   *   const counter = c.env.COUNTER
   * })
   * ```
   */
  env = {};
  #var;
  finalized = false;
  /**
   * `.error` can get the error object from the middleware if the Handler throws an error.
   *
   * @see {@link https://hono.dev/docs/api/context#error}
   *
   * @example
   * ```ts
   * app.use('*', async (c, next) => {
   *   await next()
   *   if (c.error) {
   *     // do something...
   *   }
   * })
   * ```
   */
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  /**
   * Creates an instance of the Context class.
   *
   * @param req - The Request object.
   * @param options - Optional configuration options for the context.
   */
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  /**
   * `.req` is the instance of {@link HonoRequest}.
   */
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#event}
   * The FetchEvent associated with the current request.
   *
   * @throws Will throw an error if the context does not have a FetchEvent.
   */
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#executionctx}
   * The ExecutionContext associated with the current request.
   *
   * @throws Will throw an error if the context does not have an ExecutionContext.
   */
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  /**
   * @see {@link https://hono.dev/docs/api/context#res}
   * The Response object for the current request.
   */
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers()
    });
  }
  /**
   * Sets the Response object for the current request.
   *
   * @param _res - The Response object to set.
   */
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  /**
   * `.render()` can create a response within a layout.
   *
   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   return c.render('Hello!')
   * })
   * ```
   */
  render = /* @__PURE__ */ __name((...args3) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args3);
  }, "render");
  /**
   * Sets the layout for the response.
   *
   * @param layout - The layout to set.
   * @returns The layout function.
   */
  setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, "setLayout");
  /**
   * Gets the current layout for the response.
   *
   * @returns The current layout function.
   */
  getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
  /**
   * `.setRenderer()` can set the layout in the custom middleware.
   *
   * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
   *
   * @example
   * ```tsx
   * app.use('*', async (c, next) => {
   *   c.setRenderer((content) => {
   *     return c.html(
   *       <html>
   *         <body>
   *           <p>{content}</p>
   *         </body>
   *       </html>
   *     )
   *   })
   *   await next()
   * })
   * ```
   */
  setRenderer = /* @__PURE__ */ __name((renderer) => {
    this.#renderer = renderer;
  }, "setRenderer");
  /**
   * `.header()` can set headers.
   *
   * @see {@link https://hono.dev/docs/api/context#header}
   *
   * @example
   * ```ts
   * app.get('/welcome', (c) => {
   *   // Set headers
   *   c.header('X-Message', 'Hello!')
   *   c.header('Content-Type', 'text/plain')
   *
   *   return c.body('Thank you for coming')
   * })
   * ```
   */
  header = /* @__PURE__ */ __name((name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
    if (value === void 0) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  }, "header");
  status = /* @__PURE__ */ __name((status) => {
    this.#status = status;
  }, "status");
  /**
   * `.set()` can set the value specified by the key.
   *
   * @see {@link https://hono.dev/docs/api/context#set-get}
   *
   * @example
   * ```ts
   * app.use('*', async (c, next) => {
   *   c.set('message', 'Hono is hot!!')
   *   await next()
   * })
   * ```
   */
  set = /* @__PURE__ */ __name((key, value) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key, value);
  }, "set");
  /**
   * `.get()` can use the value specified by the key.
   *
   * @see {@link https://hono.dev/docs/api/context#set-get}
   *
   * @example
   * ```ts
   * app.get('/', (c) => {
   *   const message = c.get('message')
   *   return c.text(`The message is "${message}"`)
   * })
   * ```
   */
  get = /* @__PURE__ */ __name((key) => {
    return this.#var ? this.#var.get(key) : void 0;
  }, "get");
  /**
   * `.var` can access the value of a variable.
   *
   * @see {@link https://hono.dev/docs/api/context#var}
   *
   * @example
   * ```ts
   * const result = c.var.client.oneMethod()
   * ```
   */
  // c.var.propName is a read-only
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = /* @__PURE__ */ __name((...args3) => this.#newResponse(...args3), "newResponse");
  /**
   * `.body()` can return the HTTP response.
   * You can set headers with `.header()` and set HTTP status code with `.status`.
   * This can also be set in `.text()`, `.json()` and so on.
   *
   * @see {@link https://hono.dev/docs/api/context#body}
   *
   * @example
   * ```ts
   * app.get('/welcome', (c) => {
   *   // Set headers
   *   c.header('X-Message', 'Hello!')
   *   c.header('Content-Type', 'text/plain')
   *   // Set HTTP status code
   *   c.status(201)
   *
   *   // Return the response body
   *   return c.body('Thank you for coming')
   * })
   * ```
   */
  body = /* @__PURE__ */ __name((data, arg, headers) => this.#newResponse(data, arg, headers), "body");
  /**
   * `.text()` can render text as `Content-Type:text/plain`.
   *
   * @see {@link https://hono.dev/docs/api/context#text}
   *
   * @example
   * ```ts
   * app.get('/say', (c) => {
   *   return c.text('Hello!')
   * })
   * ```
   */
  text = /* @__PURE__ */ __name((text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(
      text,
      arg,
      setDefaultContentType(TEXT_PLAIN, headers)
    );
  }, "text");
  /**
   * `.json()` can render JSON as `Content-Type:application/json`.
   *
   * @see {@link https://hono.dev/docs/api/context#json}
   *
   * @example
   * ```ts
   * app.get('/api', (c) => {
   *   return c.json({ message: 'Hello!' })
   * })
   * ```
   */
  json = /* @__PURE__ */ __name((object, arg, headers) => {
    return this.#newResponse(
      JSON.stringify(object),
      arg,
      setDefaultContentType("application/json", headers)
    );
  }, "json");
  html = /* @__PURE__ */ __name((html, arg, headers) => {
    const res = /* @__PURE__ */ __name((html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  }, "html");
  /**
   * `.redirect()` can Redirect, default status code is 302.
   *
   * @see {@link https://hono.dev/docs/api/context#redirect}
   *
   * @example
   * ```ts
   * app.get('/redirect', (c) => {
   *   return c.redirect('/')
   * })
   * app.get('/redirect-permanently', (c) => {
   *   return c.redirect('/', 301)
   * })
   * ```
   */
  redirect = /* @__PURE__ */ __name((location, status) => {
    const locationString = String(location);
    this.header(
      "Location",
      // Multibyes should be encoded
      // eslint-disable-next-line no-control-regex
      !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
    );
    return this.newResponse(null, status ?? 302);
  }, "redirect");
  /**
   * `.notFound()` can return the Not Found Response.
   *
   * @see {@link https://hono.dev/docs/api/context#notfound}
   *
   * @example
   * ```ts
   * app.get('/notfound', (c) => {
   *   return c.notFound()
   * })
   * ```
   */
  notFound = /* @__PURE__ */ __name(() => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  }, "notFound");
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
  static {
    __name(this, "UnsupportedPathError");
  }
};

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = /* @__PURE__ */ __name((c) => {
  return c.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = class _Hono {
  static {
    __name(this, "_Hono");
  }
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  /*
    This class is like an abstract class and does not have a router.
    To use it, inherit the class and implement router in the constructor.
  */
  router;
  getPath;
  // Cannot use `#` because it requires visibility at JavaScript runtime.
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args3) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args3.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone3 = new _Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone3.errorHandler = this.errorHandler;
    clone3.#notFoundHandler = this.#notFoundHandler;
    clone3.routes = this.routes;
    return clone3;
  }
  #notFoundHandler = notFoundHandler;
  // Cannot use `#` because it requires visibility at JavaScript runtime.
  errorHandler = errorHandler;
  /**
   * `.route()` allows grouping other Hono instance in routes.
   *
   * @see {@link https://hono.dev/docs/api/routing#grouping}
   *
   * @param {string} path - base Path
   * @param {Hono} app - other Hono instance
   * @returns {Hono} routed Hono instance
   *
   * @example
   * ```ts
   * const app = new Hono()
   * const app2 = new Hono()
   *
   * app2.get("/user", (c) => c.text("user"))
   * app.route("/api", app2) // GET /api/user
   * ```
   */
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  /**
   * `.basePath()` allows base paths to be specified.
   *
   * @see {@link https://hono.dev/docs/api/routing#base-path}
   *
   * @param {string} path - base Path
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * const api = new Hono().basePath('/api')
   * ```
   */
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  /**
   * `.onError()` handles an error and returns a customized Response.
   *
   * @see {@link https://hono.dev/docs/api/hono#error-handling}
   *
   * @param {ErrorHandler} handler - request Handler for error
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * app.onError((err, c) => {
   *   console.error(`${err}`)
   *   return c.text('Custom Error Message', 500)
   * })
   * ```
   */
  onError = /* @__PURE__ */ __name((handler) => {
    this.errorHandler = handler;
    return this;
  }, "onError");
  /**
   * `.notFound()` allows you to customize a Not Found Response.
   *
   * @see {@link https://hono.dev/docs/api/hono#not-found}
   *
   * @param {NotFoundHandler} handler - request handler for not-found
   * @returns {Hono} changed Hono instance
   *
   * @example
   * ```ts
   * app.notFound((c) => {
   *   return c.text('Custom 404 Message', 404)
   * })
   * ```
   */
  notFound = /* @__PURE__ */ __name((handler) => {
    this.#notFoundHandler = handler;
    return this;
  }, "notFound");
  /**
   * `.mount()` allows you to mount applications built with other frameworks into your Hono application.
   *
   * @see {@link https://hono.dev/docs/api/hono#mount}
   *
   * @param {string} path - base Path
   * @param {Function} applicationHandler - other Request Handler
   * @param {MountOptions} [options] - options of `.mount()`
   * @returns {Hono} mounted Hono instance
   *
   * @example
   * ```ts
   * import { Router as IttyRouter } from 'itty-router'
   * import { Hono } from 'hono'
   * // Create itty-router application
   * const ittyRouter = IttyRouter()
   * // GET /itty-router/hello
   * ittyRouter.get('/hello', () => new Response('Hello from itty-router'))
   *
   * const app = new Hono()
   * app.mount('/itty-router', ittyRouter.handle)
   * ```
   *
   * @example
   * ```ts
   * const app = new Hono()
   * // Send the request to another application without modification.
   * app.mount('/app', anotherApp, {
   *   replaceRequest: (req) => req,
   * })
   * ```
   */
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = /* @__PURE__ */ __name((request3) => request3, "replaceRequest");
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request3) => {
        const url = new URL(request3.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request3);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request3, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request3, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request3, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request3, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context7 = await composed(c);
        if (!context7.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context7.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  /**
   * `.fetch()` will be entry point of your app.
   *
   * @see {@link https://hono.dev/docs/api/hono#fetch}
   *
   * @param {Request} request - request Object of request
   * @param {Env} Env - env Object
   * @param {ExecutionContext} - context of execution
   * @returns {Response | Promise<Response>} response of request
   *
   */
  fetch = /* @__PURE__ */ __name((request3, ...rest) => {
    return this.#dispatch(request3, rest[1], rest[0], request3.method);
  }, "fetch");
  /**
   * `.request()` is a useful method for testing.
   * You can pass a URL or pathname to send a GET request.
   * app will return a Response object.
   * ```ts
   * test('GET /hello is ok', async () => {
   *   const res = await app.request('/hello')
   *   expect(res.status).toBe(200)
   * })
   * ```
   * @see https://hono.dev/docs/api/hono#request
   */
  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  }, "request");
  /**
   * `.fire()` automatically adds a global fetch event listener.
   * This can be useful for environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.
   * @deprecated
   * Use `fire` from `hono/service-worker` instead.
   * ```ts
   * import { Hono } from 'hono'
   * import { fire } from 'hono/service-worker'
   *
   * const app = new Hono()
   * // ...
   * fire(app)
   * ```
   * @see https://hono.dev/docs/api/hono#fire
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
   * @see https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/
   */
  fire = /* @__PURE__ */ __name(() => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  }, "fire");
};

// node_modules/hono/dist/router/reg-exp-router/matcher.js
var emptyParam = [];
function match19(method, path) {
  const matchers = this.buildAllMatchers();
  const match22 = /* @__PURE__ */ __name(((method2, path2) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path2];
    if (staticMatch) {
      return staticMatch;
    }
    const match32 = path2.match(matcher[0]);
    if (!match32) {
      return [[], emptyParam];
    }
    const index = match32.indexOf("", 1);
    return [matcher[1][index], match32];
  }), "match2");
  this.match = match22;
  return match22(method, path);
}
__name(match19, "match");

// node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = /* @__PURE__ */ Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
__name(compareKey, "compareKey");
var Node = class _Node {
  static {
    __name(this, "_Node");
  }
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context7, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new _Node();
        if (name !== "") {
          node.#varIndex = context7.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new _Node();
      }
    }
    node.insert(restTokens, index, paramMap, context7, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  static {
    __name(this, "Trie");
  }
  #context = { varIndex: 0 };
  #root = new Node();
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map23 = handlerData[i][j]?.[1];
      if (!map23) {
        continue;
      }
      const keys9 = Object.keys(map23);
      for (let k = 0, len3 = keys9.length; k < len3; k++) {
        map23[keys9[k]] = paramReplacementMap[map23[keys9[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = class {
  static {
    __name(this, "RegExpRouter");
  }
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p) => re.test(p) && routes[m][p].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match = match19;
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    clearWildcardRegExpCache();
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  static {
    __name(this, "SmartRouter");
  }
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class _Node2 {
  static {
    __name(this, "_Node");
  }
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts3 = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts3.length; i < len; i++) {
      const p = parts3[i];
      const nextP = parts3[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new _Node2();
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts3 = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts3.length; i < len; i++) {
      const part = parts3[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts3.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  static {
    __name(this, "TrieRouter");
  }
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  static {
    __name(this, "Hono");
  }
  /**
   * Creates an instance of the Hono class.
   *
   * @param options - Optional configuration options for the Hono instance.
   */
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// worker/index.ts
var TaskSchedulerDO = class extends DurableObject {
  static {
    __name(this, "TaskSchedulerDO");
  }
  scheduler;
  app;
  runningEffects = /* @__PURE__ */ new Set();
  // Track which tasks have active Effects
  constructor(ctx, env) {
    super(ctx, env);
    this.scheduler = new ReliableScheduler(this.ctx.storage);
    this.app = new Hono2();
    this.resumeRunningTasks();
    this.scheduler.register(
      "agent-loop",
      (sched, taskId, params) => Effect_exports2.gen(function* () {
        const p = params;
        const complexity = p.complexity || "demo";
        const durationMs = p.durationMs || (complexity === "demo" && (p.namespace === "mission2" || p.mission === "level2") ? 1e3 + Math.random() * 4e3 : (() => {
          const durationMap = {
            "1s": 1e3,
            "10s": 1e4,
            demo: 6e4,
            // 60s for homepage
            realistic: 36e5,
            production: 6048e5,
            month: 2592e6,
            year: 31536e6
          };
          return durationMap[complexity] || 6e4;
        })());
        const stepCountMap = {
          "1s": 2,
          "10s": 3,
          demo: 5,
          realistic: 10,
          production: 20,
          month: 30,
          year: 50
        };
        const stepCount = p.stepCount || stepCountMap[complexity] || 5;
        const stepDuration = Math.floor(durationMs / stepCount);
        const stepTemplates = p.steps || [
          "researching",
          "analyzing",
          "synthesizing",
          "writing",
          "finalizing"
        ];
        const steps = stepTemplates.slice(0, stepCount);
        yield* Effect_exports2.promise(
          () => sched.runSteps(taskId, steps, {
            stepDuration,
            result: "Task finished successfully",
            autoComplete: true,
            // Library auto-completes
            onStep: /* @__PURE__ */ __name(async (stepName, stepIndex) => {
              const subSteps = complexity === "production" ? 5 : complexity === "realistic" ? 3 : 1;
              await sched.runSubSteps(
                taskId,
                stepName,
                stepIndex,
                steps.length,
                subSteps,
                stepDuration / subSteps
              );
            }, "onStep")
          })
        );
      })
    );
    this.scheduler.register(
      "mine-asteroid",
      (sched, taskId, params) => Effect_exports2.gen(function* () {
        const p = params;
        const asteroidId = p.asteroidId || "asteroid-1";
        const capacity = p.capacity || 10;
        const durationMs = p.durationMs || 2e4;
        const steps = [];
        for (let i = 0; i < capacity; i++) {
          steps.push(`mining-${i + 1}`);
        }
        const stepDuration = Math.floor(durationMs / capacity);
        yield* Effect_exports2.promise(
          () => sched.runSteps(taskId, steps, {
            stepDuration,
            autoComplete: false,
            onStep: /* @__PURE__ */ __name(async (stepName, stepIndex) => {
              await sched.checkpoint(taskId, "progress", {
                step: stepIndex + 1,
                total: capacity,
                asteroidId
              });
            }, "onStep")
          })
        );
        const globalTaskId = "global-state";
        let globalTask = yield* Effect_exports2.promise(() => sched.getTask(globalTaskId));
        if (!globalTask) {
          yield* Effect_exports2.promise(() => sched.runNow(globalTaskId, "global-state", {}, { maxRetries: Infinity }));
          yield* Effect_exports2.promise(() => new Promise((resolve) => setTimeout(resolve, 100)));
          globalTask = yield* Effect_exports2.promise(() => sched.getTask(globalTaskId));
        }
        const currentResources = (yield* Effect_exports2.promise(
          () => sched.getCheckpoint(globalTaskId, "resources")
        )) || 0;
        const newTotal = currentResources + capacity;
        yield* Effect_exports2.promise(
          () => sched.checkpoint(globalTaskId, "resources", newTotal)
        );
        yield* Effect_exports2.promise(
          () => sched.checkpoint(globalTaskId, "lastUpdate", Date.now())
        );
        yield* Effect_exports2.promise(() => sched.completeTask(taskId));
      })
    );
    this.scheduler.register(
      "craft-item",
      (sched, taskId, params) => Effect_exports2.gen(function* () {
        const p = params;
        const itemType = p.itemType || "laser_drill";
        const requiredOre = p.requiredOre || 50;
        const requiredEnergy = p.requiredEnergy || 20;
        const steps = ["check_inventory", "gather_materials", "refine", "assemble"];
        const stepDuration = 2e3;
        yield* Effect_exports2.promise(
          () => sched.runSteps(taskId, steps, {
            stepDuration,
            autoComplete: false,
            onStep: /* @__PURE__ */ __name(async (stepName, stepIndex) => {
              if (stepName === "check_inventory") {
                const inventory = await sched.getCheckpoint("global-state", "inventory") || { ore: 0, energy: 0 };
                if ((inventory.ore || 0) < requiredOre || (inventory.energy || 0) < requiredEnergy) {
                  await sched.pauseTask(taskId);
                  let attempts = 0;
                  while (attempts < 100) {
                    await new Promise((r) => setTimeout(r, 500));
                    const updatedInventory = await sched.getCheckpoint("global-state", "inventory") || { ore: 0, energy: 0 };
                    if ((updatedInventory.ore || 0) >= requiredOre && (updatedInventory.energy || 0) >= requiredEnergy) {
                      await sched.resumeTask(taskId);
                      break;
                    }
                    attempts++;
                  }
                }
              } else if (stepName === "gather_materials") {
                const inventory = await sched.getCheckpoint("global-state", "inventory") || { ore: 0, energy: 0 };
                inventory.ore = Math.max(0, (inventory.ore || 0) - requiredOre);
                inventory.energy = Math.max(0, (inventory.energy || 0) - requiredEnergy);
                await sched.checkpoint("global-state", "inventory", inventory);
              } else if (stepName === "assemble") {
                const inventory = await sched.getCheckpoint("global-state", "inventory") || { ore: 0, energy: 0, items: [] };
                if (!inventory.items) inventory.items = [];
                inventory.items.push({ type: itemType, quality: "rare" });
                await sched.checkpoint("global-state", "inventory", inventory);
                await sched.checkpoint(taskId, "item", { type: itemType, quality: "rare" });
              }
            }, "onStep")
          })
        );
        yield* Effect_exports2.promise(() => sched.completeTask(taskId));
      })
    );
    this.scheduler.register(
      "trade-item",
      (sched, taskId, params) => Effect_exports2.gen(function* () {
        const p = params;
        const itemType = p.itemType || null;
        const sellPrice = p.sellPrice || 100;
        const inventory = (yield* Effect_exports2.promise(() => sched.getCheckpoint("global-state", "inventory"))) || { items: [] };
        if (!inventory.items) inventory.items = [];
        let itemIndex = -1;
        if (itemType) {
          itemIndex = inventory.items.findIndex((item) => item.type === itemType);
        } else if (inventory.items.length > 0) {
          itemIndex = 0;
        }
        if (itemIndex >= 0) {
          inventory.items.splice(itemIndex, 1);
          yield* Effect_exports2.promise(() => sched.checkpoint("global-state", "inventory", inventory));
          const currentMoney = (yield* Effect_exports2.promise(() => sched.getCheckpoint("global-state", "money"))) || 0;
          yield* Effect_exports2.promise(() => sched.checkpoint("global-state", "money", currentMoney + sellPrice));
          yield* Effect_exports2.promise(() => sched.checkpoint(taskId, "sold", { price: sellPrice }));
        }
        yield* Effect_exports2.promise(() => sched.completeTask(taskId));
      })
    );
    const doInstance = this;
    this.scheduler.register(
      "mine-resource-loop",
      (sched, taskId, params) => Effect_exports2.gen(function* () {
        const p = params;
        const nodeId = p.nodeId || "copper";
        const yieldAmount = p.yield || 1;
        const timeMs = p.timeMs || 4e3;
        let cycle = (yield* Effect_exports2.promise(() => sched.getCheckpoint(taskId, "cycle"))) || 0;
        while (true) {
          const task = yield* Effect_exports2.promise(() => sched.getTask(taskId));
          if (!task || task.status === "paused" || task.status === "failed") {
            return;
          }
          yield* Effect_exports2.promise(
            () => sched.checkpoint(taskId, "step", `mining-${nodeId}`)
          );
          yield* Effect_exports2.promise(
            () => new Promise((r) => setTimeout(r, timeMs))
          );
          const taskAfterWait = yield* Effect_exports2.promise(() => sched.getTask(taskId));
          if (!taskAfterWait || taskAfterWait.status === "paused" || taskAfterWait.status === "failed") {
            return;
          }
          const globalTaskId = `mission4-global-state`;
          let globalTask = yield* Effect_exports2.promise(() => sched.getTask(globalTaskId));
          if (!globalTask || globalTask.status === "completed" || globalTask.status === "failed") {
            const savedResources = globalTask?.progress?.resources;
            if (globalTask) {
              yield* Effect_exports2.promise(() => sched.cancelTask(globalTaskId));
              yield* Effect_exports2.promise(() => new Promise((r) => setTimeout(r, 100)));
            }
            yield* Effect_exports2.promise(
              () => sched.runNow(globalTaskId, "global-state", { namespace: "mission4" }, { maxRetries: Infinity })
            );
            yield* Effect_exports2.promise(() => new Promise((r) => setTimeout(r, 200)));
            globalTask = yield* Effect_exports2.promise(() => sched.getTask(globalTaskId));
            if (savedResources !== void 0 && globalTask) {
              const resourcesToRestore = typeof savedResources === "number" ? { copper: savedResources } : savedResources;
              yield* Effect_exports2.promise(() => sched.checkpoint(globalTaskId, "resources", resourcesToRestore));
            }
          }
          if (globalTask) {
            const rawResources = yield* Effect_exports2.promise(
              () => sched.getCheckpoint(globalTaskId, "resources")
            );
            let currentResources;
            if (rawResources === void 0 || rawResources === null) {
              currentResources = { copper: 0 };
            } else if (typeof rawResources === "number") {
              currentResources = { copper: rawResources };
            } else {
              currentResources = rawResources;
            }
            const resourceType = nodeId;
            currentResources[resourceType] = (currentResources[resourceType] || 0) + yieldAmount;
            currentResources.copper = (currentResources.copper || 0) + yieldAmount;
            yield* Effect_exports2.promise(
              () => sched.checkpoint(globalTaskId, "resources", currentResources)
            );
            yield* Effect_exports2.promise(() => doInstance.triggerBroadcast());
          }
          cycle++;
          yield* Effect_exports2.promise(
            () => sched.checkpoint(taskId, "cycle", cycle)
          );
          yield* Effect_exports2.promise(() => doInstance.triggerBroadcast());
        }
      })
    );
    this.scheduler.register(
      "sell-miner",
      (sched, taskId, params) => Effect_exports2.gen(function* () {
        const p = params;
        const taskIdToCancel = p.taskIdToCancel;
        const copperToAdd = p.copperToAdd || 0;
        if (!taskIdToCancel || copperToAdd <= 0) {
          yield* Effect_exports2.promise(() => sched.completeTask(taskId));
          return;
        }
        yield* Effect_exports2.promise(() => sched.cancelTask(taskIdToCancel));
        const globalTaskId = `mission4-global-state`;
        let globalTask = yield* Effect_exports2.promise(() => sched.getTask(globalTaskId));
        if (!globalTask || globalTask.status === "completed" || globalTask.status === "failed") {
          const savedResources = globalTask?.progress?.resources;
          if (globalTask) {
            yield* Effect_exports2.promise(() => sched.cancelTask(globalTaskId));
            yield* Effect_exports2.promise(() => new Promise((r) => setTimeout(r, 100)));
          }
          yield* Effect_exports2.promise(
            () => sched.runNow(globalTaskId, "global-state", { namespace: "mission4" }, { maxRetries: Infinity })
          );
          yield* Effect_exports2.promise(() => new Promise((r) => setTimeout(r, 200)));
          globalTask = yield* Effect_exports2.promise(() => sched.getTask(globalTaskId));
          if (savedResources !== void 0 && globalTask) {
            const resourcesToRestore = typeof savedResources === "number" ? { copper: savedResources } : savedResources;
            yield* Effect_exports2.promise(() => sched.checkpoint(globalTaskId, "resources", resourcesToRestore));
          }
        }
        if (globalTask) {
          const rawResources = yield* Effect_exports2.promise(
            () => sched.getCheckpoint(globalTaskId, "resources")
          );
          let currentResources;
          if (rawResources === void 0 || rawResources === null) {
            currentResources = { copper: 0 };
          } else if (typeof rawResources === "number") {
            currentResources = { copper: rawResources };
          } else {
            currentResources = rawResources;
          }
          currentResources.copper = (currentResources.copper || 0) + copperToAdd;
          yield* Effect_exports2.promise(
            () => sched.checkpoint(globalTaskId, "resources", currentResources)
          );
          yield* Effect_exports2.promise(() => doInstance.triggerBroadcast());
        }
        yield* Effect_exports2.promise(() => sched.completeTask(taskId));
      })
    );
    this.scheduler.register(
      "global-state",
      (sched, taskId, params) => Effect_exports2.gen(function* () {
        const resources = yield* Effect_exports2.promise(() => sched.getCheckpoint(taskId, "resources"));
        if (resources === void 0 || typeof resources === "number") {
          const initialResources = typeof resources === "number" ? { copper: resources } : { copper: 0 };
          yield* Effect_exports2.promise(() => sched.checkpoint(taskId, "resources", initialResources));
        }
        const speed = yield* Effect_exports2.promise(() => sched.getCheckpoint(taskId, "speedMultiplier"));
        if (speed === void 0) {
          yield* Effect_exports2.promise(() => sched.checkpoint(taskId, "speedMultiplier", 1));
        }
        while (true) {
          yield* Effect_exports2.promise(() => new Promise((r) => setTimeout(r, 3e4)));
          const task = yield* Effect_exports2.promise(() => sched.getTask(taskId));
          if (!task || task.status === "failed") return;
          if (task.progress?.completed === true) {
            yield* Effect_exports2.promise(() => sched.checkpoint(taskId, "completed", false));
          }
        }
      })
    );
    this.scheduler.register(
      "speed-upgrade",
      (sched, taskId, params) => Effect_exports2.gen(function* () {
        const p = params;
        const cost = p.cost || 0;
        const globalTaskId = "mission4-global-state";
        const globalTask = yield* Effect_exports2.promise(() => sched.getTask(globalTaskId));
        if (!globalTask) {
          yield* Effect_exports2.promise(() => sched.completeTask(taskId));
          return;
        }
        const currentResources = (yield* Effect_exports2.promise(
          () => sched.getCheckpoint(globalTaskId, "resources")
        )) || { copper: 0 };
        const currentSpeed = (yield* Effect_exports2.promise(
          () => sched.getCheckpoint(globalTaskId, "speedMultiplier")
        )) || 1;
        if ((currentResources.copper || 0) < cost) {
          yield* Effect_exports2.promise(() => sched.completeTask(taskId));
          return;
        }
        currentResources.copper = (currentResources.copper || 0) - cost;
        yield* Effect_exports2.promise(() => sched.checkpoint(globalTaskId, "resources", currentResources));
        yield* Effect_exports2.promise(() => sched.checkpoint(globalTaskId, "speedMultiplier", currentSpeed + 1));
        yield* Effect_exports2.promise(() => doInstance.triggerBroadcast());
        yield* Effect_exports2.promise(() => sched.completeTask(taskId));
      })
    );
    this.setupRoutes();
  }
  // Resume running tasks after DO restart - only for infinite-loop task types
  // Also recover failed tasks that should be running
  async resumeRunningTasks() {
    const RESUMABLE_TASKS = ["mine-resource-loop", "global-state"];
    const tasks = await this.scheduler.getTasks();
    for (const task of tasks) {
      if (!this.runningEffects.has(task.taskId) && RESUMABLE_TASKS.includes(task.taskName) && (task.status === "running" || task.status === "failed")) {
        if (task.status === "failed") {
          await this.scheduler.checkpoint(task.taskId, "_recovered", true);
        }
        this.runningEffects.add(task.taskId);
        this.runTaskHandler(task.taskId, task.taskName, task.params);
      }
    }
  }
  // Run a task handler and track it
  async runTaskHandler(taskId, taskName, params) {
    const handler = this.scheduler.getHandler(taskName);
    if (!handler) {
      this.runningEffects.delete(taskId);
      return;
    }
    try {
      await Effect_exports2.runPromise(handler(this.scheduler, taskId, params));
    } catch {
    } finally {
      this.runningEffects.delete(taskId);
    }
  }
  // Broadcast task updates to all connected clients
  broadcast(message) {
    const payload = JSON.stringify(message);
    const sockets = this.ctx.getWebSockets();
    for (const ws of sockets) {
      try {
        ws.send(payload);
      } catch (error) {
        console.error("[WS] Error broadcasting:", error);
      }
    }
  }
  // Helper to trigger broadcast from within task handlers
  async triggerBroadcast() {
    const tasks = await this.scheduler.getTasks();
    this.broadcast({
      type: "tasks",
      data: tasks.map((t) => this.formatTaskForUI(t))
    });
  }
  setupRoutes() {
    this.app.post("/task/start", async (c) => {
      const params = await c.req.json();
      const namespace = params.namespace || "task";
      const taskId = params.taskName === "global-state" ? namespace ? `${namespace}-global-state` : "global-state" : ReliableScheduler.generateTaskId(namespace);
      if (params.taskName === "mine-resource-loop" && params.cost !== void 0 && params.cost > 0) {
        const globalTaskId = namespace ? `${namespace}-global-state` : "global-state";
        let globalTask = await this.scheduler.getTask(globalTaskId);
        if (globalTask && (globalTask.status === "completed" || globalTask.status === "failed")) {
          const oldResources = await this.scheduler.getCheckpoint(globalTaskId, "resources") || { copper: 0 };
          await this.scheduler.cancelTask(globalTaskId);
          await this.scheduler.runNow(globalTaskId, "global-state", { namespace }, { maxRetries: Infinity });
          await new Promise((r) => setTimeout(r, 100));
          await this.scheduler.checkpoint(globalTaskId, "resources", oldResources);
          globalTask = await this.scheduler.getTask(globalTaskId);
        }
        if (!globalTask) {
          await this.scheduler.runNow(globalTaskId, "global-state", { namespace }, { maxRetries: Infinity });
          await new Promise((r) => setTimeout(r, 100));
          globalTask = await this.scheduler.getTask(globalTaskId);
        }
        if (globalTask) {
          const currentResources = await this.scheduler.getCheckpoint(globalTaskId, "resources") || {};
          const currentCopper = currentResources.copper || 0;
          if (currentCopper < params.cost) {
            return c.json({ error: `Insufficient resources. Need ${params.cost} Copper, have ${currentCopper}` }, 400);
          }
          currentResources.copper = currentCopper - params.cost;
          await this.scheduler.checkpoint(globalTaskId, "resources", currentResources);
        }
      }
      const isInfiniteLoop = params.taskName === "mine-resource-loop";
      await this.scheduler.runNow(
        taskId,
        params.taskName || "agent-loop",
        params,
        isInfiniteLoop ? { maxRetries: Infinity } : void 0
      );
      const tasks = await this.scheduler.getTasks();
      this.broadcast({
        type: "tasks",
        data: tasks.map((t) => this.formatTaskForUI(t))
      });
      return c.json({ taskId, status: "started" });
    });
    this.app.get("/task/status", async (c) => {
      const taskId = c.req.query("taskId");
      if (!taskId) {
        return c.json({ error: "Missing taskId" }, 400);
      }
      const task = await this.scheduler.getTask(taskId);
      if (!task) {
        return c.json({ error: "Task not found" }, 404);
      }
      return c.json(this.formatTaskForUI(task));
    });
    this.app.get("/tasks", async (c) => {
      const namespace = c.req.query("namespace");
      const tasks = await this.scheduler.getTasks();
      const filteredTasks = namespace ? tasks.filter((t) => t.taskId.startsWith(`${namespace}-`)) : tasks;
      return c.json(filteredTasks.map((t) => this.formatTaskForUI(t)));
    });
    this.app.post("/task/pause", async (c) => {
      const { taskId } = await c.req.json();
      if (!taskId) {
        return c.json({ error: "Missing taskId" }, 400);
      }
      const paused = await this.scheduler.pauseTask(taskId);
      if (!paused) {
        return c.json({ error: "Task not found or cannot be paused" }, 404);
      }
      const tasks = await this.scheduler.getTasks();
      this.broadcast({
        type: "tasks",
        data: tasks.map((t) => this.formatTaskForUI(t))
      });
      return c.json({ taskId, status: "paused" });
    });
    this.app.post("/task/resume", async (c) => {
      const { taskId } = await c.req.json();
      if (!taskId) {
        return c.json({ error: "Missing taskId" }, 400);
      }
      const resumed = await this.scheduler.resumeTask(taskId);
      if (!resumed) {
        return c.json({ error: "Task not found or not paused" }, 404);
      }
      const tasks = await this.scheduler.getTasks();
      this.broadcast({
        type: "tasks",
        data: tasks.map((t) => this.formatTaskForUI(t))
      });
      return c.json({ taskId, status: "resumed" });
    });
    this.app.post("/task/cancel", async (c) => {
      const { taskId } = await c.req.json();
      if (!taskId) {
        return c.json({ error: "Missing taskId" }, 400);
      }
      const cancelled = await this.scheduler.cancelTask(taskId);
      if (!cancelled) {
        return c.json({ error: "Task not found" }, 404);
      }
      const tasks = await this.scheduler.getTasks();
      this.broadcast({
        type: "tasks",
        data: tasks.map((t) => this.formatTaskForUI(t))
      });
      return c.json({ taskId, status: "cancelled" });
    });
    this.app.post("/tasks/clear", async (c) => {
      const count = await this.scheduler.clearCompleted();
      const tasks = await this.scheduler.getTasks();
      this.broadcast({
        type: "tasks",
        data: tasks.map((t) => this.formatTaskForUI(t))
      });
      return c.json({ count, status: "cleared" });
    });
    this.app.post("/tasks/reset", async (c) => {
      const { namespace } = await c.req.json();
      if (!namespace) {
        return c.json({ error: "Missing namespace" }, 400);
      }
      const allTasks = await this.scheduler.getTasks();
      const namespaceTasks = allTasks.filter(
        (t) => t.taskId.startsWith(`${namespace}-`)
      );
      let count = 0;
      for (const task of namespaceTasks) {
        await this.scheduler.cancelTask(task.taskId);
        count++;
      }
      const tasks = await this.scheduler.getTasks();
      this.broadcast({
        type: "tasks",
        data: tasks.map((t) => this.formatTaskForUI(t))
      });
      return c.json({ count, status: "reset" });
    });
    this.app.get("/ws", async (c) => {
      const upgradeHeader = c.req.header("upgrade");
      if (upgradeHeader !== "websocket") {
        return c.text("Expected WebSocket", 426);
      }
      const pair = new WebSocketPair();
      const client = pair[0];
      const server = pair[1];
      this.ctx.acceptWebSocket(server);
      const tasks = await this.scheduler.getTasks();
      server.send(JSON.stringify({
        type: "tasks",
        data: tasks.map((t) => this.formatTaskForUI(t))
      }));
      return new Response(null, {
        status: 101,
        webSocket: client
      });
    });
  }
  async fetch(request3) {
    return this.app.fetch(request3);
  }
  // Handle WebSocket close events (called by Durable Object runtime)
  async webSocketClose(ws, code, reason, wasClean) {
  }
  // Handle WebSocket error events (called by Durable Object runtime)
  async webSocketError(ws, error) {
    console.error("[WS] Error:", error);
  }
  // Handle WebSocket messages (called by Durable Object runtime)
  async webSocketMessage(ws, message) {
  }
  async alarm() {
    await this.scheduler.alarm();
    const tasks = await this.scheduler.getTasks();
    this.broadcast({
      type: "tasks",
      data: tasks.map((t) => this.formatTaskForUI(t))
    });
  }
  formatTaskForUI(task) {
    const formatted = this.scheduler.formatTaskForUI(task);
    formatted.complexity = task.params?.complexity || "demo";
    formatted.params = task.params;
    if (task.status === "failed" && task.progress?.error) {
      formatted.error = task.progress.error;
    }
    return formatted;
  }
};
var workerApp = new Hono2();
workerApp.on(["GET", "POST"], "/task/*", async (c) => {
  const env = c.env;
  const id = env.TASK_SCHEDULER_DO.idFromName("scheduler");
  const doInstance = env.TASK_SCHEDULER_DO.get(id);
  return await doInstance.fetch(c.req.raw);
});
workerApp.on(["GET", "POST"], "/tasks*", async (c) => {
  const env = c.env;
  const id = env.TASK_SCHEDULER_DO.idFromName("scheduler");
  const doInstance = env.TASK_SCHEDULER_DO.get(id);
  return await doInstance.fetch(c.req.raw);
});
workerApp.get("/ws", async (c) => {
  const env = c.env;
  const id = env.TASK_SCHEDULER_DO.idFromName("scheduler");
  const doInstance = env.TASK_SCHEDULER_DO.get(id);
  return await doInstance.fetch(c.req.raw);
});
var index_default = {
  async fetch(request3, env) {
    try {
      return await workerApp.fetch(request3, env);
    } catch (error) {
      console.error("Worker error:", error);
      return new Response(
        JSON.stringify({ error: "Service temporarily unavailable" }),
        {
          status: 503,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
  }
};
export {
  TaskSchedulerDO,
  index_default as default
};
//# sourceMappingURL=index.js.map
